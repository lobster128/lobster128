diff --git a/config.guess b/config.guess
index 1972fda8eb0..3a3c543ceb9 100755
--- a/config.guess
+++ b/config.guess
@@ -995,6 +995,9 @@ EOF
     k1om:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
+	lobster128:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
     loongarch32:Linux:*:* | loongarch64:Linux:*:* | loongarchx32:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
diff --git a/config.sub b/config.sub
index 38f3d037a78..9fe774727ee 100755
--- a/config.sub
+++ b/config.sub
@@ -1202,6 +1202,7 @@ case $cpu-$vendor in
 			| k1om \
 			| le32 | le64 \
 			| lm32 \
+			| lobster128 \
 			| loongarch32 | loongarch64 | loongarchx32 \
 			| m32c | m32r | m32rle \
 			| m5200 | m68000 | m680[012346]0 | m68360 | m683?2 | m68k \
diff --git a/gcc/config.gcc b/gcc/config.gcc
index 02f58970db0..814e9df3b2b 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -453,6 +453,10 @@ mips*-*-*)
 	extra_objs="frame-header-opt.o"
 	extra_options="${extra_options} g.opt fused-madd.opt mips/mips-tables.opt"
 	;;
+lobster128*)
+    cpu_type=lobster128
+	target_has_targetm_common=no
+    ;;
 loongarch*-*-*)
 	cpu_type=loongarch
 	extra_headers="larchintrin.h"
@@ -2502,7 +2506,12 @@ riscv*-*-freebsd*)
 	# automatically detect that GAS supports it, yet we require it.
 	gcc_cv_initfini_array=yes
 	;;
-
+lobster128*-*-linux* | lobster128*-*-elf*)
+	gas=yes
+	gnu_ld=yes
+	tm_file="${tm_file} dbxelf.h elfos.h newlib-stdint.h"
+	tmake_file="${tmake_file}"
+	;;
 loongarch*-*-linux*)
 	tm_file="dbxelf.h elfos.h gnu-user.h linux.h linux-android.h glibc-stdint.h ${tm_file}"
 	tm_file="${tm_file} loongarch/gnu-user.h loongarch/linux.h"
diff --git a/gcc/config/lobster128/constraints.md b/gcc/config/lobster128/constraints.md
new file mode 100644
index 00000000000..90d587137a2
--- /dev/null
+++ b/gcc/config/lobster128/constraints.md
@@ -0,0 +1,50 @@
+;; Constraints for Vitesse IQ2000 processors
+;; Copyright (C) 2011-2022 Free Software Foundation, Inc.
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+;; Integer constraints.
+(define_constraint "O"
+  "Zero."
+  (and (match_code "const_int")
+       (match_test "ival == 0")))
+
+(define_constraint "I"
+  "A 16-bit signed integer."
+  (and (match_code "const_int")
+       (match_test "IN_RANGE (ival, -32768, 32767)")))
+
+(define_constraint "K"
+  "A 16-bit unsigned integer"
+  (and (match_code "const_int")
+       (match_test "IN_RANGE (ival, 0, 65535)")))
+
+(define_constraint "J"
+  "A 32-bit constant."
+  (and (match_code "const_int")
+       (match_test "IN_RANGE (ival, 0, 0xffffffff)")))
+
+(define_constraint "L"
+  "A 64-bit constant."
+  (and (match_code "const_int")
+       (match_test "IN_RANGE (ival, 0, 0xffffffffffffffff)")))
+
+(define_constraint "N"
+  "Any constant whose lower or upper 16 bits are 0xffff."
+  (and (match_code "const_int")
+       (ior (match_test "(ival & 0xffff) == 0xffff")
+	    (match_test "(ival & 0xffff0000) == 0xffff0000"))))
diff --git a/gcc/config/lobster128/lobster128-protos.h b/gcc/config/lobster128/lobster128-protos.h
new file mode 100644
index 00000000000..1bf398e6d29
--- /dev/null
+++ b/gcc/config/lobster128/lobster128-protos.h
@@ -0,0 +1,20 @@
+/* Definitions of target machine for GNU compiler for lobster128.
+   Copyright (C) 2003-2022 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+extern int lobster128_initial_elimination_offset (int from, int to);
diff --git a/gcc/config/lobster128/lobster128.cc b/gcc/config/lobster128/lobster128.cc
new file mode 100644
index 00000000000..90436bf6ce6
--- /dev/null
+++ b/gcc/config/lobster128/lobster128.cc
@@ -0,0 +1,206 @@
+/* Subroutines used for code generation on Vitesse lobster128 processors
+   Copyright (C) 2003-2022 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#define IN_TARGET_CODE 1
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "backend.h"
+#include "target.h"
+#include "rtl.h"
+#include "tree.h"
+#include "stringpool.h"
+#include "attribs.h"
+#include "df.h"
+#include "memmodel.h"
+#include "tm_p.h"
+#include "optabs.h"
+#include "regs.h"
+#include "emit-rtl.h"
+#include "recog.h"
+#include "diagnostic-core.h"
+#include "stor-layout.h"
+#include "calls.h"
+#include "varasm.h"
+#include "output.h"
+#include "insn-attr.h"
+#include "explow.h"
+#include "expr.h"
+#include "langhooks.h"
+#include "builtins.h"
+
+/* This file should be included last.  */
+#include "target-def.h"
+
+/* Global variables for machine-dependent things.  */
+
+/* Per-function machine data.  */
+struct GTY (()) machine_function
+ {
+   /* Number of bytes saved on the stack for callee saved registers.  */
+   int callee_saved_reg_size;
+
+   /* Number of bytes saved on the stack for local variables.  */
+   int local_vars_size;
+
+   /* The sum of 2 sizes: locals vars and padding byte for saving the
+    * registers.  Used in expand_prologue () and expand_epilogue().  */
+   int size_for_adjusting_sp;
+ };
+
+/* Zero initialization is OK for all current fields.  */
+static struct machine_function *
+losbter128_init_machine_status (void)
+{
+  return ggc_cleared_alloc<machine_function> ();
+}
+
+/* Helper function for `lobster128_legitimate_address_p'.  */
+
+static bool
+lobster128_reg_ok_for_base_p (const_rtx reg, bool strict_p)
+{
+  int regno = REGNO (reg);
+
+  if (strict_p)
+    return REGNO_OK_FOR_BASE_P (regno)
+	   || REGNO_OK_FOR_BASE_P (reg_renumber[regno]);
+  else    
+    return !HARD_REGISTER_NUM_P (regno)
+	   || REGNO_OK_FOR_BASE_P (regno);
+}
+
+/* Worker function for TARGET_LEGITIMATE_ADDRESS_P.  */
+
+static bool
+lobster128_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,
+			    rtx x, bool strict_p,
+			    addr_space_t as)
+{
+  gcc_assert (ADDR_SPACE_GENERIC_P (as));
+
+  if (GET_CODE(x) == PLUS
+      && REG_P (XEXP (x, 0))
+      && lobster128_reg_ok_for_base_p (XEXP (x, 0), strict_p)
+      && CONST_INT_P (XEXP (x, 1))
+      && IN_RANGE (INTVAL (XEXP (x, 1)), -32768, 32767))
+    return true;
+  if (REG_P (x) && lobster128_reg_ok_for_base_p (x, strict_p))
+    return true;
+  if (GET_CODE (x) == SYMBOL_REF
+      || GET_CODE (x) == LABEL_REF
+      || GET_CODE (x) == CONST)
+    return true;
+  return false;
+}
+
+
+/* Define how to find the value returned by a function.
+   VALTYPE is the data type of the value (as a tree).
+   If the precise function being called is known, FUNC is its
+   FUNCTION_DECL; otherwise, FUNC is 0.  
+
+   We always return values in register RETURN_ADDRESS for moxie.  */
+static rtx
+lobster128_function_value (const_tree valtype, 
+		      const_tree fntype_or_decl ATTRIBUTE_UNUSED,
+		      bool outgoing ATTRIBUTE_UNUSED)
+{
+  return gen_rtx_REG (TYPE_MODE (valtype), GP_ARG_FIRST);
+}
+
+/* Handle TARGET_FUNCTION_VALUE_REGNO_P.
+   We always return values in register GP_RET_FIRST for moxie.  */
+static bool
+lobster128_function_value_regno_p (const unsigned int regno)
+{
+  return (regno >= GP_RET_FIRST && regno <= GP_RET_LAST);
+}
+
+/* The TARGET_OPTION_OVERRIDE worker.  */
+static void
+lobster128_option_override (void)
+{
+  /* Set the per-function-data initializer.  */
+  init_machine_status = losbter128_init_machine_status;
+}
+
+/* Compute the size of the local area and the size to be adjusted by the
+ * prologue and epilogue.  */
+
+static void
+lobster128_compute_frame (void)
+{
+  /* For aligning the local variables.  */
+  int stack_alignment = STACK_BOUNDARY / BITS_PER_UNIT;
+  /* Padding needed for each element of the frame.  */
+  cfun->machine->local_vars_size = get_frame_size ();
+
+  /* Align to the stack alignment.  */
+  int padding_locals = cfun->machine->local_vars_size % stack_alignment;
+  if (padding_locals)
+    padding_locals = stack_alignment - padding_locals;
+
+  cfun->machine->local_vars_size += padding_locals;
+
+  cfun->machine->callee_saved_reg_size = 0;
+
+  /* Save callee-saved registers.  */
+  for (int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+    if (df_regs_ever_live_p (regno) && (! call_used_or_fixed_reg_p (regno)))
+      cfun->machine->callee_saved_reg_size += 4;
+
+  cfun->machine->size_for_adjusting_sp = 
+    crtl->args.pretend_args_size
+    + cfun->machine->local_vars_size 
+    + (ACCUMULATE_OUTGOING_ARGS
+       ? (HOST_WIDE_INT) crtl->outgoing_args_size : 0);
+}
+
+int
+lobster128_initial_elimination_offset (int from, int to)
+{
+  int ret;
+  
+  if ((from) == FRAME_POINTER_REGNUM && (to) == HARD_FRAME_POINTER_REGNUM)
+    {
+      /* Compute this since we need to use cfun->machine->local_vars_size.  */
+      lobster128_compute_frame ();
+      ret = -cfun->machine->callee_saved_reg_size;
+    }
+  else if ((from) == ARG_POINTER_REGNUM && (to) == HARD_FRAME_POINTER_REGNUM)
+    ret = 0x00;
+  else
+    ret = 0x00; //abort ();
+  return ret;
+}
+
+#undef TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P
+#define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P lobster128_legitimate_address_p
+#undef TARGET_FUNCTION_VALUE
+#define TARGET_FUNCTION_VALUE lobster128_function_value
+#undef TARGET_FUNCTION_VALUE_REGNO_P
+#define TARGET_FUNCTION_VALUE_REGNO_P lobster128_function_value_regno_p
+#undef TARGET_OPTION_OVERRIDE
+#define TARGET_OPTION_OVERRIDE lobster128_option_override
+
+struct gcc_target targetm = TARGET_INITIALIZER;
+
+#include "gt-lobster128.h"
diff --git a/gcc/config/lobster128/lobster128.h b/gcc/config/lobster128/lobster128.h
new file mode 100644
index 00000000000..bd663432167
--- /dev/null
+++ b/gcc/config/lobster128/lobster128.h
@@ -0,0 +1,491 @@
+/* Definitions of target machine for GNU compiler.  
+   lobster128 processors
+   Copyright (C) 2003-2022 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Driver configuration.  */
+
+/* A generic LIB_SPEC with -leval and --*group tacked on.  */
+#undef  LIB_SPEC
+#define LIB_SPEC "%{!shared:%{!symbolic:--start-group -lc -leval -lgcc --end-group}}"
+
+#undef STARTFILE_SPEC
+#undef ENDFILE_SPEC
+
+#undef  LINK_SPEC
+#define LINK_SPEC "%{h*} %{v:-V} \
+		   %{static:-Bstatic} %{shared:-shared} %{symbolic:-Bsymbolic}"
+
+
+/* Run-time target specifications.  */
+
+#define TARGET_CPU_CPP_BUILTINS()               \
+  do                                            \
+    {                                           \
+      builtin_define ("__lobster128__"); 		\
+      builtin_assert ("cpu=lobster128"); 		\
+      builtin_assert ("machine=lobster128");	\
+    }                                           \
+  while (0)
+
+/* Allow pairs of registers to be used, which is the intent of the default.  */
+#define MAX_FIXED_MODE_SIZE GET_MODE_BITSIZE (TImode)
+
+
+/* Layout of Source Language Data Types.  */
+
+#define INT_TYPE_SIZE 32
+
+#define SHORT_TYPE_SIZE 16
+
+#define LONG_TYPE_SIZE 64
+
+#define LONG_LONG_TYPE_SIZE 64
+
+#define FLOAT_TYPE_SIZE 32
+
+#define DOUBLE_TYPE_SIZE 64
+
+#define LONG_DOUBLE_TYPE_SIZE	64
+
+#define DEFAULT_SIGNED_CHAR 1
+
+/* Number of storage units in a word; normally the size of a
+   general-purpose register, a power of two from 1 or 8.  */
+#define UNITS_PER_WORD 8
+
+#define POINTER_SIZE 8
+
+/* Define this macro to the minimum alignment enforced by hardware
+   for the stack pointer on this machine.  The definition is a C
+   expression for the desired alignment (measured in bits).  */
+#define STACK_BOUNDARY 8
+
+/* Normal alignment required for function parameters on the stack, in
+   bits.  All stack parameters receive at least this much alignment
+   regardless of data type.  */
+#define PARM_BOUNDARY 8
+
+/* No data type wants to be aligned rounder than this.  */
+#define BIGGEST_ALIGNMENT 128
+
+/* The best alignment to use in cases where we have a choice.  */
+#define FASTEST_ALIGNMENT 64
+
+/* Set this nonzero if move instructions will actually fail to work
+   when given unaligned data.  */
+#define STRICT_ALIGNMENT 0
+
+/* Storage Layout */
+
+#define BITS_BIG_ENDIAN 0
+#define BYTES_BIG_ENDIAN 0
+#define WORDS_BIG_ENDIAN 0
+
+/* Alignment required for a function entry point, in bits.  */
+#define FUNCTION_BOUNDARY 8
+
+/* Define this macro as a C expression which is nonzero if accessing
+   less than a word of memory (i.e. a `char' or a `short') is no
+   faster than accessing a word of memory.  */
+#define SLOW_BYTE_ACCESS 1
+
+/* Register Basics.  */
+
+/* Number of hardware registers known to the compiler..
+   We have 128 registers to choose from.  */
+#define FIRST_PSEUDO_REGISTER 128
+
+#define FIXED_REGISTERS							\
+{									\
+  1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,			\
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,			\
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     \
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     \
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     \
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     \
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     \
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     \
+}
+
+/* First 16 registers (excluding R0) are used for call arguments */
+#define CALL_USED_REGISTERS						\
+{									\
+  1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,			\
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,			\
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     \
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     \
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     \
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     \
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     \
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     \
+}
+
+
+/* Order of allocation of registers.  */
+
+#define REG_ALLOC_ORDER							\
+{ \
+  /* Hardware tied registers */ \
+  0,  1,  2,  3,  4, \
+  /* Call-arguments */ \
+  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,	\
+  /* Call-saved/clobered */ \
+  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,	\
+  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,	\
+  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,	\
+  64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,	\
+  80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,	\
+  96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111,	\
+ 112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127	\
+}
+
+
+
+#define AVOID_CCMODE_COPIES 1
+
+
+/* Register Classes.  */
+
+enum reg_class
+{
+  NO_REGS,			/* No registers in set.  */
+  ZERO_REGS,    /* Register used for 0 */
+  PC_REGS,      /* Program Counter register */
+  SP_REGS,      /* Stack pointer register */
+  RA_REGS,      /* Return address register */
+  SB_REGS,      /* Sibling call register */
+  SC_REGS,      /* Static chain register */
+  AR_REGS,      /* Argument registers */
+  GR_REGS,			/* Integer registers.  */
+  ALL_REGS,			/* All registers.  */
+  LIM_REG_CLASSES		/* Max value + 1.  */
+};
+
+#define REG_CLASS_CONTENTS \
+{ { 0x00000000, 0x00000000, 0x00000000, 0x00000000  }, /* Empty */			   \
+  { 0x00000001, 0x00000000, 0x00000000, 0x00000000  }, /* ZERO */ \
+  { 0x00000002, 0x00000000, 0x00000000, 0x00000000  }, /* PC */ \
+  { 0x00000004, 0x00000000, 0x00000000, 0x00000000  }, /* SP */	                   \
+  { 0x00000008, 0x00000000, 0x00000000, 0x00000000  }, /* RA */ \
+  { 0x00000010, 0x00000000, 0x00000000, 0x00000000  }, /* SB */ \
+  { 0x00000020, 0x00000000, 0x00000000, 0x00000000  }, /* SC */ \
+  { 0x0000FF00, 0x00000000, 0x00000000, 0x00000000 }, /* AR */                        \
+  { 0xFFFFFF80, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF },  /* GR */              \
+  { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF }  /* All registers */              \
+}
+
+#define GENERAL_REGS GR_REGS
+
+#define N_REG_CLASSES (int) LIM_REG_CLASSES
+
+#define REG_CLASS_NAMES						\
+{								\
+  "NO_REGS",							\
+  "ZERO_REGS",            \
+  "PC_REGS",              \
+  "SP_REGS",              \
+  "RA_REGS",              \
+  "SB_REGS",              \
+  "SC_REGS",              \
+  "AR_REGS",              \
+  "GR_REGS",              \
+  "ALL_REGS"              \
+}
+
+#define REGNO_REG_CLASS(R) \
+  ((R == ZERO_REGNUM) ? ZERO_REGS : \
+  (R == PROGRAM_COUNTER_REGNUM) ? PC_REGS : \
+  (R == STACK_POINTER_REGNUM) ? SP_REGS : \
+  (R == RETURN_ADDRESS_POINTER_REGNUM) ? RA_REGS : \
+  (R == SIBCALL_RETURN_REGNUM) ? SB_REGS : \
+  (R == STATIC_CHAIN_REGNUM) ? SC_REGS : \
+  (R == ARG_POINTER_REGNUM) ? SC_REGS : \
+  (R >= GP_FIRST && R <= GP_LAST) ? GR_REGS : NO_REGS)
+
+
+/* The Overall Framework of an Assembler File */
+
+#define FILE_ASM_OP     "\t.file\n"
+
+/* Switch to the text or data segment.  */
+#define TEXT_SECTION_ASM_OP  "\t.text"
+#define DATA_SECTION_ASM_OP  "\t.data"
+
+/* Assembler Commands for Alignment */
+
+#define ASM_OUTPUT_ALIGN(STREAM,POWER) \
+	fprintf (STREAM, "\t.p2align\t%d\n", POWER);
+
+/* A macro whose definition is the name of the class to which a
+   valid base register must belong.  A base register is one used in
+   an address which is the register value plus a displacement.  */
+#define BASE_REG_CLASS GR_REGS
+
+/* A macro whose definition is the name of the class to which a
+   valid index register must belong.  An index register is one used
+   in an address where its value is either multiplied by a scale
+   factor or added to another register (as well as added to a
+   displacement).  */
+#define INDEX_REG_CLASS NO_REGS
+
+/* Basic Stack Layout.  */
+
+#define STACK_GROWS_DOWNWARD 1
+
+#define FRAME_GROWS_DOWNWARD 0
+
+/* Use the default value zero.  */
+/* #define STACK_POINTER_OFFSET 0 */
+
+#define FIRST_PARM_OFFSET(FNDECL) 0
+
+/* The return address for the current frame is in r31 if this is a leaf
+   function.  Otherwise, it is on the stack.  It is at a variable offset
+   from sp/fp/ap, so we define a fake hard register rap which is a
+   pointer to the return address on the stack.  This always gets eliminated
+   during reload to be either the frame pointer or the stack pointer plus
+   an offset.  */
+
+#define RETURN_ADDR_RTX(count, frame)                                   \
+  (((count) == 0)                                                       \
+   ? (leaf_function_p ()                                                \
+      ? gen_rtx_REG (Pmode, SIBCALL_RETURN_REGNUM)                          \
+      : gen_rtx_MEM (Pmode, gen_rtx_REG (Pmode,                         \
+                                         RETURN_ADDRESS_POINTER_REGNUM))) \
+    : (rtx) 0)
+
+/* Before the prologue, RA lives in r31.  */
+#define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (Pmode, RETURN_ADDRESS_POINTER_REGNUM)
+
+
+/* Register That Address the Stack Frame.  */
+
+#define ZERO_REGNUM                       0 /* Hardware reserved */
+#define PROGRAM_COUNTER_REGNUM            1
+#define STACK_POINTER_REGNUM 		         2 /* Hardware optimized */
+#define FRAME_POINTER_REGNUM 		         3
+#define HARD_FRAME_POINTER_REGNUM 	      4
+#define RETURN_ADDRESS_POINTER_REGNUM	   5
+#define SIBCALL_RETURN_REGNUM             6
+#define STATIC_CHAIN_REGNUM 		         7
+#define ARG_POINTER_REGNUM 		         8
+/*
+ Lobster128 ABI convention dictates the first 8 registers
+ are used for special purpouses, hardware only enforces the
+ first 7 registers on instructions.
+
+ The rest of registers can be, and are used as GPs,
+ while the first 16 registers are call saved & the rest
+ become call clobbered.
+*/
+#define GP_FIRST                          8
+#define GP_LAST                           127
+#define GP_ARG_FIRST                      8
+#define GP_ARG_LAST                       16
+#define GP_RET_FIRST                      8
+#define GP_RET_LAST                       10
+
+#define ELIMINABLE_REGS							\
+{{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM }, \
+ { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM }, \
+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM }}			
+
+/* Passing Function Arguments on the Stack.  */
+
+/* #define PUSH_ROUNDING(BYTES) 0 */
+
+#define ACCUMULATE_OUTGOING_ARGS 1
+
+#define REG_PARM_STACK_SPACE(FNDECL) 0
+
+#define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) 1
+
+/* Define this macro as a C expression that is nonzero for registers that are
+   used by the epilogue or the return pattern.  The stack and frame
+   pointer registers are already assumed to be used as needed.  */
+#define EPILOGUE_USES(R) 0
+
+/* Function Arguments in Registers.  */
+
+#define MAX_ARGS_IN_REGISTERS 32
+
+/* A C type for declaring a variable that is used as the first
+   argument of `FUNCTION_ARG' and other related values.  */
+#define CUMULATIVE_ARGS unsigned int
+
+/* If defined, the maximum amount of space required for outgoing arguments
+   will be computed and placed into the variable
+   `current_function_outgoing_args_size'.  No space will be pushed
+   onto the stack for each call; instead, the function prologue should
+   increase the stack frame size by this amount.  */
+#define ACCUMULATE_OUTGOING_ARGS 1
+
+/* A C statement (sans semicolon) for initializing the variable CUM
+   for the state at the beginning of the argument list.  
+   For Lobster128, the first arg is passed in register determined by ARG.  */
+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,FNDECL,N_NAMED_ARGS) \
+  (CUM = GP_ARG_FIRST)
+
+#define FUNCTION_ARG_REGNO_P(N)						\
+  (((N) >= GP_ARG_FIRST && (N) <= GP_ARG_LAST))			
+
+
+/* How Large Values are Returned.  */
+
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+/* Function Entry and Exit.  */
+
+#define EXIT_IGNORE_STACK 1
+
+
+/* Trampolines for Nested Functions.  */
+
+#define TRAMPOLINE_CODE_SIZE  (8 * 4)
+#define TRAMPOLINE_SIZE       (TRAMPOLINE_CODE_SIZE + 2 * GET_MODE_SIZE (Pmode))
+#define TRAMPOLINE_ALIGNMENT  GET_MODE_ALIGNMENT (Pmode)
+
+
+/* Addressing Modes.  */
+
+#define CONSTANT_ADDRESS_P(X)						\
+  (   (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF		\
+    || GET_CODE (X) == CONST_INT || GET_CODE (X) == HIGH		\
+    || (GET_CODE (X) == CONST)))
+
+#define MAX_REGS_PER_ADDRESS 1
+
+#define REG_OK_FOR_INDEX_P(X) 0
+
+
+/* Describing Relative Costs of Operations.  */
+
+#define REGISTER_MOVE_COST(MODE, FROM, TO) 1
+
+#define MEMORY_MOVE_COST(MODE,CLASS,TO_P)	(TO_P ? 6 : 15)
+
+#define BRANCH_COST(speed_p, predictable_p) 5
+
+/* Define this macro as a C expression which is nonzero if accessing
+   less than a word of memory (i.e. a `char' or a `short') is no
+   faster than accessing a word of memory.  */
+#define SLOW_BYTE_ACCESS 1
+
+#define NO_FUNCTION_CSE 1
+
+#define ADJUST_COST(INSN,LINK,DEP_INSN,COST)				\
+  if (REG_NOTE_KIND (LINK) != 0)					\
+    (COST) = 0; /* Anti or output dependence.  */
+
+
+/* Dividing the output into sections.  */
+
+#define TEXT_SECTION_ASM_OP	"\t.text"	/* Instructions.  */
+
+#define DATA_SECTION_ASM_OP	"\t.data"	/* Large data.  */
+
+
+/* The Overall Framework of an Assembler File.  */
+
+#define ASM_COMMENT_START " #"
+
+#define ASM_APP_ON "#APP\n"
+
+#define ASM_APP_OFF "#NO_APP\n"
+
+
+/* Output and Generation of Labels.  */
+
+#undef ASM_GENERATE_INTERNAL_LABEL
+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)			\
+  sprintf ((LABEL), "*%s%s%ld", (LOCAL_LABEL_PREFIX), (PREFIX), (long) (NUM))
+
+#define GLOBAL_ASM_OP "\t.globl\t"
+
+
+/* Output of Assembler Instructions.  */
+
+#define REGISTER_NAMES							\
+{									\
+ "ZERO", "PC",   "SP",   "RA",   "FP",   "BC",   "R6",   "R7",   \
+ "R8",   "R9",   "R10",  "R11",  "R12",  "R13",  "R14",  "R15",  \
+ "R16",  "R17",  "R18",  "R19",  "R20",  "R21",  "R22",  "R23",  \
+ "R24",  "R25",  "R26",  "R27",  "R28",  "R29",  "R30",  "R31",  \
+ "R32",  "R34",  "R35",  "R36",  "R37",  "R38",  "R39",  "R40",  \
+ "R41",  "R42",  "R43",  "R44",  "R45",  "R46",  "R47",  "R48",  \
+ "R49",  "R50",  "R51",  "R52",  "R53",  "R54",  "R55",  "R56",  \
+ "R57",  "R58",  "R59",  "R60",  "R61",  "R62",  "R63",  "R64",  \
+ "R65",  "R66",  "R67",  "R68",  "R69",  "R70",  "R71",  "R72",  \
+ "R73",  "R74",  "R75",  "R76",  "R77",  "R78",  "R79",  "R80",  \
+ "R81",  "R82",  "R83",  "R84",  "R85",  "R86",  "R87",  "R88",  \
+ "R89",  "R90",  "R91",  "R92",  "R93",  "R94",  "R95",  "R96",  \
+ "R97",  "R98",  "R99",  "R100", "R101", "R102", "R103", "R104", \
+ "R105", "R106", "R107", "R108", "R109", "R110", "R111", "R112", \
+ "R113", "R114", "R115", "R116", "R117", "R118", "R119", "R120", \
+ "R121", "R122", "R123", "R124", "R125", "R126", "R127", "R128", \
+}
+
+#define LOCAL_LABEL_PREFIX	"$"
+
+#define USER_LABEL_PREFIX	""
+
+/* Miscellaneous Parameters.  */
+#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND
+
+#define BITMASK_UPPER16	((unsigned long) 0xffff << 16)	/* 0xffff0000 */
+#define BITMASK_LOWER16	((unsigned long) 0xffff)	/* 0x0000ffff */
+
+/* Specify the machine mode that pointers have.
+   After generation of rtl, the compiler makes no further distinction
+   between pointers and any other objects of this machine mode.  */
+#define Pmode SImode
+
+/* An alias for the machine mode used for memory references to
+   functions being called, in `call' RTL expressions.  */
+#define FUNCTION_MODE QImode
+
+/* Maximum number of registers that can appear in a valid memory
+   address.  */
+#define MAX_REGS_PER_ADDRESS 1
+
+/* A C expression which is nonzero if register number NUM is suitable
+   for use as a base register in operand addresses.  */
+#define REGNO_OK_FOR_BASE_P(NUM) 1
+
+/* A C expression which is nonzero if register number NUM is suitable
+   for use as an index register in operand addresses.  */
+#define REGNO_OK_FOR_INDEX_P(NUM) 0
+
+/* An alias for a machine mode name.  This is the machine mode that
+   elements of a jump-table should have.  */
+#define CASE_VECTOR_MODE SImode
+
+/* Generating Code for Profiling */
+#define FUNCTION_PROFILER(FILE,LABELNO) (abort (), 0)
+
+/* The maximum number of bytes that a single instruction can move quickly from
+   memory to memory.  */
+#define MOVE_MAX 8
+
+/* This macro returns the initial difference between the specified pair
+   of registers.  */
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)			\
+  do {									\
+    (OFFSET) = lobster128_initial_elimination_offset ((FROM), (TO));		\
+  } while (0)
diff --git a/gcc/config/lobster128/lobster128.md b/gcc/config/lobster128/lobster128.md
new file mode 100644
index 00000000000..33e924885e9
--- /dev/null
+++ b/gcc/config/lobster128/lobster128.md
@@ -0,0 +1,391 @@
+;;  lobster128.md	     Machine Description for lobster128 processors
+;;  Copyright (C) 2003-2022 Free Software Foundation, Inc.
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+(include "constraints.md")
+(include "predicates.md")
+
+; All instructions are 8 bytes long
+(define_attr "length" "" (const_int 8))
+
+; Lenght of operands
+(define_mode_iterator MODE [QI HI SI DI TI])
+;(define_mode_attr mode [(QI "qi") (HI "hi") (SI "si") (DI "di") (TI "ti")])
+(define_mode_attr lenx [(QI ".CHR") (HI ".HLF") (SI ".WRD") (DI ".DWO") (TI ".OWO")])
+
+; Handle both unsigned and signed arithmethics
+(define_code_iterator EXTEND [sign_extend zero_extend])
+(define_code_attr isgn [(sign_extend "") (zero_extend "u")])
+(define_code_attr sgnprefix [(sign_extend "I.") (zero_extend "Z.")])
+
+;; -------------------------------------------------------------------------
+;; nop instruction
+;; -------------------------------------------------------------------------
+(define_insn "nop"
+  [(const_int 0)]
+  ""
+  "nop")
+
+;; -------------------------------------------------------------------------
+;; Arithmetic instructions
+;; -------------------------------------------------------------------------
+(define_insn "add<mode>3"
+  [(set (match_operand:MODE 0 "register_operand" "=r")
+	  (plus:MODE
+	   (match_operand:MODE 1 "register_operand" "r")
+	   (match_operand:MODE 2 "register_operand" "r")))]
+  ""
+  "<sgnprefix>.ADD.<lenx> %0,%1,%2")
+
+(define_insn "sub<mode>3"
+  [(set (match_operand:MODE 0 "register_operand" "=r")
+	  (minus:MODE
+	   (match_operand:MODE 1 "register_operand" "r")
+	   (match_operand:MODE 2 "register_operand" "r")))]
+  ""
+  "<sgnprefix>.SUB.<lenx> %0,%1,%2")
+
+(define_insn "mul<mode>3"
+  [(set (match_operand:MODE 0 "register_operand" "=r")
+	  (mult:MODE
+	   (match_operand:MODE 1 "register_operand" "r")
+	   (match_operand:MODE 2 "register_operand" "r")))]
+  ""
+  "<sgnprefix>.MUL.<lenx> %0,%1,%2")
+
+(define_insn "div<mode>3"
+  [(set (match_operand:MODE 0 "register_operand" "=r")
+	  (div:MODE
+	   (match_operand:MODE 1 "register_operand" "r")
+	   (match_operand:MODE 2 "register_operand" "r")))]
+  ""
+  "<sgnprefix>.DIV.<lenx> %0,%1,%2")
+
+(define_insn "mod<mode>3"
+  [(set (match_operand:MODE 0 "register_operand" "=r")
+	  (mod:MODE
+	   (match_operand:MODE 1 "register_operand" "r")
+	   (match_operand:MODE 2 "register_operand" "r")))]
+  ""
+  "<sgnprefix>.MOD.<lenx> %0,%1,%2")
+
+(define_insn "ashl<mode>3"
+  [(set (match_operand:MODE 0 "register_operand" "=r")
+	  (ashift:MODE
+	   (match_operand:MODE 1 "register_operand" "r")
+	   (match_operand:MODE 2 "register_operand" "r")))]
+  ""
+  "<sgnprefix>.LSH.<lenx> %0,%1,%2")
+
+(define_insn "ashr<mode>3"
+  [(set (match_operand:MODE 0 "register_operand" "=r")
+	  (ashiftrt:MODE
+	   (match_operand:MODE 1 "register_operand" "r")
+	   (match_operand:MODE 2 "register_operand" "r")))]
+  ""
+  "<sgnprefix>.RSH.<lenx> %0,%1,%2")
+
+(define_insn "xor<mode>3"
+  [(set (match_operand:MODE 0 "register_operand" "=r")
+	  (xor:MODE
+	   (match_operand:MODE 1 "register_operand" "r")
+	   (match_operand:MODE 2 "register_operand" "r")))]
+  ""
+  "<sgnprefix>.XOR.<lenx> %0,%1,%2")
+
+(define_insn "ior<mode>3"
+  [(set (match_operand:MODE 0 "register_operand" "=r")
+	  (ior:MODE
+	   (match_operand:MODE 1 "register_operand" "r")
+	   (match_operand:MODE 2 "register_operand" "r")))]
+  ""
+  "<sgnprefix>.OR.<lenx> %0,%1,%2")
+
+(define_insn "and<mode>3"
+  [(set (match_operand:MODE 0 "register_operand" "=r")
+	  (and:MODE
+	   (match_operand:MODE 1 "register_operand" "r")
+	   (match_operand:MODE 2 "register_operand" "r")))]
+  ""
+  "<sgnprefix>.AND.<lenx> %0,%1,%2")
+
+;(define_insn "sqrt<mode>2"
+;  [(set (match_operand:<MODE> 0 "register_operand" "=r,=r,=r")
+;  (match_operand:<MODE> 1 "nonimmediate_operand" "O,r,i"))]
+;  ""
+;  "@
+;   <sgnprefix>.XOR.<lenx> %0,%1
+;   <sgnprefix>.SQRT.<lenx> %0,%1
+;   <sgnprefix>.SQRT.I.<lenx> %0,%1"
+;  )
+
+;(define_insn "*mov<mode>_advanced"
+;  [(set (match_operand:MODE 0 "register_operand "r,r,r")
+;    (match_operand:MODE 1 "register_operand" "O,r,l"))]
+;  ""
+;  "@
+;   Z.XOR.<lenx> %0,%1
+;   Z.TRANS.<lenx> %0,%1
+;   Z.LOAD.<lenx> %0,%1"
+;  )
+
+(define_expand "movqi"
+  [(set (match_operand:QI 0 "general_operand" "")
+	(match_operand:QI 1 "general_operand" ""))]
+  ""
+  "
+{
+  /* If this is a store, force the value into a register.  */
+  if (MEM_P (operands[0]))
+    operands[1] = force_reg (QImode, operands[1]);
+}")
+
+(define_insn "*movqi"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=r,r,r,m")
+	(match_operand:QI 1 "nonimmediate_operand" "O,r,K,r"))]
+  ""
+  "@
+   Z.XOR.CHR %0,%1
+   Z.TRANS.CHR %0,%1
+   Z.LOAD.CHR %0,%1
+   Z.STORE.CHR %0,%1"
+  )
+
+(define_expand "movhi"
+  [(set (match_operand:HI 0 "general_operand" "")
+	(match_operand:HI 1 "general_operand" ""))]
+  ""
+  "
+{
+  /* If this is a store, force the value into a register.  */
+  if (MEM_P (operands[0]))
+    operands[1] = force_reg (HImode, operands[1]);
+}")
+
+(define_insn "*movhi"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=r,r,r,m")
+	(match_operand:HI 1 "nonimmediate_operand" "O,r,K,r"))]
+  ""
+  "@
+   Z.XOR.HLF %0,%1
+   Z.TRANS.HLF %0,%1
+   Z.LOAD.HLF %0,%1
+   Z.STORE.HLF %0,%1"
+  )
+
+(define_expand "movsi"
+  [(set (match_operand:SI 0 "general_operand" "")
+	(match_operand:SI 1 "general_operand" ""))]
+  ""
+  "
+{
+  /* If this is a store, force the value into a register.  */
+  if (MEM_P (operands[0]))
+    operands[1] = force_reg (SImode, operands[1]);
+}")
+
+(define_insn "*movsi"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,r,r,m")
+	(match_operand:SI 1 "nonimmediate_operand" "O,r,J,r"))]
+  ""
+  "@
+   Z.XOR.WRD %0,%1
+   Z.TRANS.WRD %0,%1
+   Z.LOAD.WRD %0,%1
+   Z.STORE.WRD %0,%1"
+  )
+
+(define_expand "movdi"
+  [(set (match_operand:DI 0 "general_operand" "")
+	(match_operand:DI 1 "general_operand" ""))]
+  ""
+  "
+{
+  /* If this is a store, force the value into a register.  */
+  if (MEM_P (operands[0]))
+    operands[1] = force_reg (DImode, operands[1]);
+}")
+
+(define_insn "*movdi"
+  [(set (match_operand:DI 0 "nonimmediate_operand" "=r,r,r,m")
+	(match_operand:DI 1 "nonimmediate_operand" "O,r,L,r"))]
+  ""
+  "@
+   Z.XOR.QWO %0,%1
+   Z.TRANS.QWO %0,%1
+   Z.LOAD.QWO %0,%1
+   Z.STORE.QWO %0,%1"
+  )
+
+(define_expand "movti"
+  [(set (match_operand:TI 0 "general_operand" "")
+	(match_operand:TI 1 "general_operand" ""))]
+  ""
+  "
+{
+  /* If this is a store, force the value into a register.  */
+  if (MEM_P (operands[0]))
+    operands[1] = force_reg (TImode, operands[1]);
+}")
+
+(define_insn "*movti"
+  [(set (match_operand:TI 0 "nonimmediate_operand" "=r,r,r,m")
+	(match_operand:TI 1 "nonimmediate_operand" "O,r,L,r"))]
+  ""
+  "@
+   Z.XOR.OWO %0,%1
+   Z.TRANS.OWO %0,%1
+   Z.LOAD.OWO %0,%1
+   Z.STORE.OWO %0,%1"
+  )
+
+;; -------------------------------------------------------------------------
+;; Compare instructions
+;; -------------------------------------------------------------------------
+
+(define_constants
+  [(CC_REG 64)])
+
+(define_expand "cbranchsi4"
+  [(set (reg:CC CC_REG)
+        (compare:CC
+         (match_operand:SI 1 "general_operand" "")
+         (match_operand:SI 2 "general_operand" "")))
+   (set (pc)
+        (if_then_else (match_operator 0 "comparison_operator"
+                       [(reg:CC CC_REG) (const_int 0)])
+                      (label_ref (match_operand 3 "" ""))
+                      (pc)))]
+  ""
+  "
+  /* Force the compare operands into registers.  */
+  if (GET_CODE (operands[1]) != REG)
+	operands[1] = force_reg (SImode, operands[1]);
+  if (GET_CODE (operands[2]) != REG)
+	operands[2] = force_reg (SImode, operands[2]);
+  ")
+
+(define_insn "*cmpsi"
+  [(set (reg:CC CC_REG)
+	(compare
+	 (match_operand:SI 0 "register_operand" "r")
+	 (match_operand:SI 1 "register_operand"	"r")))]
+  ""
+  "CMP %0,%1")
+
+;; -------------------------------------------------------------------------
+;; Branch instructions
+;; -------------------------------------------------------------------------
+
+(define_code_iterator cond [ne eq lt ltu gt gtu ge le geu leu])
+(define_code_attr rCC [(ne "EQU") (eq "NEQ") (lt "GTE") (ltu "GEU") 
+		       (gt "LTE") (gtu "LEU") (ge "LTH") (le "GTH") 
+		       (geu "LTU") (leu "GTU") ])
+
+(define_insn "*b<cond:code>"
+  [(set (pc)
+	(if_then_else (cond (reg:CC CC_REG)
+			    (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "Z.BCH.<rCC> %l0")
+
+;; -------------------------------------------------------------------------
+;; Call and Jump instructions
+;; -------------------------------------------------------------------------
+
+(define_expand "call"
+  [(call (match_operand:QI 0 "memory_operand" "")
+		(match_operand 1 "general_operand" ""))]
+  ""
+{
+  gcc_assert (MEM_P (operands[0]));
+})
+
+(define_insn "*call"
+  [(call (mem:QI (match_operand:SI
+		  0 "nonmemory_operand" "i,r"))
+	 (match_operand 1 "" ""))]
+  ""
+  "@
+   Z.JMP %0
+   Z.JMP %0"
+  )
+
+(define_expand "call_value"
+  [(set (match_operand 0 "" "")
+		(call (match_operand:QI 1 "memory_operand" "")
+		 (match_operand 2 "" "")))]
+  ""
+{
+  gcc_assert (MEM_P (operands[1]));
+})
+
+(define_insn "*call_value"
+  [(set (match_operand 0 "register_operand" "=r")
+	(call (mem:QI (match_operand:SI
+		       1 "immediate_operand" "i"))
+	      (match_operand 2 "" "")))]
+  ""
+  "Z.JMP %1")
+
+(define_insn "*call_value_indirect"
+  [(set (match_operand 0 "register_operand" "=r")
+	(call (mem:QI (match_operand:SI
+		       1 "register_operand" "r"))
+	      (match_operand 2 "" "")))]
+  ""
+  "Z.JMP %1")
+
+(define_insn "indirect_jump"
+  [(set (pc) (match_operand:SI 0 "nonimmediate_operand" "r"))]
+  ""
+  "Z.JMP %0")
+
+(define_insn "jump"
+  [(set (pc)
+	(label_ref (match_operand 0 "" "")))]
+  ""
+  "Z.JMP %0")
+
+;; -------------------------------------------------------------------------
+;; Prologue & Epilogue
+;; -------------------------------------------------------------------------
+(define_expand "prologue"
+  [(clobber (const_int 0))]
+  ""
+  "
+{
+  DONE;
+}
+")
+
+(define_expand "epilogue"
+  [(return)]
+  ""
+  "
+{
+  DONE;  
+}
+")
+
+(define_insn "returner"
+  [(return)]
+  "reload_completed"
+  "Z.RET")
diff --git a/gcc/config/lobster128/lobster128.opt b/gcc/config/lobster128/lobster128.opt
new file mode 100644
index 00000000000..6aa28006001
--- /dev/null
+++ b/gcc/config/lobster128/lobster128.opt
@@ -0,0 +1,19 @@
+; Options for the lobster128 port of the compiler.
+
+; Copyright (C) 2005-2022 Free Software Foundation, Inc.
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify it under
+; the terms of the GNU General Public License as published by the Free
+; Software Foundation; either version 3, or (at your option) any later
+; version.
+;
+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+; WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+; for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING3.  If not see
+; <http://www.gnu.org/licenses/>.
diff --git a/gcc/config/lobster128/predicates.md b/gcc/config/lobster128/predicates.md
new file mode 100644
index 00000000000..b5e0537a7bc
--- /dev/null
+++ b/gcc/config/lobster128/predicates.md
@@ -0,0 +1,19 @@
+;; Predicate definitions for LOBSTER128.
+;; Copyright (C) 2005-2022 Free Software Foundation, Inc.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
diff --git a/gcc/lra-int.h b/gcc/lra-int.h
index 04baefef348..710c9483226 100644
--- a/gcc/lra-int.h
+++ b/gcc/lra-int.h
@@ -26,7 +26,7 @@ along with GCC; see the file COPYING3.	If not see
 /* The parameter used to prevent infinite reloading for an insn.  Each
    insn operands might require a reload and, if it is a memory, its
    base and index registers might require a reload too.	 */
-#define LRA_MAX_INSN_RELOADS (MAX_RECOG_OPERANDS * 3)
+#define LRA_MAX_INSN_RELOADS (MAX_RECOG_OPERANDS * 5)
 
 typedef struct lra_live_range *lra_live_range_t;
 
diff --git a/libgcc/config.host b/libgcc/config.host
index b2a0a8e1aa9..c0d8883225e 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -138,6 +138,9 @@ hppa*-*-*)
 lm32*-*-*)
 	cpu_type=lm32
 	;;
+lobster128*)
+	cpu_type=lobster128
+	;;
 loongarch*-*-*)
 	cpu_type=loongarch
 	tmake_file="loongarch/t-loongarch"
diff --git a/libgcc/config/lobster128/crti.S b/libgcc/config/lobster128/crti.S
new file mode 100644
index 00000000000..063d2025a33
--- /dev/null
+++ b/libgcc/config/lobster128/crti.S
@@ -0,0 +1,40 @@
+# crti.S for lobster128
+#
+#   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+# 
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the
+# Free Software Foundation; either version 3, or (at your option) any
+# later version.
+# 
+# This file is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+# 
+# Under Section 7 of GPL version 3, you are granted additional
+# permissions described in the GCC Runtime Library Exception, version
+# 3.1, as published by the Free Software Foundation.
+#
+# You should have received a copy of the GNU General Public License and
+# a copy of the GCC Runtime Library Exception along with this program;
+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+# <http://www.gnu.org/licenses/>.
+
+# This file just make a stack frame for the contents of the .fini and
+# .init sections.  Users may put any desired instructions in those
+# sections.
+
+	.file		"crti.S"
+
+	.section	".init"
+	.global	_init
+	.type	_init, @function	
+	.p2align	1
+_init:
+
+	.section	".fini"
+	.global	_fini
+	.type	_fini,@function
+	.p2align	1
+_fini:
diff --git a/libgcc/config/lobster128/crtn.S b/libgcc/config/lobster128/crtn.S
new file mode 100644
index 00000000000..099eaaacf9e
--- /dev/null
+++ b/libgcc/config/lobster128/crtn.S
@@ -0,0 +1,34 @@
+# crtn.S for lobster128
+# 
+#   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+# 
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the
+# Free Software Foundation; either version 3, or (at your option) any
+# later version.
+# 
+# This file is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+# 
+# Under Section 7 of GPL version 3, you are granted additional
+# permissions described in the GCC Runtime Library Exception, version
+# 3.1, as published by the Free Software Foundation.
+#
+# You should have received a copy of the GNU General Public License and
+# a copy of the GCC Runtime Library Exception along with this program;
+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+# <http://www.gnu.org/licenses/>.
+
+# This file just makes sure that the .fini and .init sections do in
+# fact return.  Users may put any desired instructions in those sections.
+# This file is the last thing linked into any executable.
+
+	.file		"crtn.S"
+
+	.section	".init"
+	ret
+	
+	.section	".fini"
+	ret
diff --git a/libgcc/config/lobster128/sfp-machine.h b/libgcc/config/lobster128/sfp-machine.h
new file mode 100644
index 00000000000..7874081fdab
--- /dev/null
+++ b/libgcc/config/lobster128/sfp-machine.h
@@ -0,0 +1,51 @@
+/* Use 32-bit types here to prevent longlong.h trying to use TImode.
+   Once TImode works we might be better to use 64-bit here.  */
+
+#define _FP_W_TYPE_SIZE		32
+#define _FP_W_TYPE		unsigned int
+#define _FP_WS_TYPE		signed int
+#define _FP_I_TYPE		int
+
+#define _FP_MUL_MEAT_S(R,X,Y)				\
+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_D(R,X,Y)				\
+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_loop(S,R,X,Y)
+#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_2_udiv(D,R,X,Y)
+
+#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
+#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+
+#define _FP_KEEPNANFRACP 1
+#define _FP_QNANNEGATEDP 0
+
+/* Someone please check this.  */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)			\
+  do {								\
+    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)		\
+	&& !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))	\
+      {								\
+	R##_s = Y##_s;						\
+	_FP_FRAC_COPY_##wc(R,Y);				\
+      }								\
+    else							\
+      {								\
+	R##_s = X##_s;						\
+	_FP_FRAC_COPY_##wc(R,X);				\
+      }								\
+    R##_c = FP_CLS_NAN;						\
+  } while (0)
+
+#define _FP_TININESS_AFTER_ROUNDING 0
+
+#define __LITTLE_ENDIAN 1234
+#define	__BIG_ENDIAN	4321
+#define __BYTE_ORDER __LITTLE_ENDIAN
+
+/* Define ALIASNAME as a strong alias for NAME.  */
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+# define _strong_alias(name, aliasname) \
+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));
