diff --git a/config.guess b/config.guess
index 1972fda8eb0..3a3c543ceb9 100755
--- a/config.guess
+++ b/config.guess
@@ -995,6 +995,9 @@ EOF
     k1om:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
+	lobster128:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
     loongarch32:Linux:*:* | loongarch64:Linux:*:* | loongarchx32:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
diff --git a/config.sub b/config.sub
index 38f3d037a78..9fe774727ee 100755
--- a/config.sub
+++ b/config.sub
@@ -1202,6 +1202,7 @@ case $cpu-$vendor in
 			| k1om \
 			| le32 | le64 \
 			| lm32 \
+			| lobster128 \
 			| loongarch32 | loongarch64 | loongarchx32 \
 			| m32c | m32r | m32rle \
 			| m5200 | m68000 | m680[012346]0 | m68360 | m683?2 | m68k \
diff --git a/gcc/config.gcc b/gcc/config.gcc
index 02f58970db0..814e9df3b2b 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -453,6 +453,10 @@ mips*-*-*)
 	extra_objs="frame-header-opt.o"
 	extra_options="${extra_options} g.opt fused-madd.opt mips/mips-tables.opt"
 	;;
+lobster128*)
+    cpu_type=lobster128
+	target_has_targetm_common=no
+    ;;
 loongarch*-*-*)
 	cpu_type=loongarch
 	extra_headers="larchintrin.h"
@@ -2502,7 +2506,12 @@ riscv*-*-freebsd*)
 	# automatically detect that GAS supports it, yet we require it.
 	gcc_cv_initfini_array=yes
 	;;
-
+lobster128*-*-linux* | lobster128*-*-elf*)
+	gas=yes
+	gnu_ld=yes
+	tm_file="${tm_file} dbxelf.h elfos.h newlib-stdint.h"
+	tmake_file="${tmake_file}"
+	;;
 loongarch*-*-linux*)
 	tm_file="dbxelf.h elfos.h gnu-user.h linux.h linux-android.h glibc-stdint.h ${tm_file}"
 	tm_file="${tm_file} loongarch/gnu-user.h loongarch/linux.h"
diff --git a/gcc/config/lobster128/constraints.md b/gcc/config/lobster128/constraints.md
new file mode 100644
index 00000000000..017cefeb8fc
--- /dev/null
+++ b/gcc/config/lobster128/constraints.md
@@ -0,0 +1,49 @@
+;; Constraints for Vitesse IQ2000 processors
+;; Copyright (C) 2011-2022 Free Software Foundation, Inc.
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+;; Integer constraints.
+(define_constraint "O"
+  "Zero."
+  (and (match_code "const_int")
+       (match_test "ival == 0")))
+
+(define_constraint "N"
+  "A constant 8-bit signed integer -(0..255)"
+  (and (match_code "const_int")
+       (match_test "ival >= -255 && ival <= 0")))
+
+(define_constraint "I"
+  "A 16-bit signed integer."
+  (and (match_code "const_int")
+       (match_test "IN_RANGE (ival, -32768, 32767)")))
+
+(define_constraint "K"
+  "A 16-bit unsigned integer"
+  (and (match_code "const_int")
+       (match_test "IN_RANGE (ival, 0, 65535)")))
+
+(define_constraint "J"
+  "A 32-bit constant."
+  (and (match_code "const_int")
+       (match_test "IN_RANGE (ival, 0, 0xffffffff)")))
+
+(define_constraint "L"
+  "A 64-bit constant."
+  (and (match_code "const_int")
+       (match_test "IN_RANGE (ival, 0, 0xffffffffffffffff)")))
diff --git a/gcc/config/lobster128/lobster128-protos.h b/gcc/config/lobster128/lobster128-protos.h
new file mode 100644
index 00000000000..92eca311d45
--- /dev/null
+++ b/gcc/config/lobster128/lobster128-protos.h
@@ -0,0 +1,24 @@
+/* Definitions of target machine for GNU compiler for lobster128.
+   Copyright (C) 2003-2022 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+extern void  lobster128_expand_prologue (void);
+extern void  lobster128_expand_epilogue (void);
+extern int   lobster128_initial_elimination_offset (int, int);
+extern bool  lobster128_offset_address_p (rtx);
+
diff --git a/gcc/config/lobster128/lobster128.cc b/gcc/config/lobster128/lobster128.cc
new file mode 100644
index 00000000000..8b21715c1b8
--- /dev/null
+++ b/gcc/config/lobster128/lobster128.cc
@@ -0,0 +1,490 @@
+/* Subroutines used for code generation on Vitesse lobster128 processors
+   Copyright (C) 2003-2022 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#define IN_TARGET_CODE 1
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "backend.h"
+#include "target.h"
+#include "rtl.h"
+#include "tree.h"
+#include "stringpool.h"
+#include "attribs.h"
+#include "df.h"
+#include "memmodel.h"
+#include "tm_p.h"
+#include "optabs.h"
+#include "regs.h"
+#include "emit-rtl.h"
+#include "recog.h"
+#include "diagnostic-core.h"
+#include "stor-layout.h"
+#include "calls.h"
+#include "varasm.h"
+#include "output.h"
+#include "insn-attr.h"
+#include "explow.h"
+#include "expr.h"
+#include "langhooks.h"
+#include "builtins.h"
+
+/* This file should be included last.  */
+#include "target-def.h"
+
+/* Global variables for machine-dependent things.  */
+
+/* Per-function machine data.  */
+struct GTY(()) machine_function
+{
+  /* Number of bytes saved on the stack for callee saved registers.  */
+  int callee_saved_reg_size;
+
+  /* Number of bytes saved on the stack for local variables.  */
+  int local_vars_size;
+
+  /* The sum of 2 sizes: locals vars and padding byte for saving the
+   * registers.  Used in expand_prologue () and expand_epilogue().  */
+  int size_for_adjusting_sp;
+};
+
+/* Worker function for TARGET_RETURN_IN_MEMORY.  */
+static bool
+lobster128_return_in_memory(const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
+{
+  const HOST_WIDE_INT size = int_size_in_bytes(type);
+  return (size == -1 || size > 2 * UNITS_PER_WORD);
+}
+
+/* Zero initialization is OK for all current fields.  */
+static struct machine_function *
+losbter128_init_machine_status(void)
+{
+  return ggc_cleared_alloc<machine_function>();
+}
+
+/* Helper function for `lobster128_legitimate_address_p'.  */
+
+static bool
+lobster128_reg_ok_for_base_p(const_rtx reg, bool strict_p)
+{
+  int regno = REGNO(reg);
+
+  if (strict_p)
+    return REGNO_OK_FOR_BASE_P(regno) || REGNO_OK_FOR_BASE_P(reg_renumber[regno]);
+  else
+    return !HARD_REGISTER_NUM_P(regno) || REGNO_OK_FOR_BASE_P(regno);
+}
+
+/* Worker function for TARGET_LEGITIMATE_ADDRESS_P.  */
+
+static bool
+lobster128_legitimate_address_p(machine_mode mode ATTRIBUTE_UNUSED,
+                                rtx x, bool strict_p,
+                                addr_space_t as)
+{
+  gcc_assert(ADDR_SPACE_GENERIC_P(as));
+  if (GET_CODE(x) == PLUS && REG_P(XEXP(x, 0)) && lobster128_reg_ok_for_base_p(XEXP(x, 0), strict_p) && CONST_INT_P(XEXP(x, 1)) && IN_RANGE(INTVAL(XEXP(x, 1)), -32768, 32767))
+    return true;
+  if (REG_P(x) && lobster128_reg_ok_for_base_p(x, strict_p))
+    return true;
+  if (GET_CODE(x) == SYMBOL_REF || GET_CODE(x) == LABEL_REF || GET_CODE(x) == CONST)
+    return true;
+  return false;
+}
+
+/* Return non-zero if the function argument described by ARG is to be
+   passed by reference.  */
+static bool
+lobster128_pass_by_reference(cumulative_args_t, const function_arg_info &arg)
+{
+  if (arg.aggregate_type_p())
+    return true;
+  unsigned HOST_WIDE_INT size = arg.type_size_in_bytes();
+  return size > 4 * 6;
+}
+
+/* Some function arguments will only partially fit in the registers
+   that hold arguments.  Given a new arg, return the number of bytes
+   that fit in argument passing registers.  */
+static int
+lobster128_arg_partial_bytes(cumulative_args_t cum_v, const function_arg_info &arg)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args(cum_v);
+  if (*cum >= LOBSTER128_LAST)
+    return 0;
+
+  int size;
+  if (lobster128_pass_by_reference(cum_v, arg))
+    size = 4;
+  else if (arg.type)
+  {
+    if (AGGREGATE_TYPE_P(arg.type))
+      return 0;
+    size = int_size_in_bytes(arg.type);
+  }
+  else
+    size = GET_MODE_SIZE(arg.mode);
+
+  int bytes_left = (4 * 6) - ((*cum - 2) * 4);
+  if (size > bytes_left)
+    return bytes_left;
+  else
+    return 0;
+}
+
+/* Worker function for TARGET_STATIC_CHAIN.  */
+static rtx
+lobster128_static_chain(const_tree ARG_UNUSED(fndecl_or_type), bool incoming_p)
+{
+  rtx addr;
+
+  if (incoming_p)
+    addr = plus_constant(Pmode, arg_pointer_rtx, 2 * UNITS_PER_WORD);
+  else
+    addr = plus_constant(Pmode, stack_pointer_rtx, -UNITS_PER_WORD);
+
+  rtx mem = gen_rtx_MEM(Pmode, addr);
+  MEM_NOTRAP_P(mem) = 1;
+  return mem;
+}
+
+/* Return the next register to be used to hold a function argument or
+   NULL_RTX if there's no more space.  */
+static rtx
+lobster128_function_arg(cumulative_args_t cum_v, const function_arg_info &arg)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args(cum_v);
+  if (*cum < LOBSTER128_LAST)
+    return gen_rtx_REG(arg.mode, *cum);
+  return NULL_RTX;
+}
+
+#define LOBSTER128_FUNCTION_ARG_SIZE(MODE, TYPE) \
+  ((MODE) != BLKmode ? GET_MODE_SIZE(MODE)       \
+                     : (unsigned)int_size_in_bytes(TYPE))
+
+/* Advance the argument to the next argument position.  */
+
+static void
+lobster128_function_arg_advance(cumulative_args_t cum_v,
+                                const function_arg_info &arg)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args(cum_v);
+  (*cum)++;
+}
+
+/* Define how to find the value returned by a function.
+   VALTYPE is the data type of the value (as a tree).
+   If the precise function being called is known, FUNC is its
+   FUNCTION_DECL; otherwise, FUNC is 0.
+
+   We always return values in register RETURN_ADDRESS for lobster128.  */
+static rtx
+lobster128_function_value(const_tree valtype,
+                          const_tree fntype_or_decl ATTRIBUTE_UNUSED,
+                          bool outgoing ATTRIBUTE_UNUSED)
+{
+  return gen_rtx_REG(TYPE_MODE(valtype), LOBSTER128_FIRST);
+}
+
+/* Handle TARGET_FUNCTION_VALUE_REGNO_P.
+   We always return values in register LOBSTER128_FIRST for lobster128.  */
+static bool
+lobster128_function_value_regno_p(const unsigned int regno)
+{
+  return (regno == LOBSTER128_FIRST);
+}
+
+/* The TARGET_OPTION_OVERRIDE worker.  */
+static void
+lobster128_option_override(void)
+{
+  /* Set the per-function-data initializer.  */
+  init_machine_status = losbter128_init_machine_status;
+}
+
+/* Compute the size of the local area and the size to be adjusted by the
+ * prologue and epilogue.  */
+
+static void
+lobster128_compute_frame(void)
+{
+  /* For aligning the local variables.  */
+  int stack_alignment = STACK_BOUNDARY / BITS_PER_UNIT;
+  /* Padding needed for each element of the frame.  */
+  cfun->machine->local_vars_size = get_frame_size();
+
+  /* Align to the stack alignment.  */
+  int padding_locals = cfun->machine->local_vars_size % stack_alignment;
+  if (padding_locals)
+    padding_locals = stack_alignment - padding_locals;
+
+  cfun->machine->local_vars_size += padding_locals;
+
+  cfun->machine->callee_saved_reg_size = 0;
+
+  /* Save callee-saved registers.  */
+  for (int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+    if (df_regs_ever_live_p(regno) && (!call_used_or_fixed_reg_p(regno)))
+      cfun->machine->callee_saved_reg_size += 4;
+
+  cfun->machine->size_for_adjusting_sp =
+      crtl->args.pretend_args_size + cfun->machine->local_vars_size + (ACCUMULATE_OUTGOING_ARGS ? (HOST_WIDE_INT)crtl->outgoing_args_size : 0);
+}
+
+/* Return the offset between two registers, one to be eliminated, and the other
+   its replacement, at the start of a routine.  */
+int lobster128_initial_elimination_offset(int from, int to)
+{
+  int ret;
+  if ((from) == FRAME_POINTER_REGNUM && (to) == HARD_FRAME_POINTER_REGNUM)
+  {
+    /* Compute this since we need to use cfun->machine->local_vars_size.  */
+    lobster128_compute_frame();
+    ret = -cfun->machine->callee_saved_reg_size;
+  }
+  else if ((from) == ARG_POINTER_REGNUM && (to) == HARD_FRAME_POINTER_REGNUM)
+    ret = 0;
+  else if ((from) == STACK_POINTER_REGNUM && (to) == HARD_FRAME_POINTER_REGNUM)
+    ret = 0;
+  else if ((from) == HARD_FRAME_POINTER_REGNUM && (to) == STACK_POINTER_REGNUM)
+    ret = 0;
+  else
+    abort();
+  return ret;
+}
+
+void lobster128_expand_prologue(void)
+{
+  rtx insn;
+
+  lobster128_compute_frame();
+  if (flag_stack_usage_info)
+    current_function_static_stack_size = cfun->machine->size_for_adjusting_sp;
+
+  /* Save callee-saved registers.  */
+  for (int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+  {
+    if (df_regs_ever_live_p(regno) && !call_used_or_fixed_reg_p(regno))
+    {
+      insn = emit_insn(gen_movsi_push(gen_rtx_REG(Pmode, regno)));
+      RTX_FRAME_RELATED_P(insn) = 1;
+    }
+  }
+
+  if (cfun->machine->size_for_adjusting_sp > 0)
+  {
+    int i = cfun->machine->size_for_adjusting_sp;
+    while ((i >= 65535))
+    {
+      insn = emit_insn(gen_subdi3(stack_pointer_rtx,
+                                  stack_pointer_rtx,
+                                  GEN_INT(65535)));
+      RTX_FRAME_RELATED_P(insn) = 1;
+      i -= 65535;
+    }
+
+    /* TODO: We could do better and generate a Z.PUSH / Z.POP */
+    if (i <= 255)
+    {
+      insn = emit_insn(gen_subdi3(stack_pointer_rtx,
+                                  stack_pointer_rtx,
+                                  GEN_INT(i)));
+      RTX_FRAME_RELATED_P(insn) = 1;
+    }
+    else
+    {
+      rtx reg = gen_rtx_REG(DImode, 17);
+      insn = emit_move_insn(reg, GEN_INT(i));
+      RTX_FRAME_RELATED_P(insn) = 1;
+      insn = emit_insn(gen_subdi3(stack_pointer_rtx,
+                                  stack_pointer_rtx,
+                                  reg));
+      RTX_FRAME_RELATED_P(insn) = 1;
+    }
+  }
+}
+
+void lobster128_expand_epilogue(void)
+{
+  if (cfun->machine->callee_saved_reg_size != 0)
+  {
+    rtx reg = gen_rtx_REG(Pmode, 17);
+    if (cfun->machine->callee_saved_reg_size <= 255)
+    {
+      emit_move_insn(reg, hard_frame_pointer_rtx);
+      emit_insn(gen_subdi3(reg, reg,
+                           GEN_INT(cfun->machine->callee_saved_reg_size)));
+    }
+    else
+    {
+      emit_move_insn(reg,
+                     GEN_INT(-cfun->machine->callee_saved_reg_size));
+      emit_insn(gen_adddi3(reg, reg, hard_frame_pointer_rtx));
+    }
+    for (int regno = FIRST_PSEUDO_REGISTER; regno-- > 0;)
+      if (!call_used_or_fixed_reg_p(regno) && df_regs_ever_live_p(regno))
+      {
+        rtx preg = gen_rtx_REG(Pmode, regno);
+        emit_insn(gen_movsi_pop(reg, preg));
+      }
+  }
+
+  emit_jump_insn(gen_returner());
+}
+
+/* The PRINT_OPERAND_ADDRESS worker.  */
+static void
+lobster128_print_operand_address(FILE *file, machine_mode, rtx x)
+{
+  switch (GET_CODE(x))
+  {
+  case REG:
+    fprintf(file, "(%s)", reg_names[REGNO(x)]);
+    break;
+  case PLUS:
+    switch (GET_CODE(XEXP(x, 1)))
+    {
+    case CONST_INT:
+      fprintf(file, "%ld(%s)",
+              INTVAL(XEXP(x, 1)), reg_names[REGNO(XEXP(x, 0))]);
+      break;
+    case SYMBOL_REF:
+      output_addr_const(file, XEXP(x, 1));
+      fprintf(file, "(%s)", reg_names[REGNO(XEXP(x, 0))]);
+      break;
+    case CONST:
+    {
+      rtx plus = XEXP(XEXP(x, 1), 0);
+      if (GET_CODE(XEXP(plus, 0)) == SYMBOL_REF && CONST_INT_P(XEXP(plus, 1)))
+      {
+        output_addr_const(file, XEXP(plus, 0));
+        fprintf(file, "+%ld(%s)", INTVAL(XEXP(plus, 1)),
+                reg_names[REGNO(XEXP(x, 0))]);
+      }
+      else
+        abort();
+    }
+    break;
+    default:
+      abort();
+    }
+    break;
+  default:
+    output_addr_const(file, x);
+    break;
+  }
+}
+
+/* The PRINT_OPERAND worker.  */
+static void
+lobster128_print_operand(FILE *file, rtx x, int code)
+{
+  rtx operand = x;
+
+  /* New code entries should just be added to the switch below.  If
+     handling is finished, just return.  If handling was just a
+     modification of the operand, the modified operand should be put in
+     "operand", and then do a break to let default handling
+     (zero-modifier) output the operand.  */
+
+  switch (code)
+  {
+  case 0:
+    /* No code, print as usual.  */
+    break;
+
+  default:
+    internal_error("invalid operand modifier letter");
+  }
+
+  /* Print an operand as without a modifier letter.  */
+  switch (GET_CODE(operand))
+  {
+  case REG:
+    if (REGNO(operand) > FIRST_PSEUDO_REGISTER)
+      internal_error("internal error: bad register: %d", REGNO(operand));
+    fprintf(file, "%s", reg_names[REGNO(operand)]);
+    return;
+
+  case MEM:
+    output_address(GET_MODE(XEXP(operand, 0)), XEXP(operand, 0));
+    return;
+
+  default:
+    /* No need to handle all strange variants, let output_addr_const
+ do it for us.  */
+    if (CONSTANT_P(operand))
+    {
+      output_addr_const(file, operand);
+      return;
+    }
+
+    internal_error("unexpected operand");
+  }
+}
+
+/* Return true for memory offset addresses between -32768 and 32767.  */
+bool lobster128_offset_address_p(rtx x)
+{
+  x = XEXP(x, 0);
+  if (GET_CODE(x) == PLUS)
+  {
+    x = XEXP(x, 1);
+    if (GET_CODE(x) == CONST_INT)
+    {
+      unsigned int v = INTVAL(x) & 0xFFFF8000;
+      return (v == 0xFFFF8000 || v == 0x00000000);
+    }
+  }
+  return 0;
+}
+
+#undef TARGET_RETURN_IN_MEMORY
+#define TARGET_RETURN_IN_MEMORY lobster128_return_in_memory
+#undef TARGET_MUST_PASS_IN_STACK
+#define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size
+#undef TARGET_PASS_BY_REFERENCE
+#define TARGET_PASS_BY_REFERENCE lobster128_pass_by_reference
+#undef TARGET_ARG_PARTIAL_BYTES
+#define TARGET_ARG_PARTIAL_BYTES lobster128_arg_partial_bytes
+#undef TARGET_FUNCTION_ARG
+#define TARGET_FUNCTION_ARG lobster128_function_arg
+#undef TARGET_FUNCTION_ARG_ADVANCE
+#define TARGET_FUNCTION_ARG_ADVANCE lobster128_function_arg_advance
+#undef TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P
+#define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P lobster128_legitimate_address_p
+#undef TARGET_FUNCTION_VALUE
+#define TARGET_FUNCTION_VALUE lobster128_function_value
+#undef TARGET_FUNCTION_VALUE_REGNO_P
+#define TARGET_FUNCTION_VALUE_REGNO_P lobster128_function_value_regno_p
+#undef TARGET_OPTION_OVERRIDE
+#define TARGET_OPTION_OVERRIDE lobster128_option_override
+#undef TARGET_STATIC_CHAIN
+#define TARGET_STATIC_CHAIN lobster128_static_chain
+#undef TARGET_PRINT_OPERAND
+#define TARGET_PRINT_OPERAND lobster128_print_operand
+#undef TARGET_PRINT_OPERAND_ADDRESS
+#define TARGET_PRINT_OPERAND_ADDRESS lobster128_print_operand_address
+
+struct gcc_target targetm = TARGET_INITIALIZER;
+
+#include "gt-lobster128.h"
diff --git a/gcc/config/lobster128/lobster128.h b/gcc/config/lobster128/lobster128.h
new file mode 100644
index 00000000000..7cf7e7f3fe4
--- /dev/null
+++ b/gcc/config/lobster128/lobster128.h
@@ -0,0 +1,443 @@
+/* Definitions of target machine for GNU compiler.  
+   lobster128 processors
+   Copyright (C) 2003-2022 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Driver configuration.  */
+
+/* A generic LIB_SPEC with -leval and --*group tacked on.  */
+#undef  LIB_SPEC
+#define LIB_SPEC "%{!shared:%{!symbolic:--start-group -lc -leval -lgcc --end-group}}"
+
+#undef STARTFILE_SPEC
+#undef ENDFILE_SPEC
+
+#undef  LINK_SPEC
+#define LINK_SPEC "%{h*} %{v:-V} \
+		   %{static:-Bstatic} %{shared:-shared} %{symbolic:-Bsymbolic}"
+
+
+/* Run-time target specifications.  */
+
+#define TARGET_CPU_CPP_BUILTINS()               \
+  do                                            \
+    {                                           \
+      builtin_define ("__lobster128__"); 		\
+      builtin_assert ("cpu=lobster128"); 		\
+      builtin_assert ("machine=lobster128");	\
+    }                                           \
+  while (0)
+
+/* Allow pairs of registers to be used, which is the intent of the default.  */
+#define MAX_FIXED_MODE_SIZE GET_MODE_BITSIZE (TImode)
+
+/*
+ Lobster128 ABI convention dictates the first 8 registers
+ are used for special purpouses, hardware only enforces the
+ first 7 registers on instructions.
+
+ The rest of registers can be, and are used as GPs,
+ while the first 16 registers are call saved & the rest
+ become call clobbered.
+*/
+#define LOBSTER128_ZERO 0
+#define LOBSTER128_PC 1
+#define LOBSTER128_SP 2
+#define LOBSTER128_FP 3
+#define LOBSTER128_FIRST 4
+#define LOBSTER128_LAST 127
+#define LOBSTER128_CC 128
+
+/* Layout of Source Language Data Types.  */
+
+#define INT_TYPE_SIZE 32
+
+#define SHORT_TYPE_SIZE 16
+
+#define LONG_TYPE_SIZE 64
+
+#define LONG_LONG_TYPE_SIZE 64
+
+#define FLOAT_TYPE_SIZE 32
+
+#define DOUBLE_TYPE_SIZE 64
+
+#define LONG_DOUBLE_TYPE_SIZE	64
+
+#define DEFAULT_SIGNED_CHAR 1
+
+/* Number of storage units in a word; normally the size of a
+   general-purpose register, a power of two from 1 or 8.  */
+#define UNITS_PER_WORD 8
+
+#define POINTER_SIZE 8
+
+/* Define this macro to the minimum alignment enforced by hardware
+   for the stack pointer on this machine.  The definition is a C
+   expression for the desired alignment (measured in bits).  */
+#define STACK_BOUNDARY 8
+
+/* Normal alignment required for function parameters on the stack, in
+   bits.  All stack parameters receive at least this much alignment
+   regardless of data type.  */
+#define PARM_BOUNDARY 8
+
+/* No data type wants to be aligned rounder than this.  */
+#define BIGGEST_ALIGNMENT 128
+
+/* The best alignment to use in cases where we have a choice.  */
+#define FASTEST_ALIGNMENT 64
+
+/* Set this nonzero if move instructions will actually fail to work
+   when given unaligned data.  */
+#define STRICT_ALIGNMENT 0
+
+/* Storage Layout */
+
+#define BITS_BIG_ENDIAN 0
+#define BYTES_BIG_ENDIAN 0
+#define WORDS_BIG_ENDIAN 0
+
+/* Alignment required for a function entry point, in bits.  */
+#define FUNCTION_BOUNDARY 8
+
+/* Define this macro as a C expression which is nonzero if accessing
+   less than a word of memory (i.e. a `char' or a `short') is no
+   faster than accessing a word of memory.  */
+#define SLOW_BYTE_ACCESS 1
+
+/* Register Basics.  */
+
+/* Number of hardware registers known to the compiler..
+   We have 128 registers to choose from, plus the CC register  */
+#define FIRST_PSEUDO_REGISTER (128 + 1)
+
+#define FIXED_REGISTERS							\
+{									\
+  1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,			\
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,			\
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     \
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     \
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     \
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     \
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     \
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     \
+  1, \
+}
+
+#define CALL_USED_REGISTERS						\
+{									\
+  1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,			\
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,			\
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     \
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     \
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     \
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     \
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     \
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     \
+  1, \
+}
+
+
+/* Order of allocation of registers.  */
+
+#define REG_ALLOC_ORDER							\
+{ \
+  /* Hardware tied registers */ \
+  0,  1,  2,  3,  4, \
+  /* Call-arguments */ \
+  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,	\
+  /* Call-saved/clobered */ \
+  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,	\
+  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,	\
+  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,	\
+  64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,	\
+  80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,	\
+  96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111,	\
+ 112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,	\
+  /* Virtual registers */ \
+  128 \
+}
+
+/* We can't copy to or from our CC register. */
+#define AVOID_CCMODE_COPIES 1
+
+/* Register Classes.  */
+enum reg_class
+{
+  NO_REGS,			/* No registers in set.  */
+  ZERO_REGS,    /* Register used for 0 */
+  PC_REGS,      /* Program Counter register */
+  CC_REGS,        /* Condition registers. */
+  GR_REGS,			/* Integer registers.  */
+  ALL_REGS,			/* All registers.  */
+  LIM_REG_CLASSES		/* Max value + 1.  */
+};
+
+#define REG_CLASS_CONTENTS \
+{ { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00  }, /* Empty */			   \
+  { 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00  }, /* ZERO */ \
+  { 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00  }, /* PC */ \
+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01 }, /* CC */                        \
+  { 0xFFFFFFFC, 0xFFFFFFFF, 0xFFFFFFFF, 0x7FFFFFFF, 0x00 }, /* GR */              \
+  { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00 }  /* All registers */              \
+}
+
+#define GENERAL_REGS GR_REGS
+
+#define N_REG_CLASSES (int) LIM_REG_CLASSES
+
+#define REG_CLASS_NAMES    \
+{                          \
+  "NO_REGS",               \
+  "ZERO_REGS",             \
+  "PC_REGS",               \
+  "CC_REGS",               \
+  "GR_REGS",               \
+  "ALL_REGS"               \
+}
+
+#define REGNO_REG_CLASS(R) \
+  ((R == LOBSTER128_ZERO) ? ZERO_REGS \
+  : (R == LOBSTER128_PC) ? PC_REGS \
+  : (R == LOBSTER128_CC) ? CC_REGS \
+  : GR_REGS)
+
+
+/* The Overall Framework of an Assembler File */
+
+#define FILE_ASM_OP     "\t.file\n"
+
+/* Switch to the text or data segment.  */
+#define TEXT_SECTION_ASM_OP  "\t.text"
+#define DATA_SECTION_ASM_OP  "\t.data"
+
+/* Assembler Commands for Alignment */
+
+#define ASM_OUTPUT_ALIGN(STREAM,POWER) \
+	fprintf (STREAM, "\t.p2align\t%d\n", POWER);
+
+/* A macro whose definition is the name of the class to which a
+   valid base register must belong.  A base register is one used in
+   an address which is the register value plus a displacement.  */
+#define BASE_REG_CLASS GR_REGS
+
+/* A macro whose definition is the name of the class to which a
+   valid index register must belong.  An index register is one used
+   in an address where its value is either multiplied by a scale
+   factor or added to another register (as well as added to a
+   displacement).  */
+#define INDEX_REG_CLASS NO_REGS
+
+/* Basic Stack Layout.  */
+/* Define this macro if pushing a word onto the stack moves the stack
+   pointer to a smaller address.  */
+#define STACK_GROWS_DOWNWARD 1
+
+/* Define this macro to nonzero value if the addresses of local variable slots
+   are at negative offsets from the frame pointer.  */
+#define FRAME_GROWS_DOWNWARD 1
+
+/* Offset from the argument pointer register to the first argument's
+   address.  On some machines it may depend on the data type of the
+   function.  */
+#define FIRST_PARM_OFFSET(F) 12
+
+/* A C expression whose value is RTL representing the location of the
+   incoming return address at the beginning of any function, before
+   the prologue.  */
+#define INCOMING_RETURN_ADDR_RTX					\
+  gen_frame_mem (Pmode,							\
+		 plus_constant (Pmode, stack_pointer_rtx, UNITS_PER_WORD))
+
+/* Describe how we implement __builtin_eh_return.  */
+#define EH_RETURN_DATA_REGNO(N)	((N) < 4 ? (N+2) : INVALID_REGNUM)
+
+/* Store the return handler into the call frame.  */
+#define EH_RETURN_HANDLER_RTX						\
+  gen_frame_mem (Pmode,							\
+		 plus_constant (Pmode, frame_pointer_rtx, UNITS_PER_WORD))
+
+/* The register number of the stack pointer register, which must also
+   be a fixed register according to `FIXED_REGISTERS'.  */
+#define STACK_POINTER_REGNUM LOBSTER128_SP
+
+/* The register number of the frame pointer register, which is used to
+   access automatic variables in the stack frame.  */
+#define FRAME_POINTER_REGNUM LOBSTER128_FP
+
+/* The register number of the arg pointer register, which is used to
+   access the function's argument list.  */
+#define ARG_POINTER_REGNUM LOBSTER128_FP
+
+#define RETURN_ADDRESS_POINTER_REGNUM LOBSTER128_FIRST
+
+#define ELIMINABLE_REGS							\
+{{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM }, \
+ { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM }, \
+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM }}			
+
+/* Passing Function Arguments on the Stack.  */
+
+/* #define PUSH_ROUNDING(BYTES) 0 */
+
+#define ACCUMULATE_OUTGOING_ARGS 1
+
+#define REG_PARM_STACK_SPACE(FNDECL) 0
+
+#define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) 1
+
+/* Define this macro as a C expression that is nonzero for registers that are
+   used by the epilogue or the return pattern.  The stack and frame
+   pointer registers are already assumed to be used as needed.  */
+#define EPILOGUE_USES(R) 0
+
+/* Function Arguments in Registers.  */
+
+#define MAX_ARGS_IN_REGISTERS 32
+
+/* A C type for declaring a variable that is used as the first
+   argument of `FUNCTION_ARG' and other related values.  */
+#define CUMULATIVE_ARGS unsigned int
+
+/* If defined, the maximum amount of space required for outgoing arguments
+   will be computed and placed into the variable
+   `current_function_outgoing_args_size'.  No space will be pushed
+   onto the stack for each call; instead, the function prologue should
+   increase the stack frame size by this amount.  */
+#define ACCUMULATE_OUTGOING_ARGS 1
+
+/* A C statement (sans semicolon) for initializing the variable CUM
+   for the state at the beginning of the argument list.  
+   For Lobster128, the first arg is passed in register determined by ARG.  */
+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,FNDECL,N_NAMED_ARGS) \
+  (CUM = LOBSTER128_FIRST)
+
+#define FUNCTION_ARG_REGNO_P(N)						\
+  (((N) >= LOBSTER128_FIRST && (N) <= LOBSTER128_LAST))
+
+/* Trampolines for Nested Functions.  */
+#define TRAMPOLINE_SIZE (2 + 6 + 4 + 2 + 6)
+
+/* Alignment required for trampolines, in bits.  */
+#define TRAMPOLINE_ALIGNMENT 32
+
+/* Addressing Modes.  */
+
+#define MAX_REGS_PER_ADDRESS 1
+
+/* Define this macro as a C expression which is nonzero if accessing
+   less than a word of memory (i.e. a `char' or a `short') is no
+   faster than accessing a word of memory.  */
+#define SLOW_BYTE_ACCESS 1
+
+/* Dividing the output into sections.  */
+
+#define TEXT_SECTION_ASM_OP	"\t.text"	/* Instructions.  */
+
+#define DATA_SECTION_ASM_OP	"\t.data"	/* Large data.  */
+
+/* The Overall Framework of an Assembler File.  */
+
+#define ASM_COMMENT_START " #"
+
+#define ASM_APP_ON "#APP\n"
+
+#define ASM_APP_OFF "#NO_APP\n"
+
+
+/* Output and Generation of Labels.  */
+
+#undef ASM_GENERATE_INTERNAL_LABEL
+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)			\
+  sprintf ((LABEL), "*%s%s%ld", (LOCAL_LABEL_PREFIX), (PREFIX), (long) (NUM))
+
+#define GLOBAL_ASM_OP "\t.globl\t"
+
+
+/* Output of Assembler Instructions.  */
+
+#define REGISTER_NAMES							\
+{									\
+ "ZERO", "PC",   "SP",   "FP",   "R4",   "R5",   "R6",   "R7",   \
+ "R8",   "R9",   "R10",  "R11",  "R12",  "R13",  "R14",  "R15",  \
+ "R16",  "R17",  "R18",  "R19",  "R20",  "R21",  "R22",  "R23",  \
+ "R24",  "R25",  "R26",  "R27",  "R28",  "R29",  "R30",  "R31",  \
+ "R32",  "R34",  "R35",  "R36",  "R37",  "R38",  "R39",  "R40",  \
+ "R41",  "R42",  "R43",  "R44",  "R45",  "R46",  "R47",  "R48",  \
+ "R49",  "R50",  "R51",  "R52",  "R53",  "R54",  "R55",  "R56",  \
+ "R57",  "R58",  "R59",  "R60",  "R61",  "R62",  "R63",  "R64",  \
+ "R65",  "R66",  "R67",  "R68",  "R69",  "R70",  "R71",  "R72",  \
+ "R73",  "R74",  "R75",  "R76",  "R77",  "R78",  "R79",  "R80",  \
+ "R81",  "R82",  "R83",  "R84",  "R85",  "R86",  "R87",  "R88",  \
+ "R89",  "R90",  "R91",  "R92",  "R93",  "R94",  "R95",  "R96",  \
+ "R97",  "R98",  "R99",  "R100", "R101", "R102", "R103", "R104", \
+ "R105", "R106", "R107", "R108", "R109", "R110", "R111", "R112", \
+ "R113", "R114", "R115", "R116", "R117", "R118", "R119", "R120", \
+ "R121", "R122", "R123", "R124", "R125", "R126", "R127", "R128", \
+ "CC", \
+}
+
+#define LOCAL_LABEL_PREFIX	"$"
+
+#define USER_LABEL_PREFIX	""
+
+/* All load operations zero extend.  */
+#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND
+
+/* Specify the machine mode that pointers have.
+   After generation of rtl, the compiler makes no further distinction
+   between pointers and any other objects of this machine mode.  */
+#define Pmode DImode
+
+/* An alias for the machine mode used for memory references to
+   functions being called, in `call' RTL expressions.  */
+#define FUNCTION_MODE DImode
+
+/* Maximum number of registers that can appear in a valid memory
+   address.  */
+#define MAX_REGS_PER_ADDRESS 1
+
+/* A C expression which is nonzero if register number NUM is suitable
+   for use as a base register in operand addresses.  */
+#define REGNO_OK_FOR_BASE_P(NUM) \
+  ((unsigned) (NUM) < FIRST_PSEUDO_REGISTER \
+   && (REGNO_REG_CLASS(NUM) == GR_REGS \
+       || (NUM) == LOBSTER128_FP))
+
+/* A C expression which is nonzero if register number NUM is suitable
+   for use as an index register in operand addresses.  */
+#define REGNO_OK_FOR_INDEX_P(NUM) LOBSTER128_FP
+
+/* An alias for a machine mode name.  This is the machine mode that
+   elements of a jump-table should have.  */
+#define CASE_VECTOR_MODE DImode
+
+/* Generating Code for Profiling */
+#define FUNCTION_PROFILER(FILE,LABELNO) (abort (), 0)
+
+/* The maximum number of bytes that a single instruction can move quickly from
+   memory to memory.  */
+#define MOVE_MAX 8
+
+/* This macro returns the initial difference between the specified pair
+   of registers.  */
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)			\
+  do {									\
+    (OFFSET) = lobster128_initial_elimination_offset ((FROM), (TO));		\
+  } while (0)
diff --git a/gcc/config/lobster128/lobster128.md b/gcc/config/lobster128/lobster128.md
new file mode 100644
index 00000000000..63f21ed0185
--- /dev/null
+++ b/gcc/config/lobster128/lobster128.md
@@ -0,0 +1,322 @@
+;;  lobster128.md	     Machine Description for lobster128 processors
+;;  Copyright (C) 2003-2022 Free Software Foundation, Inc.
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+(include "constraints.md")
+(include "predicates.md")
+
+(define_constants
+  [(ZERO_REG 0)
+   (PC_REG 1)
+   (SP_REG 2)
+   (FP_REG 3)
+   (CC_REG 128)])
+
+; All instructions are 8 bytes long
+(define_attr "length" "" (const_int 8))
+
+; Lenght of operands
+(define_mode_iterator MODE [QI HI SI DI TI])
+;(define_mode_attr mode [(QI "qi") (HI "hi") (SI "si") (DI "di") (TI "ti")])
+(define_mode_attr lenx [(QI ".CHR") (HI ".HLF") (SI ".WRD") (DI ".DWO") (TI ".OWO")])
+
+; Handle both unsigned and signed arithmethics
+(define_code_iterator EXTEND [sign_extend zero_extend])
+(define_code_attr u [(sign_extend "") (zero_extend "u")])
+(define_code_attr sgnprefix [(sign_extend "I.") (zero_extend "Z.")])
+
+;; -------------------------------------------------------------------------
+;; nop instruction
+;; -------------------------------------------------------------------------
+(define_insn "nop"
+  [(const_int 0)]
+  ""
+  "Z.NOP.OWO")
+
+;; -------------------------------------------------------------------------
+;; Arithmetic instructions
+;; -------------------------------------------------------------------------
+(define_insn "add<mode>3"
+  [(set (match_operand:MODE 0 "register_operand" "=r,r")
+	  (plus:MODE
+	   (match_operand:MODE 1 "lobster128_arith_operand" "r,r")
+	   (match_operand:MODE 2 "lobster128_arith_operand" "r,L")))]
+  ""
+  "Z.ADD<lenx> %0,%1,%2")
+
+(define_insn "sub<mode>3"
+  [(set (match_operand:MODE 0 "register_operand" "=r,r")
+	  (minus:MODE
+	   (match_operand:MODE 1 "lobster128_arith_operand" "r,r")
+	   (match_operand:MODE 2 "lobster128_arith_operand" "r,L")))]
+  ""
+  "Z.SUB<lenx> %0,%1,%2")
+
+(define_insn "mul<mode>3"
+  [(set (match_operand:MODE 0 "register_operand" "=r")
+	  (mult:MODE
+	   (match_operand:MODE 1 "register_operand" "r")
+	   (match_operand:MODE 2 "lobster128_arith_operand" "r")))]
+  ""
+  "Z.MUL<lenx> %0,%1,%2")
+
+(define_insn "div<mode>3"
+  [(set (match_operand:MODE 0 "register_operand" "=r")
+	  (div:MODE
+	   (match_operand:MODE 1 "register_operand" "r")
+	   (match_operand:MODE 2 "lobster128_arith_operand" "r")))]
+  ""
+  "Z.DIV<lenx> %0,%1,%2")
+
+(define_insn "mod<mode>3"
+  [(set (match_operand:MODE 0 "register_operand" "=r")
+	  (mod:MODE
+	   (match_operand:MODE 1 "register_operand" "r")
+	   (match_operand:MODE 2 "lobster128_arith_operand" "r")))]
+  ""
+  "Z.MOD<lenx> %0,%1,%2")
+
+(define_insn "ashl<mode>3"
+  [(set (match_operand:MODE 0 "register_operand" "=r")
+	  (ashift:MODE
+	   (match_operand:MODE 1 "register_operand" "r")
+	   (match_operand:MODE 2 "lobster128_arith_operand" "r")))]
+  ""
+  "Z.LSH<lenx> %0,%1,%2")
+
+(define_insn "ashr<mode>3"
+  [(set (match_operand:MODE 0 "register_operand" "=r")
+	  (ashiftrt:MODE
+	   (match_operand:MODE 1 "register_operand" "r")
+	   (match_operand:MODE 2 "lobster128_arith_operand" "r")))]
+  ""
+  "Z.RSH<lenx> %0,%1,%2")
+
+(define_insn "xor<mode>3"
+  [(set (match_operand:MODE 0 "register_operand" "=r")
+	  (xor:MODE
+	   (match_operand:MODE 1 "register_operand" "r")
+	   (match_operand:MODE 2 "lobster128_arith_operand" "r")))]
+  ""
+  "Z.XOR<lenx> %0,%1,%2")
+
+(define_insn "ior<mode>3"
+  [(set (match_operand:MODE 0 "register_operand" "=r")
+	  (ior:MODE
+	   (match_operand:MODE 1 "register_operand" "r")
+	   (match_operand:MODE 2 "lobster128_arith_operand" "r")))]
+  ""
+  "Z.OR<lenx> %0,%1,%2")
+
+(define_insn "and<mode>3"
+  [(set (match_operand:MODE 0 "register_operand" "=r")
+	  (and:MODE
+	   (match_operand:MODE 1 "register_operand" "r")
+	   (match_operand:MODE 2 "lobster128_arith_operand" "r")))]
+  ""
+  "Z.AND<lenx> %0,%1,%2")
+
+(define_insn "mov<mode>"
+  [(set (match_operand:MODE 0 "nonimmediate_operand" "=r,r,m,r,r,r,r,r")
+	(match_operand:MODE 1 "general_operand" "O,r,r,m,I,J,K,L"))]
+  ""
+  "@
+   Z.XOR<lenx> %0,%1
+   Z.TRANS<lenx> %0,%1
+   Z.STORE<lenx> %0,%1
+   Z.LOAD<lenx> %0,%1
+   Z.LOAD<lenx> %0,%1
+   Z.LOAD<lenx> %0,%1
+   Z.LOAD<lenx> %0,%1
+   Z.LOAD<lenx> %0,%1"
+  )
+
+(define_insn "*mov<mode>"
+  [(set (match_operand:MODE 0 "nonimmediate_operand" "=r,r,m,r,r,r,r,r")
+	(match_operand:MODE 1 "general_operand" "O,r,r,m,I,J,K,L"))]
+  ""
+  "@
+   Z.XOR<lenx> %0,%1
+   Z.TRANS<lenx> %0,%1
+   Z.STORE<lenx> %0,%1
+   Z.LOAD<lenx> %0,%1
+   Z.LOAD<lenx> %0,%1
+   Z.LOAD<lenx> %0,%1
+   Z.LOAD<lenx> %0,%1
+   Z.LOAD<lenx> %0,%1"
+  )
+
+(define_insn "zero_extend<mode>ti2"
+  [(set (match_operand:MODE 0 "register_operand" "=r,m,r")
+	(zero_extend:MODE (match_operand:TI 1 "nonimmediate_operand" "r,r,m")))]
+  ""
+  "@
+  <sgnprefix>EXT<lenx> %0,%1
+  <sgnprefix>EXT<lenx> %0,%1
+  <sgnprefix>EXT<lenx> %0,%1"
+)
+
+(define_insn "sign_extend<mode>ti2"
+  [(set (match_operand:MODE 0 "register_operand" "=r,m,r")
+	(sign_extend:MODE (match_operand:TI 1 "nonimmediate_operand" "r,r,m")))]
+  ""
+  "@
+  <sgnprefix>SXT<lenx> %0,%1
+  <sgnprefix>SXT<lenx> %0,%1
+  <sgnprefix>SXT<lenx> %0,%1"
+)
+
+;; -------------------------------------------------------------------------
+;; Compare instructions
+;; -------------------------------------------------------------------------
+(define_insn "cmp<mode>"
+  [(set (reg:CC CC_REG) (compare
+	 (match_operand:MODE 0 "general_operand" "r,m,r")
+	 (match_operand:MODE 1 "general_operand" "r,r,m")))]
+  ""
+  "@
+  Z.CMP<lenx> %0,%1
+  Z.CMP<lenx> %0,%1
+  Z.CMP<lenx> %0,%1")
+
+;; Push a register onto the stack
+(define_insn "mov<mode>_push"
+  [(set (mem:MODE (pre_dec:MODE (reg:MODE 1)))
+  	(match_operand:MODE 0 "register_operand" "r"))]
+  ""
+  "Z.PUSH<lenx> %0,%1")
+
+;; Pop a register from the stack
+(define_insn "mov<mode>_pop"
+  [(set (match_operand:MODE 1 "register_operand" "=r")
+  	(mem:MODE (post_inc:MODE (match_operand:MODE 0 "register_operand" "r"))))]
+  ""
+  "Z.POP<lenx> %0,%1")
+
+;; -------------------------------------------------------------------------
+;; Branch instructions
+;; -------------------------------------------------------------------------
+
+(define_code_iterator cond [ne eq lt ltu gt gtu ge le geu leu])
+(define_code_attr rCC [(ne "EQU") (eq "NEQ") (lt "GTE") (ltu "GEU") 
+		       (gt "LTE") (gtu "LEU") (ge "LTH") (le "GTH") 
+		       (geu "LTU") (leu "GTU") ])
+
+(define_insn "*b<cond:code>"
+  [(set (pc)
+	(if_then_else (cond (reg:CC CC_REG)
+			    (const_int 0))
+          (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  "Z.BCH.<rCC> %0")
+
+(define_insn "*b<cond:code>"
+  [(set (pc)
+	(if_then_else (cond (reg:CC CC_REG)
+			    (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "Z.BCH.<rCC> %0")
+
+;; -------------------------------------------------------------------------
+;; Call and Jump instructions
+;; -------------------------------------------------------------------------
+
+(define_expand "call"
+  [(call (match_operand:QI 0 "memory_operand" "")
+		(match_operand 1 "general_operand" ""))]
+  ""
+{
+  gcc_assert (MEM_P (operands[0]));
+})
+
+(define_insn "*call"
+  [(call (mem:QI (match_operand:DI
+		  0 "nonmemory_operand" "i,r"))
+	 (match_operand 1 "" ""))]
+  ""
+  "@
+   Z.JMP %0
+   Z.JMP %0"
+  )
+
+(define_expand "call_value"
+  [(set (match_operand 0 "" "")
+		(call (match_operand:TI 1 "memory_operand" "")
+		 (match_operand 2 "" "")))]
+  ""
+{
+  gcc_assert (MEM_P (operands[1]));
+})
+
+(define_insn "*call_value"
+  [(set (match_operand 0 "register_operand" "=r")
+	(call (mem:TI (match_operand:TI
+		       1 "immediate_operand" "i"))
+	      (match_operand 2 "" "")))]
+  ""
+  "Z.JMP %1")
+
+(define_insn "*call_value_indirect"
+  [(set (match_operand 0 "register_operand" "=r")
+	(call (mem:TI (match_operand:TI
+		       1 "register_operand" "r"))
+	      (match_operand 2 "" "")))]
+  ""
+  "Z.JMP %1")
+
+(define_insn "indirect_jump"
+  [(set (pc) (match_operand:TI 0 "nonimmediate_operand" "r"))]
+  ""
+  "Z.JMP %0")
+
+(define_insn "jump"
+  [(set (pc)
+	(label_ref (match_operand 0 "" "")))]
+  ""
+  "Z.JMP %0")
+
+;; -------------------------------------------------------------------------
+;; Prologue & Epilogue
+;; -------------------------------------------------------------------------
+(define_expand "prologue"
+  [(clobber (const_int 0))]
+  ""
+  "
+{
+  lobster128_expand_prologue ();
+  DONE;
+}
+")
+
+(define_expand "epilogue"
+  [(return)]
+  ""
+  "
+{
+  lobster128_expand_epilogue ();
+  DONE;  
+}
+")
+
+(define_insn "returner"
+  [(return)]
+  "reload_completed"
+  "Z.RET.OWO")
diff --git a/gcc/config/lobster128/lobster128.opt b/gcc/config/lobster128/lobster128.opt
new file mode 100644
index 00000000000..6aa28006001
--- /dev/null
+++ b/gcc/config/lobster128/lobster128.opt
@@ -0,0 +1,19 @@
+; Options for the lobster128 port of the compiler.
+
+; Copyright (C) 2005-2022 Free Software Foundation, Inc.
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify it under
+; the terms of the GNU General Public License as published by the Free
+; Software Foundation; either version 3, or (at your option) any later
+; version.
+;
+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+; WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+; for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING3.  If not see
+; <http://www.gnu.org/licenses/>.
diff --git a/gcc/config/lobster128/predicates.md b/gcc/config/lobster128/predicates.md
new file mode 100644
index 00000000000..f9a3154b67a
--- /dev/null
+++ b/gcc/config/lobster128/predicates.md
@@ -0,0 +1,23 @@
+;; Predicate definitions for LOBSTER128.
+;; Copyright (C) 2005-2022 Free Software Foundation, Inc.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+(define_predicate "lobster128_arith_operand"
+  (ior (match_code "reg")
+       (and (match_code "const_int")
+	    (match_test "IN_RANGE (INTVAL (op), 0, 0xffffffff)"))))
diff --git a/gcc/lra-int.h b/gcc/lra-int.h
index 04baefef348..710c9483226 100644
--- a/gcc/lra-int.h
+++ b/gcc/lra-int.h
@@ -26,7 +26,7 @@ along with GCC; see the file COPYING3.	If not see
 /* The parameter used to prevent infinite reloading for an insn.  Each
    insn operands might require a reload and, if it is a memory, its
    base and index registers might require a reload too.	 */
-#define LRA_MAX_INSN_RELOADS (MAX_RECOG_OPERANDS * 3)
+#define LRA_MAX_INSN_RELOADS (MAX_RECOG_OPERANDS * 5)
 
 typedef struct lra_live_range *lra_live_range_t;
 
diff --git a/libgcc/config.host b/libgcc/config.host
index b2a0a8e1aa9..c0d8883225e 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -138,6 +138,9 @@ hppa*-*-*)
 lm32*-*-*)
 	cpu_type=lm32
 	;;
+lobster128*)
+	cpu_type=lobster128
+	;;
 loongarch*-*-*)
 	cpu_type=loongarch
 	tmake_file="loongarch/t-loongarch"
diff --git a/libgcc/config/lobster128/crti.S b/libgcc/config/lobster128/crti.S
new file mode 100644
index 00000000000..063d2025a33
--- /dev/null
+++ b/libgcc/config/lobster128/crti.S
@@ -0,0 +1,40 @@
+# crti.S for lobster128
+#
+#   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+# 
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the
+# Free Software Foundation; either version 3, or (at your option) any
+# later version.
+# 
+# This file is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+# 
+# Under Section 7 of GPL version 3, you are granted additional
+# permissions described in the GCC Runtime Library Exception, version
+# 3.1, as published by the Free Software Foundation.
+#
+# You should have received a copy of the GNU General Public License and
+# a copy of the GCC Runtime Library Exception along with this program;
+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+# <http://www.gnu.org/licenses/>.
+
+# This file just make a stack frame for the contents of the .fini and
+# .init sections.  Users may put any desired instructions in those
+# sections.
+
+	.file		"crti.S"
+
+	.section	".init"
+	.global	_init
+	.type	_init, @function	
+	.p2align	1
+_init:
+
+	.section	".fini"
+	.global	_fini
+	.type	_fini,@function
+	.p2align	1
+_fini:
diff --git a/libgcc/config/lobster128/crtn.S b/libgcc/config/lobster128/crtn.S
new file mode 100644
index 00000000000..904914fa050
--- /dev/null
+++ b/libgcc/config/lobster128/crtn.S
@@ -0,0 +1,34 @@
+# crtn.S for lobster128
+# 
+#   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+# 
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the
+# Free Software Foundation; either version 3, or (at your option) any
+# later version.
+# 
+# This file is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+# 
+# Under Section 7 of GPL version 3, you are granted additional
+# permissions described in the GCC Runtime Library Exception, version
+# 3.1, as published by the Free Software Foundation.
+#
+# You should have received a copy of the GNU General Public License and
+# a copy of the GCC Runtime Library Exception along with this program;
+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+# <http://www.gnu.org/licenses/>.
+
+# This file just makes sure that the .fini and .init sections do in
+# fact return.  Users may put any desired instructions in those sections.
+# This file is the last thing linked into any executable.
+
+	.file		"crtn.S"
+
+	.section	".init"
+	Z.RET.OWO
+	
+	.section	".fini"
+	Z.RET.OWO
diff --git a/libgcc/config/lobster128/sfp-machine.h b/libgcc/config/lobster128/sfp-machine.h
new file mode 100644
index 00000000000..7874081fdab
--- /dev/null
+++ b/libgcc/config/lobster128/sfp-machine.h
@@ -0,0 +1,51 @@
+/* Use 32-bit types here to prevent longlong.h trying to use TImode.
+   Once TImode works we might be better to use 64-bit here.  */
+
+#define _FP_W_TYPE_SIZE		32
+#define _FP_W_TYPE		unsigned int
+#define _FP_WS_TYPE		signed int
+#define _FP_I_TYPE		int
+
+#define _FP_MUL_MEAT_S(R,X,Y)				\
+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_D(R,X,Y)				\
+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_loop(S,R,X,Y)
+#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_2_udiv(D,R,X,Y)
+
+#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
+#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+
+#define _FP_KEEPNANFRACP 1
+#define _FP_QNANNEGATEDP 0
+
+/* Someone please check this.  */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)			\
+  do {								\
+    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)		\
+	&& !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))	\
+      {								\
+	R##_s = Y##_s;						\
+	_FP_FRAC_COPY_##wc(R,Y);				\
+      }								\
+    else							\
+      {								\
+	R##_s = X##_s;						\
+	_FP_FRAC_COPY_##wc(R,X);				\
+      }								\
+    R##_c = FP_CLS_NAN;						\
+  } while (0)
+
+#define _FP_TININESS_AFTER_ROUNDING 0
+
+#define __LITTLE_ENDIAN 1234
+#define	__BIG_ENDIAN	4321
+#define __BYTE_ORDER __LITTLE_ENDIAN
+
+/* Define ALIASNAME as a strong alias for NAME.  */
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+# define _strong_alias(name, aliasname) \
+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));
