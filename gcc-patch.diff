diff --git a/config.guess b/config.guess
index 1972fda8eb0..3a3c543ceb9 100755
--- a/config.guess
+++ b/config.guess
@@ -995,6 +995,9 @@ EOF
     k1om:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
+	lobster128:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
     loongarch32:Linux:*:* | loongarch64:Linux:*:* | loongarchx32:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
diff --git a/config.sub b/config.sub
index 38f3d037a78..9fe774727ee 100755
--- a/config.sub
+++ b/config.sub
@@ -1202,6 +1202,7 @@ case $cpu-$vendor in
 			| k1om \
 			| le32 | le64 \
 			| lm32 \
+			| lobster128 \
 			| loongarch32 | loongarch64 | loongarchx32 \
 			| m32c | m32r | m32rle \
 			| m5200 | m68000 | m680[012346]0 | m68360 | m683?2 | m68k \
diff --git a/configure b/configure
index 81c034b553f..5fec4c973af 100755
--- a/configure
+++ b/configure
@@ -4026,6 +4026,9 @@ case "${target}" in
   wasm32-*-*)
     noconfigdirs="$noconfigdirs ld"
     ;;
+  lobster128-*-*)
+    noconfigdirs="$noconfigdirs"
+    ;;
   loongarch*-*-linux*)
     ;;
   loongarch*-*-*)
diff --git a/configure.ac b/configure.ac
index 13f8c5f2a9f..b03e2142191 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1283,6 +1283,9 @@ case "${target}" in
   wasm32-*-*)
     noconfigdirs="$noconfigdirs ld"
     ;;
+  lobster128-*-*)
+    noconfigdirs="$noconfigdirs"
+    ;;
   loongarch*-*-linux*)
     ;;
   loongarch*-*-*)
diff --git a/gcc/config.gcc b/gcc/config.gcc
index 02f58970db0..2b83c6f006e 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -453,6 +453,11 @@ mips*-*-*)
 	extra_objs="frame-header-opt.o"
 	extra_options="${extra_options} g.opt fused-madd.opt mips/mips-tables.opt"
 	;;
+lobster128*)
+    cpu_type=lobster128
+	extra_modes=lobster128/lobster128-modes.def
+	target_has_targetm_common=no
+    ;;
 loongarch*-*-*)
 	cpu_type=loongarch
 	extra_headers="larchintrin.h"
@@ -2502,7 +2507,12 @@ riscv*-*-freebsd*)
 	# automatically detect that GAS supports it, yet we require it.
 	gcc_cv_initfini_array=yes
 	;;
-
+lobster128*-*-linux* | lobster128*-*-elf*)
+	gas=yes
+	gnu_ld=yes
+	tm_file="${tm_file} dbxelf.h elfos.h newlib-stdint.h"
+	tmake_file="${tmake_file}"
+	;;
 loongarch*-*-linux*)
 	tm_file="dbxelf.h elfos.h gnu-user.h linux.h linux-android.h glibc-stdint.h ${tm_file}"
 	tm_file="${tm_file} loongarch/gnu-user.h loongarch/linux.h"
diff --git a/gcc/config/lobster128/constraints.md b/gcc/config/lobster128/constraints.md
new file mode 100644
index 00000000000..65efcabaf11
--- /dev/null
+++ b/gcc/config/lobster128/constraints.md
@@ -0,0 +1,63 @@
+;; Constraints for Vitesse IQ2000 processors
+;; Copyright (C) 2011-2022 Free Software Foundation, Inc.
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+(define_register_constraint "f" "GR_REGS"
+  "A floating-point register.")
+
+;; Integer constraints.
+(define_constraint "O"
+  "Zero."
+  (and (match_code "const_int")
+       (match_test "ival == 0")))
+
+(define_constraint "N"
+  "A constant 8-bit signed integer -(0..255)"
+  (and (match_code "const_int")
+       (match_test "ival >= -255 && ival <= 0")))
+
+(define_constraint "I"
+  "A 16-bit signed integer."
+  (and (match_code "const_int")
+       (match_test "IN_RANGE (ival, -32768, 32767)")))
+
+(define_constraint "K"
+  "A 16-bit unsigned integer"
+  (and (match_code "const_int")
+       (match_test "IN_RANGE (ival, 0, 65535)")))
+
+(define_constraint "J"
+  "A 32-bit constant."
+  (and (match_code "const_int")
+       (match_test "IN_RANGE (ival, 0, 0xffffffff)")))
+
+(define_constraint "L"
+  "A 64-bit constant."
+  (and (match_code "const_int")
+       (match_test "IN_RANGE (ival, 0, 0xffffffffffffffff)")))
+
+(define_constraint "M"
+  "A 13-bit constant."
+  (and (match_code "const_int")
+       (match_test "IN_RANGE (ival, 0, 0x1fff)")))
+
+(define_constraint "W"
+  "A register indirect memory operand."
+  (and (match_code "mem")
+       (match_test "REG_P (XEXP (op, 0))
+		    && REGNO_OK_FOR_BASE_P (REGNO (XEXP (op, 0)))")))
diff --git a/gcc/config/lobster128/lobster128-modes.def b/gcc/config/lobster128/lobster128-modes.def
new file mode 100644
index 00000000000..70b4fbbdc23
--- /dev/null
+++ b/gcc/config/lobster128/lobster128-modes.def
@@ -0,0 +1,30 @@
+/* Definitions of target machine GNU compiler.
+   Copyright (C) 2002-2022 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+FRACTIONAL_FLOAT_MODE (XF, 127, 16, ieee_extended_intel_128_format);
+FLOAT_MODE (TF, 16, ieee_quad_format);
+
+/* Vector modes.  */
+VECTOR_MODES (INT, 4);		/* V4QI V2HI */
+VECTOR_MODES (INT, 8);		/* V8QI V4HI V2SI */
+VECTOR_MODE (INT, QI, 16);
+VECTOR_MODE (INT, HI, 8);
+VECTOR_MODE (INT, SI, 4);
+VECTOR_MODE (FLOAT, SF, 2);
+VECTOR_MODE (FLOAT, SF, 4);
diff --git a/gcc/config/lobster128/lobster128-protos.h b/gcc/config/lobster128/lobster128-protos.h
new file mode 100644
index 00000000000..92eca311d45
--- /dev/null
+++ b/gcc/config/lobster128/lobster128-protos.h
@@ -0,0 +1,24 @@
+/* Definitions of target machine for GNU compiler for lobster128.
+   Copyright (C) 2003-2022 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+extern void  lobster128_expand_prologue (void);
+extern void  lobster128_expand_epilogue (void);
+extern int   lobster128_initial_elimination_offset (int, int);
+extern bool  lobster128_offset_address_p (rtx);
+
diff --git a/gcc/config/lobster128/lobster128.cc b/gcc/config/lobster128/lobster128.cc
new file mode 100644
index 00000000000..ac7e6395ec3
--- /dev/null
+++ b/gcc/config/lobster128/lobster128.cc
@@ -0,0 +1,560 @@
+/* Subroutines used for code generation on Vitesse lobster128 processors
+   Copyright (C) 2003-2022 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#define IN_TARGET_CODE 1
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "backend.h"
+#include "target.h"
+#include "rtl.h"
+#include "tree.h"
+#include "stringpool.h"
+#include "attribs.h"
+#include "df.h"
+#include "memmodel.h"
+#include "tm_p.h"
+#include "optabs.h"
+#include "regs.h"
+#include "emit-rtl.h"
+#include "recog.h"
+#include "diagnostic-core.h"
+#include "stor-layout.h"
+#include "calls.h"
+#include "varasm.h"
+#include "output.h"
+#include "insn-attr.h"
+#include "explow.h"
+#include "expr.h"
+#include "langhooks.h"
+#include "builtins.h"
+
+/* This file should be included last.  */
+#include "target-def.h"
+
+/* Global variables for machine-dependent things.  */
+
+/* Per-function machine data.  */
+struct GTY(()) machine_function
+{
+  /* Number of bytes saved on the stack for callee saved registers.  */
+  int callee_saved_reg_size;
+
+  /* Number of bytes saved on the stack for local variables.  */
+  int local_vars_size;
+
+  /* The sum of 2 sizes: locals vars and padding byte for saving the
+   * registers.  Used in expand_prologue () and expand_epilogue().  */
+  int size_for_adjusting_sp;
+};
+
+void lobster128_init_builtins(void)
+{
+
+}
+
+/* Worker function for TARGET_SETUP_INCOMING_VARARGS.  */
+static void
+lobster128_setup_incoming_varargs(cumulative_args_t cum_v,
+                                  const function_arg_info &,
+                                  int *pretend_size, int no_rtl)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args(cum_v);
+  int regs = LOBSTER128_LAST - cum->used_regs;
+
+  *pretend_size = regs < 0 ? 0 : GET_MODE_SIZE(TImode) * regs;
+
+  if (no_rtl)
+    return;
+
+  for (int regno = cum->used_regs; regno < LOBSTER128_MAX_ARG_REGNO; regno++)
+  {
+    rtx reg = gen_rtx_REG(TImode, regno);
+    rtx slot = gen_rtx_PLUS(Pmode,
+                            gen_rtx_REG(TImode, ARG_POINTER_REGNUM),
+                            GEN_INT(GET_MODE_SIZE(TImode) * ((regno - 4))));
+    emit_move_insn(gen_rtx_MEM(TImode, slot), reg);
+  }
+}
+
+/* Worker function for TARGET_TRAMPOLINE_INIT.  */
+static void
+lobster128_trampoline_init(rtx m_tramp, tree fndecl, rtx chain_value)
+{
+  emit_block_move(m_tramp, assemble_trampoline_template(),
+                  GEN_INT(TRAMPOLINE_SIZE), BLOCK_OP_NORMAL);
+  rtx mem = adjust_address(m_tramp, TImode, 16);
+  emit_move_insn(mem, chain_value);
+  mem = adjust_address(m_tramp, TImode, 32);
+  rtx fnaddr = XEXP(DECL_RTL(fndecl), 0);
+  emit_move_insn(mem, fnaddr);
+}
+
+/* Worker function for TARGET_RETURN_IN_MEMORY.  */
+static bool
+lobster128_return_in_memory(const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
+{
+  const HOST_WIDE_INT size = int_size_in_bytes(type);
+  return (size == -1 || size > GET_MODE_SIZE(TImode));
+}
+
+/* Zero initialization is OK for all current fields.  */
+static struct machine_function *
+losbter128_init_machine_status(void)
+{
+  return ggc_cleared_alloc<machine_function>();
+}
+
+/* Helper function for `lobster128_legitimate_address_p'.  */
+static bool
+lobster128_reg_ok_for_base_p(const_rtx reg, bool strict)
+{
+  if (strict && REGNO_OK_FOR_BASE_P (REGNO (reg)))
+    return true;
+  else if (!strict
+	   && ((REGNO (reg) < LOBSTER128_LAST) || !HARD_REGISTER_P (reg)))
+    return true;
+  else
+    return false;
+}
+
+/* Worker function for TARGET_LEGITIMATE_ADDRESS_P.  */
+static bool
+lobster128_legitimate_address_p(machine_mode mode,
+                                rtx x, bool strict_p,
+                                addr_space_t as)
+{
+  gcc_assert(ADDR_SPACE_GENERIC_P(as));
+  if (REG_P(x) && lobster128_reg_ok_for_base_p(x, strict_p))
+    return true;
+  
+  switch(GET_CODE(x))
+  {
+    case PLUS:
+      if(REG_P(XEXP(x, 0)) && lobster128_reg_ok_for_base_p(XEXP(x, 0), strict_p) && CONST_INT_P(XEXP(x, 1)) && IN_RANGE(INTVAL(XEXP(x, 1)), 0, 0xffffffffffffffff))
+      {
+        return true;
+      }
+      break;
+    case SYMBOL_REF:
+    case LABEL_REF:
+    case CONST:
+    case CONST_INT:
+      return true;
+    default:
+      break;
+  }
+  return false;
+}
+
+/* Return non-zero if the function argument described by ARG is to be
+   passed by reference.  */
+static bool
+lobster128_pass_by_reference(cumulative_args_t, const function_arg_info &arg)
+{
+  if (arg.aggregate_type_p())
+    return true;
+  unsigned HOST_WIDE_INT size = arg.type_size_in_bytes();
+  return size > GET_MODE_SIZE(TImode);
+}
+
+/* Some function arguments will only partially fit in the registers
+   that hold arguments.  Given a new arg, return the number of bytes
+   that fit in argument passing registers.  */
+static int
+lobster128_arg_partial_bytes(cumulative_args_t cum_v, const function_arg_info &arg)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args(cum_v);
+  if (cum->used_regs >= LOBSTER128_MAX_ARG_REGNO)
+    return 0;
+
+  int size;
+  if (lobster128_pass_by_reference(cum_v, arg))
+    size = 4;
+  else if (arg.type)
+  {
+    if (AGGREGATE_TYPE_P(arg.type))
+      return 0;
+    size = int_size_in_bytes(arg.type);
+  }
+  else
+    size = GET_MODE_SIZE(arg.mode);
+
+  int bytes_left = ((cum->used_regs - 4) * GET_MODE_SIZE(TImode));
+  if (size > bytes_left)
+    return bytes_left;
+  else
+    return 0;
+}
+
+/* Worker function for TARGET_STATIC_CHAIN.  */
+static rtx
+lobster128_static_chain(const_tree ARG_UNUSED(fndecl_or_type), bool incoming_p)
+{
+  rtx addr;
+  if (incoming_p)
+    addr = plus_constant(Pmode, arg_pointer_rtx, 2 * UNITS_PER_WORD);
+  else
+    addr = plus_constant(Pmode, stack_pointer_rtx, -UNITS_PER_WORD);
+
+  rtx mem = gen_rtx_MEM(Pmode, addr);
+  MEM_NOTRAP_P(mem) = 1;
+  return mem;
+}
+
+/* Return the next register to be used to hold a function argument or
+   NULL_RTX if there's no more space.  */
+static rtx
+lobster128_function_arg(cumulative_args_t cum_v, const function_arg_info &arg)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args(cum_v);
+  if (cum->used_regs < LOBSTER128_MAX_ARG_REGNO)
+    return gen_rtx_REG(arg.mode, cum->used_regs);
+  return NULL_RTX;
+}
+
+#define LOBSTER128_FUNCTION_ARG_SIZE(MODE, TYPE) \
+  ((MODE) != BLKmode ? GET_MODE_SIZE(MODE)       \
+                     : (unsigned)int_size_in_bytes(TYPE))
+
+/* Advance the argument to the next argument position.  */
+
+static void
+lobster128_function_arg_advance(cumulative_args_t cum_v,
+                                const function_arg_info &arg)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args(cum_v);
+  gcc_assert(cum->used_regs < LOBSTER128_MAX_ARG_REGNO);
+  cum->used_regs++;
+}
+
+/* Define how to find the value returned by a function.
+   VALTYPE is the data type of the value (as a tree).
+   If the precise function being called is known, FUNC is its
+   FUNCTION_DECL; otherwise, FUNC is 0.
+
+   We always return values in register RETURN_ADDRESS for lobster128.  */
+static rtx
+lobster128_function_value(const_tree valtype,
+                          const_tree fntype_or_decl ATTRIBUTE_UNUSED,
+                          bool outgoing ATTRIBUTE_UNUSED)
+{
+  return gen_rtx_REG(TYPE_MODE(valtype), LOBSTER128_FIRST);
+}
+
+/* Handle TARGET_FUNCTION_VALUE_REGNO_P.
+   We always return values in register LOBSTER128_FIRST for lobster128.  */
+static bool
+lobster128_function_value_regno_p(const unsigned int regno)
+{
+  return (regno == LOBSTER128_FIRST);
+}
+
+/* The TARGET_OPTION_OVERRIDE worker.  */
+static void
+lobster128_option_override(void)
+{
+  /* Set the per-function-data initializer.  */
+  init_machine_status = losbter128_init_machine_status;
+}
+
+/* Compute the size of the local area and the size to be adjusted by the
+ * prologue and epilogue.  */
+
+static void
+lobster128_compute_frame(void)
+{
+  /* For aligning the local variables.  */
+  int stack_alignment = STACK_BOUNDARY / BITS_PER_UNIT;
+  /* Padding needed for each element of the frame.  */
+  cfun->machine->local_vars_size = get_frame_size();
+
+  /* Align to the stack alignment.  */
+  int padding_locals = cfun->machine->local_vars_size % stack_alignment;
+  if (padding_locals)
+    padding_locals = stack_alignment - padding_locals;
+
+  cfun->machine->local_vars_size += padding_locals;
+
+  cfun->machine->callee_saved_reg_size = 0;
+
+  /* Save callee-saved registers.  */
+  for (int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+    if (df_regs_ever_live_p(regno) && (!call_used_or_fixed_reg_p(regno)))
+      cfun->machine->callee_saved_reg_size += 16;
+
+  cfun->machine->size_for_adjusting_sp =
+      crtl->args.pretend_args_size + cfun->machine->local_vars_size + (ACCUMULATE_OUTGOING_ARGS ? (HOST_WIDE_INT)crtl->outgoing_args_size : 0);
+}
+
+/* Return the offset between two registers, one to be eliminated, and the other
+   its replacement, at the start of a routine.  */
+int lobster128_initial_elimination_offset(int from, int to)
+{
+  int ret;
+  if ((from) == FRAME_POINTER_REGNUM && (to) == HARD_FRAME_POINTER_REGNUM)
+  {
+    /* Compute this since we need to use cfun->machine->local_vars_size.  */
+    lobster128_compute_frame();
+    ret = -cfun->machine->callee_saved_reg_size;
+  }
+  else if ((from) == ARG_POINTER_REGNUM && (to) == HARD_FRAME_POINTER_REGNUM)
+    ret = 0;
+  else
+    abort();
+  return ret;
+}
+
+void lobster128_expand_prologue(void)
+{
+  lobster128_compute_frame();
+  if (flag_stack_usage_info)
+    current_function_static_stack_size = cfun->machine->size_for_adjusting_sp;
+  
+  rtx insn;
+  /* Save callee-saved registers.  */
+  for (int regno = 4; regno < FIRST_PSEUDO_REGISTER; regno++)
+  {
+    if (df_regs_ever_live_p(regno) && !call_used_or_fixed_reg_p(regno))
+    {
+      /*insn = emit_insn(gen_movti_push(stack_pointer_rtx, gen_rtx_REG(Pmode, regno)));
+      RTX_FRAME_RELATED_P(insn) = 1;*/
+    }
+  }
+
+  if (cfun->machine->size_for_adjusting_sp > 0)
+  {
+    const int max_micro_move = 0x1fff;
+    int i = cfun->machine->size_for_adjusting_sp;
+    while ((i >= max_micro_move))
+    {
+      insn = emit_insn(gen_subti3(stack_pointer_rtx,
+                                  stack_pointer_rtx,
+                                  GEN_INT(max_micro_move)));
+      RTX_FRAME_RELATED_P(insn) = 1;
+      i -= max_micro_move;
+    }
+    /* TODO: We could do better and generate a Z.PUSH / Z.POP */
+    if (i <= max_micro_move)
+    {
+      insn = emit_insn(gen_subti3(stack_pointer_rtx,
+                                  stack_pointer_rtx,
+                                  GEN_INT(i)));
+      RTX_FRAME_RELATED_P(insn) = 1;
+    }
+    else
+    {
+      rtx reg = gen_rtx_REG(Pmode, 8);
+      insn = emit_move_insn(reg, GEN_INT(i));
+      RTX_FRAME_RELATED_P(insn) = 1;
+      insn = emit_insn(gen_subti3(stack_pointer_rtx,
+                                  stack_pointer_rtx,
+                                  reg));
+      RTX_FRAME_RELATED_P(insn) = 1;
+    }
+  }
+}
+
+void lobster128_expand_epilogue(void)
+{
+  if (cfun->machine->callee_saved_reg_size != 0)
+  {
+    rtx reg = gen_rtx_REG(Pmode, 8);
+    if (cfun->machine->callee_saved_reg_size <= 255)
+    {
+      emit_move_insn(reg, hard_frame_pointer_rtx);
+      emit_insn(gen_subti3(reg, reg,
+                           GEN_INT(cfun->machine->callee_saved_reg_size)));
+    }
+    else
+    {
+      emit_move_insn(reg, GEN_INT(-cfun->machine->callee_saved_reg_size));
+      emit_insn(gen_addti3(reg, reg, hard_frame_pointer_rtx));
+    }
+    for (int regno = FIRST_PSEUDO_REGISTER; regno-- > 0;)
+      if (!call_used_or_fixed_reg_p(regno) && df_regs_ever_live_p(regno))
+      {
+        rtx preg = gen_rtx_REG(Pmode, regno);
+        emit_insn(gen_movti_pop(reg, preg));
+      }
+  }
+
+  emit_jump_insn(gen_returner());
+}
+
+/* The PRINT_OPERAND_ADDRESS worker.  */
+static void
+lobster128_print_operand_address(FILE *file, machine_mode, rtx x)
+{
+  switch (GET_CODE(x))
+  {
+  case REG:
+    fprintf(file, "(%s)", reg_names[REGNO(x)]);
+    break;
+  case MEM:
+    fprintf(file, "(%s)", reg_names[REGNO(x)]);
+    break;
+  case PLUS:
+    switch (GET_CODE(XEXP(x, 1)))
+    {
+    case CONST_INT:
+      fprintf(file, "%ld(%s)",
+              INTVAL(XEXP(x, 1)), reg_names[REGNO(XEXP(x, 0))]);
+      break;
+    case SYMBOL_REF:
+      output_addr_const(file, XEXP(x, 1));
+      fprintf(file, "(%s)", reg_names[REGNO(XEXP(x, 0))]);
+      break;
+    case CONST:
+    {
+      rtx plus = XEXP(XEXP(x, 1), 0);
+      if (GET_CODE(XEXP(plus, 0)) == SYMBOL_REF && CONST_INT_P(XEXP(plus, 1)))
+      {
+        output_addr_const(file, XEXP(plus, 0));
+        fprintf(file, "+%ld(%s)", INTVAL(XEXP(plus, 1)),
+                reg_names[REGNO(XEXP(x, 0))]);
+      }
+      else
+        abort();
+    }
+    break;
+    default:
+      abort();
+    }
+    break;
+  default:
+    output_addr_const(file, x);
+    break;
+  }
+}
+
+/* The PRINT_OPERAND worker.  */
+static void
+lobster128_print_operand(FILE *file, rtx x, int code)
+{
+  /* New code entries should just be added to the switch below.  If
+     handling is finished, just return.  If handling was just a
+     modification of the operand, the modified operand should be put in
+     "operand", and then do a break to let default handling
+     (zero-modifier) output the operand.  */
+  switch (code)
+  {
+  case 0:
+    /* No code, print as usual.  */
+    break;
+  default:
+    internal_error("invalid operand modifier letter: '%c'", code);
+  }
+
+  /* Print an operand as without a modifier letter.  */
+  long val;
+  switch (GET_CODE(x))
+  {
+  case REG:
+    if (!HARD_REGISTER_NUM_P(REGNO(x)))
+      internal_error("internal error: bad register: %d", REGNO(x));
+    fprintf(file, "%s", reg_names[REGNO(x)]);
+    break;
+  case MEM:
+    output_address(GET_MODE(XEXP(x, 0)), XEXP(x, 0));
+    break;
+  case CONST_INT:
+  case SYMBOL_REF:
+  case CONST:
+  case LABEL_REF:
+    lobster128_print_operand_address(file, VOIDmode, x);
+    break;
+  case CONST_DOUBLE:
+    REAL_VALUE_TO_TARGET_SINGLE(*CONST_DOUBLE_REAL_VALUE(x), val);
+    fprintf(file, "%ld", val);
+    break;
+  case CODE_LABEL:
+    fprintf(file, "L%d", CODE_LABEL_NUMBER(x));
+    break;
+  default:
+    /* No need to handle all strange variants, let output_addr_const
+       do it for us.  */
+    if (CONSTANT_P(x))
+    {
+      lobster128_print_operand_address(file, VOIDmode, x);
+      return;
+    }
+    internal_error("unexpected code: %d", GET_CODE(x));
+  }
+}
+
+/* Return true for memory offset addresses between -32768 and 32767.  */
+bool lobster128_offset_address_p(rtx x)
+{
+  x = XEXP(x, 0);
+  if (GET_CODE(x) == PLUS)
+  {
+    x = XEXP(x, 1);
+    if (GET_CODE(x) == CONST_INT)
+    {
+      unsigned int v = INTVAL(x) & 0xFFFF8000;
+      return (v == 0xFFFF8000 || v == 0x00000000);
+    }
+  }
+  return 0;
+}
+
+#undef TARGET_INIT_BUILTINS
+#define TARGET_INIT_BUILTINS lobster128_init_builtins
+#undef TARGET_RETURN_IN_MEMORY
+#define TARGET_RETURN_IN_MEMORY lobster128_return_in_memory
+#undef TARGET_MUST_PASS_IN_STACK
+#define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size
+#undef TARGET_PASS_BY_REFERENCE
+#define TARGET_PASS_BY_REFERENCE lobster128_pass_by_reference
+#undef TARGET_ARG_PARTIAL_BYTES
+#define TARGET_ARG_PARTIAL_BYTES lobster128_arg_partial_bytes
+#undef TARGET_FUNCTION_ARG
+#define TARGET_FUNCTION_ARG lobster128_function_arg
+#undef TARGET_FUNCTION_ARG_ADVANCE
+#define TARGET_FUNCTION_ARG_ADVANCE lobster128_function_arg_advance
+#undef TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P
+#define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P lobster128_legitimate_address_p
+#undef TARGET_FUNCTION_VALUE
+#define TARGET_FUNCTION_VALUE lobster128_function_value
+#undef TARGET_FUNCTION_VALUE_REGNO_P
+#define TARGET_FUNCTION_VALUE_REGNO_P lobster128_function_value_regno_p
+#undef TARGET_OPTION_OVERRIDE
+#define TARGET_OPTION_OVERRIDE lobster128_option_override
+#undef TARGET_STATIC_CHAIN
+#define TARGET_STATIC_CHAIN lobster128_static_chain
+#undef TARGET_PRINT_OPERAND
+#define TARGET_PRINT_OPERAND lobster128_print_operand
+#undef TARGET_PRINT_OPERAND_ADDRESS
+#define TARGET_PRINT_OPERAND_ADDRESS lobster128_print_operand_address
+#undef TARGET_LRA_P
+#define TARGET_LRA_P hook_bool_void_false
+#undef TARGET_PROMOTE_PROTOTYPES
+#define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_true
+#undef TARGET_FRAME_POINTER_REQUIRED
+#define TARGET_FRAME_POINTER_REQUIRED hook_bool_void_true
+#undef TARGET_SETUP_INCOMING_VARARGS
+#define TARGET_SETUP_INCOMING_VARARGS lobster128_setup_incoming_varargs
+#undef TARGET_TRAMPOLINE_INIT
+#define TARGET_TRAMPOLINE_INIT lobster128_trampoline_init
+
+struct gcc_target targetm = TARGET_INITIALIZER;
+
+#include "gt-lobster128.h"
diff --git a/gcc/config/lobster128/lobster128.h b/gcc/config/lobster128/lobster128.h
new file mode 100644
index 00000000000..8cfaf3828f4
--- /dev/null
+++ b/gcc/config/lobster128/lobster128.h
@@ -0,0 +1,485 @@
+/* Definitions of target machine for GNU compiler.  
+   lobster128 processors
+   Copyright (C) 2003-2022 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Driver configuration.  */
+
+/* A generic LIB_SPEC with -leval and --*group tacked on.  */
+#undef  LIB_SPEC
+#define LIB_SPEC "%{!shared:%{!symbolic:--start-group -lc -leval -lgcc --end-group}}"
+
+#undef STARTFILE_SPEC
+#undef ENDFILE_SPEC
+
+#undef  LINK_SPEC
+#define LINK_SPEC "%{h*} %{v:-V} \
+		   %{static:-Bstatic} %{shared:-shared} %{symbolic:-Bsymbolic}"
+
+
+/* Run-time target specifications.  */
+
+#define TARGET_CPU_CPP_BUILTINS()               \
+  do                                            \
+    {                                           \
+      builtin_define ("__lobster128__"); 		\
+      builtin_assert ("cpu=lobster128"); 		\
+      builtin_assert ("machine=lobster128");	\
+      builtin_define("__SIZEOF_FLOAT80__=16");\
+	   builtin_define("__SIZEOF_FLOAT128__=16");\
+    }                                           \
+  while (0)
+
+/* Allow pairs of registers to be used, which is the intent of the default.  */
+#define MAX_FIXED_MODE_SIZE GET_MODE_BITSIZE (TImode)
+
+/*
+ Lobster128 ABI convention dictates the first 8 registers
+ are used for special purpouses, hardware only enforces the
+ first 7 registers on instructions.
+
+ The rest of registers can be, and are used as GPs,
+ while the first 16 registers are call saved & the rest
+ become call clobbered.
+*/
+#define LOBSTER128_ZERO 0
+#define LOBSTER128_PC 1
+#define LOBSTER128_SP 2
+#define LOBSTER128_FP 3
+/* Max. register number allowed for arguments */
+#define LOBSTER128_MAX_ARG_REGNO 7
+#define LOBSTER128_FIRST 4
+#define LOBSTER128_LAST 127
+#define LOBSTER128_CC 128
+
+/* Layout of Source Language Data Types.  */
+
+#define SHORT_TYPE_SIZE 16
+
+#define INT_TYPE_SIZE 32
+
+#define LONG_TYPE_SIZE 64
+
+#define LONG_LONG_TYPE_SIZE 128
+
+#define FLOAT_TYPE_SIZE 32
+
+#define DOUBLE_TYPE_SIZE 64
+
+#define LONG_DOUBLE_TYPE_SIZE	128
+
+#define DEFAULT_SIGNED_CHAR 1
+
+/* TODO: 128-bit UNITS_PER_WORD */
+
+/* Number of storage units in a word; normally the size of a
+   general-purpose register, a power of two from 1 or 8.  */
+#define UNITS_PER_WORD 8
+
+#define POINTER_SIZE 16
+
+/* Define this macro to the minimum alignment enforced by hardware
+   for the stack pointer on this machine.  The definition is a C
+   expression for the desired alignment (measured in bits).  */
+#define STACK_BOUNDARY 8
+
+/* Normal alignment required for function parameters on the stack, in
+   bits.  All stack parameters receive at least this much alignment
+   regardless of data type.  */
+#define PARM_BOUNDARY 8
+
+/* No data type wants to be aligned rounder than this.  */
+#define BIGGEST_ALIGNMENT 128
+
+/* The best alignment to use in cases where we have a choice.  */
+#define FASTEST_ALIGNMENT 64
+
+/* Set this nonzero if move instructions will actually fail to work
+   when given unaligned data.  */
+#define STRICT_ALIGNMENT 0
+
+/* Storage Layout */
+
+#define BITS_BIG_ENDIAN 0
+#define BYTES_BIG_ENDIAN 0
+#define WORDS_BIG_ENDIAN 0
+
+/* Alignment required for a function entry point, in bits.  */
+#define FUNCTION_BOUNDARY 8
+
+/* Define this macro as a C expression which is nonzero if accessing
+   less than a word of memory (i.e. a `char' or a `short') is no
+   faster than accessing a word of memory.  */
+#define SLOW_BYTE_ACCESS 1
+
+/* Register Basics.  */
+
+/* Number of hardware registers known to the compiler..
+   We have 128 registers to choose from, plus the CC register  */
+#define FIRST_PSEUDO_REGISTER (128 + 1)
+
+#define FIXED_REGISTERS							\
+{									\
+  1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,			\
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,			\
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     \
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     \
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     \
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     \
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     \
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     \
+  1, \
+}
+
+#define CALL_USED_REGISTERS						\
+{									\
+  1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,			\
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,			\
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     \
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     \
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     \
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     \
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     \
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     \
+  1, \
+}
+
+
+/* Order of allocation of registers.  */
+
+#define REG_ALLOC_ORDER							\
+{ \
+  /* Hardware tied registers */ \
+  0,  1,  2,  3,  4, \
+  /* Call-arguments */ \
+  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,	\
+  /* Call-saved/clobered */ \
+  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,	\
+  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,	\
+  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,	\
+  64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,	\
+  80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,	\
+  96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111,	\
+ 112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,	\
+  /* Virtual registers */ \
+  128 \
+}
+
+/* We can't copy to or from our CC register. */
+#define AVOID_CCMODE_COPIES 1
+
+/* Register Classes.  */
+enum reg_class
+{
+  NO_REGS,			/* No registers in set.  */
+  ZERO_REGS,    /* Register used for 0 */
+  PC_REGS,      /* Program Counter register */
+  CC_REGS,        /* Condition registers. */
+  GR_REGS,			/* Integer registers.  */
+  ALL_REGS,			/* All registers.  */
+  LIM_REG_CLASSES		/* Max value + 1.  */
+};
+
+#define REG_CLASS_CONTENTS \
+{ { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00  }, /* Empty */			   \
+  { 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00  }, /* ZERO */ \
+  { 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00  }, /* PC */ \
+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01 }, /* CC */                        \
+  { 0xFFFFFFFC, 0xFFFFFFFF, 0xFFFFFFFF, 0x7FFFFFFF, 0x00 }, /* GR */              \
+  { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00 }  /* All registers */              \
+}
+
+#define GENERAL_REGS GR_REGS
+
+#define N_REG_CLASSES (int) LIM_REG_CLASSES
+
+#define REG_CLASS_NAMES    \
+{                          \
+  "NO_REGS",               \
+  "ZERO_REGS",             \
+  "PC_REGS",               \
+  "CC_REGS",               \
+  "GR_REGS",               \
+  "ALL_REGS"               \
+}
+
+#define REGNO_REG_CLASS(R) \
+  ((R == LOBSTER128_ZERO) ? ZERO_REGS \
+  : (R == LOBSTER128_PC) ? PC_REGS \
+  : (R == LOBSTER128_CC) ? CC_REGS \
+  : GR_REGS)
+
+
+/* The Overall Framework of an Assembler File */
+
+#define FILE_ASM_OP     "\t.file\n"
+
+/* Switch to the text or data segment.  */
+#define TEXT_SECTION_ASM_OP  "\t.text"
+#define DATA_SECTION_ASM_OP  "\t.data"
+
+/* Assembler Commands for Alignment */
+
+#define ASM_OUTPUT_ALIGN(STREAM,POWER) \
+	fprintf (STREAM, "\t.p2align\t%d\n", POWER);
+
+/* A macro whose definition is the name of the class to which a
+   valid base register must belong.  A base register is one used in
+   an address which is the register value plus a displacement.  */
+#define BASE_REG_CLASS GR_REGS
+
+/* A macro whose definition is the name of the class to which a
+   valid index register must belong.  An index register is one used
+   in an address where its value is either multiplied by a scale
+   factor or added to another register (as well as added to a
+   displacement).  */
+#define INDEX_REG_CLASS NO_REGS
+
+/* Basic Stack Layout.  */
+/* Define this macro if pushing a word onto the stack moves the stack
+   pointer to a smaller address.  */
+#define STACK_GROWS_DOWNWARD 1
+
+/* Define this macro to nonzero value if the addresses of local variable slots
+   are at negative offsets from the frame pointer.  */
+#define FRAME_GROWS_DOWNWARD 1
+
+/* Offset from the argument pointer register to the first argument's
+   address.  On some machines it may depend on the data type of the
+   function.  */
+#define FIRST_PARM_OFFSET(F) 12
+
+/* A C expression whose value is RTL representing the location of the
+   incoming return address at the beginning of any function, before
+   the prologue.  */
+#define INCOMING_RETURN_ADDR_RTX					\
+  gen_frame_mem (Pmode,							\
+		 plus_constant (Pmode, stack_pointer_rtx, UNITS_PER_WORD))
+
+/* Describe how we implement __builtin_eh_return.  */
+#define EH_RETURN_DATA_REGNO(N)	((N) < 4 ? (N+2) : INVALID_REGNUM)
+
+/* Store the return handler into the call frame.  */
+#define EH_RETURN_HANDLER_RTX						\
+  gen_frame_mem (Pmode,							\
+		 plus_constant (Pmode, frame_pointer_rtx, UNITS_PER_WORD))
+
+/* The register number of the stack pointer register, which must also
+   be a fixed register according to `FIXED_REGISTERS'.  */
+#define STACK_POINTER_REGNUM LOBSTER128_SP
+
+/* The register number of the frame pointer register, which is used to
+   access automatic variables in the stack frame.  */
+#define FRAME_POINTER_REGNUM LOBSTER128_FP
+
+#define HARD_FRAME_POINTER_REGNUM LOBSTER128_FP
+
+/* The register number of the arg pointer register, which is used to
+   access the function's argument list.  */
+#define ARG_POINTER_REGNUM LOBSTER128_FP
+
+#define RETURN_ADDRESS_POINTER_REGNUM LOBSTER128_FIRST
+
+#define ELIMINABLE_REGS							\
+{{ FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM }, \
+ { ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM }}			
+
+/* Passing Function Arguments on the Stack.  */
+
+/* If defined, the maximum amount of space required for outgoing arguments
+   will be computed and placed into the variable
+   `current_function_outgoing_args_size'.  No space will be pushed
+   onto the stack for each call; instead, the function prologue should
+   increase the stack frame size by this amount.  */
+#define ACCUMULATE_OUTGOING_ARGS 1
+
+/* Define this macro if pushing a word onto the stack moves the stack
+   pointer to a smaller address.  */
+#define STACK_GROWS_DOWNWARD 1
+
+/* Define this if the above stack space is to be considered part of the
+   space allocated by the caller.  */
+#define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) 1
+#define STACK_PARMS_IN_REG_PARM_AREA
+
+/* Offset from the argument pointer register to the first argument's
+   address.  On some machines it may depend on the data type of the
+   function.  */
+#define FIRST_PARM_OFFSET(F) 12
+
+/* Define this macro to nonzero value if the addresses of local variable slots
+   are at negative offsets from the frame pointer.  */
+#define FRAME_GROWS_DOWNWARD 1
+
+/* Define this macro as a C expression that is nonzero for registers that are
+   used by the epilogue or the return pattern.  The stack and frame
+   pointer registers are already assumed to be used as needed.  */
+#define EPILOGUE_USES(R) (R == 17)
+
+/* Function Arguments in Registers.  */
+#define MAX_ARGS_IN_REGISTERS 4
+
+typedef struct _lobster128_cumulative_args_t {
+   /* Number of used registers from R2-R8 */
+   int used_regs;
+} lobster128_cumulative_args_t;
+
+/* A C type for declaring a variable that is used as the first
+   argument of `FUNCTION_ARG' and other related values.  */
+#define CUMULATIVE_ARGS lobster128_cumulative_args_t
+
+/* If defined, the maximum amount of space required for outgoing arguments
+   will be computed and placed into the variable
+   `current_function_outgoing_args_size'.  No space will be pushed
+   onto the stack for each call; instead, the function prologue should
+   increase the stack frame size by this amount.  */
+#define ACCUMULATE_OUTGOING_ARGS 1
+
+/* A C statement (sans semicolon) for initializing the variable CUM
+   for the state at the beginning of the argument list.  
+   For Lobster128, the first arg is passed in register determined by ARG.  */
+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,FNDECL,N_NAMED_ARGS) \
+  ((CUM).used_regs = 4)
+
+#define FUNCTION_ARG_REGNO_P(N)						\
+  (((N) >= LOBSTER128_FIRST && (N) <= LOBSTER128_LAST))
+
+/* Trampolines for Nested Functions.  */
+#define TRAMPOLINE_SIZE (2 + 6 + 4 + 2 + 6)
+
+/* Alignment required for trampolines, in bits.  */
+#define TRAMPOLINE_ALIGNMENT 32
+
+/* Addressing Modes.  */
+
+#define MAX_REGS_PER_ADDRESS 1
+
+/* Define this macro as a C expression which is nonzero if accessing
+   less than a word of memory (i.e. a `char' or a `short') is no
+   faster than accessing a word of memory.  */
+#define SLOW_BYTE_ACCESS 1
+
+/* Dividing the output into sections.  */
+
+#define TEXT_SECTION_ASM_OP	"\t.text"	/* Instructions.  */
+
+#define DATA_SECTION_ASM_OP	"\t.data"	/* Large data.  */
+
+/* The Overall Framework of an Assembler File.  */
+
+#define ASM_COMMENT_START " #"
+
+#define ASM_APP_ON "#APP\n"
+
+#define ASM_APP_OFF "#NO_APP\n"
+
+
+/* Output and Generation of Labels.  */
+
+#undef ASM_GENERATE_INTERNAL_LABEL
+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)			\
+  sprintf ((LABEL), "*%s%s%ld", (LOCAL_LABEL_PREFIX), (PREFIX), (long) (NUM))
+
+#define GLOBAL_ASM_OP "\t.globl\t"
+
+
+/* Output of Assembler Instructions.  */
+
+#define REGISTER_NAMES							\
+{									\
+ "zero", "pc",   "sp",   "fp",   "r4",   "r5",   "r6",   "r7",   \
+ "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",  \
+ "r16",  "r17",  "r18",  "r19",  "r20",  "r21",  "r22",  "r23",  \
+ "r24",  "r25",  "r26",  "r27",  "r28",  "r29",  "r30",  "r31",  \
+ "r32",  "r34",  "r35",  "r36",  "r37",  "r38",  "r39",  "r40",  \
+ "r41",  "r42",  "r43",  "r44",  "r45",  "r46",  "r47",  "r48",  \
+ "r49",  "r50",  "r51",  "r52",  "r53",  "r54",  "r55",  "r56",  \
+ "r57",  "r58",  "r59",  "r60",  "r61",  "r62",  "r63",  "r64",  \
+ "r65",  "r66",  "r67",  "r68",  "r69",  "r70",  "r71",  "r72",  \
+ "r73",  "r74",  "r75",  "r76",  "r77",  "r78",  "r79",  "r80",  \
+ "r81",  "r82",  "r83",  "r84",  "r85",  "r86",  "r87",  "r88",  \
+ "r89",  "r90",  "r91",  "r92",  "r93",  "r94",  "r95",  "r96",  \
+ "r97",  "r98",  "r99",  "r100", "r101", "r102", "r103", "r104", \
+ "r105", "r106", "r107", "r108", "r109", "r110", "r111", "r112", \
+ "r113", "r114", "r115", "r116", "r117", "r118", "r119", "r120", \
+ "r121", "r122", "r123", "r124", "r125", "r126", "r127", "r128", \
+ "cc", \
+}
+
+#define LOCAL_LABEL_PREFIX	"$"
+
+#define USER_LABEL_PREFIX	""
+
+/* All load operations zero extend.  */
+#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND
+
+/* Specify the machine mode that pointers have.
+   After generation of rtl, the compiler makes no further distinction
+   between pointers and any other objects of this machine mode.  */
+#define Pmode TImode
+
+/* An alias for the machine mode used for memory references to
+   functions being called, in `call' RTL expressions.  */
+#define FUNCTION_MODE TImode
+
+/* Maximum number of registers that can appear in a valid memory
+   address.  */
+#define MAX_REGS_PER_ADDRESS 1
+
+#define HARD_REGNO_OK_FOR_BASE_P(NUM) \
+  (HARD_REGISTER_NUM_P(NUM) && (REGNO_REG_CLASS(NUM) == GENERAL_REGS \
+       || (NUM) == HARD_FRAME_POINTER_REGNUM))
+
+/* A C expression which is nonzero if register number NUM is suitable
+   for use as a base register in operand addresses.  */
+#ifdef REG_OK_STRICT
+#define REGNO_OK_FOR_BASE_P(NUM)		 \
+  (HARD_REGNO_OK_FOR_BASE_P(NUM) 		 \
+   || HARD_REGNO_OK_FOR_BASE_P(reg_renumber[(NUM)]))
+#else
+#define REGNO_OK_FOR_BASE_P(NUM)		 \
+  ((NUM) >= FIRST_PSEUDO_REGISTER || HARD_REGNO_OK_FOR_BASE_P(NUM))
+#endif
+
+/* A C expression which is nonzero if register number NUM is suitable
+   for use as an index register in operand addresses.  */
+#define REGNO_OK_FOR_INDEX_P(NUM) LOBSTER128_FP
+
+/* An alias for a machine mode name.  This is the machine mode that
+   elements of a jump-table should have.  */
+#define CASE_VECTOR_MODE TImode
+
+/* A C expression whose value is zero if pointers that need to be extended
+   from being `POINTER_SIZE' bits wide to `Pmode' are sign-extended and
+   greater then zero if they are zero-extended and less then zero if the
+   ptr_extend instruction should be used.  */
+#define POINTERS_EXTEND_UNSIGNED 0
+
+/* Generating Code for Profiling */
+#define FUNCTION_PROFILER(FILE,LABELNO) (abort (), 0)
+
+/* The maximum number of bytes that a single instruction can move quickly from
+   memory to memory.  */
+#define MOVE_MAX 65535
+
+/* This macro returns the initial difference between the specified pair
+   of registers.  */
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)			\
+  do {									\
+    (OFFSET) = lobster128_initial_elimination_offset ((FROM), (TO));		\
+  } while (0)
diff --git a/gcc/config/lobster128/lobster128.md b/gcc/config/lobster128/lobster128.md
new file mode 100644
index 00000000000..c7d21d454e2
--- /dev/null
+++ b/gcc/config/lobster128/lobster128.md
@@ -0,0 +1,372 @@
+;;  lobster128.md	     Machine Description for lobster128 processors
+;;  Copyright (C) 2003-2022 Free Software Foundation, Inc.
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+(include "constraints.md")
+(include "predicates.md")
+
+(define_constants
+  [(ZERO_REG 0)
+   (PC_REG 1)
+   (SP_REG 2)
+   (FP_REG 3)
+   (CC_REG 128)])
+
+; All instructions are 8 bytes long
+(define_attr "length" "" (const_int 8))
+
+; Lenght of operands
+(define_mode_iterator MODE [QI HI SI DI TI])
+(define_mode_attr lenx [(QI ".b") (HI ".s") (SI ".i") (DI ".d") (TI ".q")])
+(define_mode_iterator FMODE [SF DF TF])
+(define_mode_attr flenx [(SF ".i") (DF ".fd") (TF ".fq")])
+
+; Handle both unsigned and signed arithmethics
+(define_code_iterator EXTEND [sign_extend zero_extend])
+(define_code_attr u [(sign_extend "") (zero_extend "u")])
+(define_code_attr sgnprefix [(sign_extend "i.") (zero_extend "z.")])
+
+; Instruction sizes, micro is 16-bits, mini is 32-bits, long is 64-bits and macro is TBD
+(define_attr "type" "micro,mini,long,macro" (const_string "mini"))
+
+;; -------------------------------------------------------------------------
+;; nop instruction
+;; -------------------------------------------------------------------------
+(define_insn "nop"
+  [(const_int 0)]
+  ""
+  "z.nop")
+
+;; -------------------------------------------------------------------------
+;; Micro-arithmethic instruction ops
+;; -------------------------------------------------------------------------
+(define_insn "addti3"
+  [(set (match_operand:TI 0 "lobster128_ureg_operand" "=r,r,r")
+    (plus:TI
+      (match_operand:TI 1 "lobster128_ureg_operand" "0,0,0")
+      (match_operand:TI 2 "lobster128_ureg_operand" "r,i,m")))]
+  ""
+  "u.addr %0,%2"
+  [(set_attr "type" "micro")])
+
+(define_insn "subti3"
+  [(set (match_operand:TI 0 "lobster128_ureg_operand" "=r,r,r")
+    (minus:TI
+      (match_operand:TI 1 "lobster128_ureg_operand" "0,0,0")
+      (match_operand:TI 2 "lobster128_ureg_operand" "r,i,m")))]
+  ""
+  "u.addr %0,%2"
+  [(set_attr "type" "micro")])
+
+(define_insn "multi3"
+  [(set (match_operand:TI 0 "lobster128_ureg_operand" "=r,r,r")
+    (mult:TI
+      (match_operand:TI 1 "lobster128_ureg_operand" "0,0,0")
+      (match_operand:TI 2 "lobster128_ureg_operand" "r,i,m")))]
+  ""
+  "u.addr %0,%2"
+  [(set_attr "type" "micro")])
+
+(define_insn "divti3"
+  [(set (match_operand:TI 0 "lobster128_ureg_operand" "=r")
+    (div:TI
+      (match_operand:TI 1 "lobster128_ureg_operand" "0")
+      (match_operand:TI 2 "lobster128_ureg_operand" "r")))]
+  ""
+  "u.divr %0,%2"
+  [(set_attr "type" "micro")])
+
+(define_insn "iorti3"
+  [(set (match_operand:TI 0 "lobster128_ureg_operand" "=r")
+    (ior:TI
+      (match_operand:TI 1 "lobster128_ureg_operand" "0")
+      (match_operand:TI 2 "lobster128_ureg_operand" "r")))]
+  ""
+  "u.orr %0,%2"
+  [(set_attr "type" "micro")])
+
+(define_insn "xorti3"
+  [(set (match_operand:TI 0 "lobster128_ureg_operand" "=r")
+    (xor:TI
+      (match_operand:TI 1 "lobster128_ureg_operand" "0")
+      (match_operand:TI 2 "lobster128_ureg_operand" "r")))]
+  ""
+  "u.xorr %0,%2"
+  [(set_attr "type" "micro")])
+
+(define_insn "movti2"
+  [(set (match_operand:TI 0 "lobster128_ureg_operand" "=r")
+    (match_operand:TI 1 "lobster128_ureg_operand" "r"))]
+  ""
+  "u.setr %0,%1"
+  [(set_attr "type" "micro")])
+
+;; -------------------------------------------------------------------------
+;; Move instructions
+;; -------------------------------------------------------------------------
+;; Push a register onto the stack
+(define_insn "mov<mode>_push"
+  [(set (mem:MODE (minus:MODE
+      (match_operand:MODE 0 "lobster128_general_movsrc_operand" "=r,r,r")
+      (const_int 16)))
+    (match_operand:MODE 1 "lobster128_mreg_operand" "r,i,m"))]
+  ""
+  "@
+  m.pushr<lenx> %0,%1
+  m.pushi<lenx> %0,%1
+  m.pushm<lenx> %0,%1"
+  [(set_attr "type" "mini")])
+
+;; Pop a register from the stack
+(define_insn "mov<mode>_pop"
+  [(set (match_operand:MODE 0 "lobster128_mreg_operand" "=r,r,r")
+    (mem:MODE (plus:MODE
+      (match_operand:MODE 1 "lobster128_general_movsrc_operand" "r,i,m")
+      (const_int 16))))]
+  ""
+  "@
+  m.popr<lenx> %0,%1
+  m.popi<lenx> %0,%1
+  m.popm<lenx> %0,%1"
+  [(set_attr "type" "mini")])
+
+(define_expand "mov<mode>"
+  [(set (match_operand:MODE 0 "general_operand" "")
+	      (match_operand:MODE 1 "general_operand" ""))]
+  ""
+  "
+{
+  if(<MODE>mode == TImode)
+  {
+    /* If this is a store, force the value into a register.  */
+    if ( (reload_in_progress || reload_completed))
+    {
+      if (MEM_P (operands[0]))
+      {
+        operands[1] = force_reg (<MODE>mode, operands[1]);
+        if (MEM_P (XEXP (operands[0], 0)))
+          operands[0] = gen_rtx_MEM (<MODE>mode, force_reg (<MODE>mode, XEXP (operands[0], 0)));
+      }
+      else 
+        if (MEM_P (operands[1])
+            && MEM_P (XEXP (operands[1], 0)))
+          operands[1] = gen_rtx_MEM (<MODE>mode, force_reg (<MODE>mode, XEXP (operands[1], 0)));
+    }
+  }
+  else
+  {
+    /* If this is a store, force the value into a register.  */
+    if (MEM_P (operands[0]))
+      operands[1] = force_reg (<MODE>mode, operands[1]);
+  }
+}")
+
+(define_insn "*mov<mode>"
+  [(set (match_operand:MODE 0 "lobster128_mreg_operand" "=r,r,r,r,W,r,m,r")
+	(match_operand:MODE 1 "lobster128_general_movsrc_operand" "O,r,M,i,r,W,r,m"))]
+  "register_operand (operands[0], <MODE>mode)
+    || register_operand (operands[1], <MODE>mode)"
+  "*
+{
+  return \"m.set<lenx> %0,%1\";
+}"
+  [(set_attr "type" "mini")])
+
+(define_insn "movstr<mode>"
+  [(set (reg:MODE 0) (const_int 0))
+  (parallel [(set (match_operand:MODE 0 "nonimmediate_operand" "=m,m")
+    (match_operand:MODE 1 "lobster128_general_movsrc_operand" "m,m"))
+    (match_operand:MODE 2 "lobster128_arith_operand" "i,r")
+    (clobber (reg:CC CC_REG))])]
+  ""
+  "l.set<lenx> %0,%1,%2"
+  [(set_attr "type" "mini")])
+
+(define_insn "zero_extend<mode>ti2"
+  [(set (match_operand:TI 0 "register_operand" "=r")
+	  (zero_extend:TI (match_operand:MODE 1 "nonimmediate_operand" "")))]
+  ""
+  "m.extr<lenx> %0,%1"
+  [(set_attr "type" "mini")])
+
+(define_insn "sign_extend<mode>ti2"
+  [(set (match_operand:TI 0 "register_operand" "=r")
+	  (sign_extend:TI (match_operand:MODE 1 "nonimmediate_operand" "")))]
+  ""
+  "m.sexr<lenx> %0,%1"
+  [(set_attr "type" "mini")])
+
+(define_insn "ptr_extend<mode>"
+  [(set (match_operand:TI 0 "register_operand" "=r")
+	  (zero_extend:TI (match_operand:MODE 1 "register_operand" "r")))]
+  ""
+  "m.setr<lenx> %0,%1"
+  [(set_attr "type" "mini")])
+
+;; -------------------------------------------------------------------------
+;; Compare instructions
+;; -------------------------------------------------------------------------
+(define_insn "cmp<mode>"
+  [(set (reg:CC CC_REG) (compare:CC
+	 (match_operand:MODE 0 "register_operand" "r")
+	 (match_operand:MODE 1 "lobster128_arith_operand" "")))]
+  ""
+  "z.cmp<lenx> %0,%1")
+
+;; -------------------------------------------------------------------------
+;; Branch instructions
+;; -------------------------------------------------------------------------
+
+(define_code_iterator cond [ne eq lt ltu gt gtu ge le geu leu])
+(define_code_attr rCC [(ne "ne") (eq "eq") (lt "lt") (ltu "ltu") 
+		       (gt "gt") (gtu "gtu") (ge "ge") (le "le") 
+		       (geu "geu") (leu "leu")])
+
+(define_expand "cbranch<mode>4"
+  [(set (reg:CC CC_REG)
+    (compare:CC
+      (match_operand:MODE 1 "general_operand" "")
+      (match_operand:MODE 2 "general_operand" "")))
+    (set (pc)
+      (if_then_else (match_operator 0 "comparison_operator"
+        [(reg:CC CC_REG) (const_int 0)])
+          (label_ref (match_operand 3 "" ""))
+          (pc)))]
+  ""
+  "
+{
+  /* Force the compare operands into registers.  */
+  if (GET_CODE (operands[1]) != REG)
+	  operands[1] = force_reg (<MODE>mode, operands[1]);
+  if (GET_CODE (operands[2]) != REG)
+	  operands[2] = force_reg (<MODE>mode, operands[2]);
+}")
+
+(define_insn "*cmp<mode>"
+  [(set (reg:CC CC_REG) (compare:CC
+	 (match_operand:MODE 0 "register_operand" "r")
+	 (match_operand:MODE 1 "register_operand"	"r")))]
+  ""
+  "z.cmp<lenx> %0, %1")
+
+(define_insn "*b<cond:code>"
+  [(set (pc)
+	(if_then_else (cond (reg:CC CC_REG)
+			    (const_int 0))
+          (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  "z.b<rCC> %0")
+
+(define_insn "*b<cond:code>"
+  [(set (pc)
+	(if_then_else (cond (reg:CC CC_REG)
+			    (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "z.b<rCC> %0")
+
+;; -------------------------------------------------------------------------
+;; Call and Jump instructions
+;; -------------------------------------------------------------------------
+
+(define_expand "call"
+  [(call (match_operand:TI 0 "memory_operand" "")
+		(match_operand 1 "general_operand" ""))]
+  ""
+{
+  gcc_assert (MEM_P (operands[0]));
+})
+
+(define_insn "*call"
+  [(call (mem:TI (match_operand:TI 0 "nonmemory_operand" "i,r"))
+	 (match_operand 1 "" ""))]
+  ""
+  "z.call %1")
+
+(define_expand "call_value"
+  [(set (match_operand 0 "" "")
+		(call (match_operand:TI 1 "memory_operand" "")
+		 (match_operand 2 "" "")))]
+  ""
+{
+  gcc_assert (MEM_P (operands[1]));
+})
+
+(define_insn "*call_value"
+  [(set (match_operand 0 "register_operand" "=r")
+	(call (mem:TI (match_operand:TI 1 "immediate_operand" "i"))
+	      (match_operand 2 "" "")))]
+  ""
+  "z.call %1")
+
+(define_insn "*call_value_indirect"
+  [(set (match_operand 0 "register_operand" "=r")
+	(call (mem:TI (match_operand:TI 1 "register_operand" "r"))
+	      (match_operand 2 "" "")))]
+  ""
+  "z.call %1")
+
+(define_insn "indirect_jump"
+  [(set (pc) (match_operand:TI 0 "nonimmediate_operand" "r"))]
+  ""
+  "z.jr %0")
+
+(define_insn "jump"
+  [(set (pc)
+	(label_ref (match_operand 0 "" "")))]
+  ""
+  "z.j %0")
+
+;; -------------------------------------------------------------------------
+;; Floating point instructions
+;; -------------------------------------------------------------------------
+(define_insn "sqrt<mode>"
+  [(set (match_operand:FMODE 0 "register_operand" "=f")
+    (sqrt:FMODE (match_operand:FMODE 1 "register_operand" "f")) )]
+  ""
+  "z.sqrt<flenx> %0,%1")
+
+;; -------------------------------------------------------------------------
+;; Prologue & Epilogue
+;; -------------------------------------------------------------------------
+(define_expand "prologue"
+  [(clobber (const_int 0))]
+  ""
+  "
+{
+  lobster128_expand_prologue ();
+  DONE;
+}
+")
+
+(define_expand "epilogue"
+  [(return)]
+  ""
+  "
+{
+  lobster128_expand_epilogue ();
+  DONE;  
+}
+")
+
+(define_insn "returner"
+  [(return)]
+  "reload_completed"
+  "z.ret.owo")
diff --git a/gcc/config/lobster128/lobster128.opt b/gcc/config/lobster128/lobster128.opt
new file mode 100644
index 00000000000..6aa28006001
--- /dev/null
+++ b/gcc/config/lobster128/lobster128.opt
@@ -0,0 +1,19 @@
+; Options for the lobster128 port of the compiler.
+
+; Copyright (C) 2005-2022 Free Software Foundation, Inc.
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify it under
+; the terms of the GNU General Public License as published by the Free
+; Software Foundation; either version 3, or (at your option) any later
+; version.
+;
+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+; WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+; for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING3.  If not see
+; <http://www.gnu.org/licenses/>.
diff --git a/gcc/config/lobster128/predicates.md b/gcc/config/lobster128/predicates.md
new file mode 100644
index 00000000000..dbd368a9479
--- /dev/null
+++ b/gcc/config/lobster128/predicates.md
@@ -0,0 +1,55 @@
+;; Predicate definitions for LOBSTER128.
+;; Copyright (C) 2005-2022 Free Software Foundation, Inc.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+(define_predicate "lobster128_general_movsrc_operand"
+  (match_code "mem,const_int,reg,subreg,symbol_ref,label_ref,const")
+  "{
+    return general_operand (op, mode);
+}");
+
+;; Micro register number (0 to 31)
+(define_predicate "lobster128_ureg_operand"
+  (match_operand 0 "register_operand")
+{
+  if (GET_CODE (op) == SUBREG)
+    op = SUBREG_REG (op);
+  int regno = REGNO (op);
+  return (regno < 0x20 || regno >= FIRST_PSEUDO_REGISTER);
+})
+
+;; Mini register number (0 to 64)
+(define_predicate "lobster128_mreg_operand"
+  (match_operand 0 "register_operand")
+{
+  if (GET_CODE (op) == SUBREG)
+    op = SUBREG_REG (op);
+  int regno = REGNO (op);
+  return (regno < 0x40 || regno >= FIRST_PSEUDO_REGISTER);
+})
+
+(define_predicate "lobster128_arith_operand"
+  (match_operand 0 "nonimmediate_operand")
+{
+  if (GET_CODE (op) == MEM)
+    return true;
+  if (GET_CODE (op) == SUBREG)
+    op = SUBREG_REG (op);
+  int regno = REGNO (op);
+  return (regno < 0x40 || regno >= FIRST_PSEUDO_REGISTER);
+})
diff --git a/gcc/lra-int.h b/gcc/lra-int.h
index 04baefef348..710c9483226 100644
--- a/gcc/lra-int.h
+++ b/gcc/lra-int.h
@@ -26,7 +26,7 @@ along with GCC; see the file COPYING3.	If not see
 /* The parameter used to prevent infinite reloading for an insn.  Each
    insn operands might require a reload and, if it is a memory, its
    base and index registers might require a reload too.	 */
-#define LRA_MAX_INSN_RELOADS (MAX_RECOG_OPERANDS * 3)
+#define LRA_MAX_INSN_RELOADS (MAX_RECOG_OPERANDS * 5)
 
 typedef struct lra_live_range *lra_live_range_t;
 
diff --git a/libgcc/config.host b/libgcc/config.host
index 9a28b10ac7f..41f984fdee2 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -136,6 +136,9 @@ hppa*-*-*)
 lm32*-*-*)
 	cpu_type=lm32
 	;;
+lobster128*)
+	cpu_type=lobster128
+	;;
 loongarch*-*-*)
 	cpu_type=loongarch
 	tmake_file="loongarch/t-loongarch"
diff --git a/libgcc/config/lobster128/crti.S b/libgcc/config/lobster128/crti.S
new file mode 100644
index 00000000000..063d2025a33
--- /dev/null
+++ b/libgcc/config/lobster128/crti.S
@@ -0,0 +1,40 @@
+# crti.S for lobster128
+#
+#   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+# 
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the
+# Free Software Foundation; either version 3, or (at your option) any
+# later version.
+# 
+# This file is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+# 
+# Under Section 7 of GPL version 3, you are granted additional
+# permissions described in the GCC Runtime Library Exception, version
+# 3.1, as published by the Free Software Foundation.
+#
+# You should have received a copy of the GNU General Public License and
+# a copy of the GCC Runtime Library Exception along with this program;
+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+# <http://www.gnu.org/licenses/>.
+
+# This file just make a stack frame for the contents of the .fini and
+# .init sections.  Users may put any desired instructions in those
+# sections.
+
+	.file		"crti.S"
+
+	.section	".init"
+	.global	_init
+	.type	_init, @function	
+	.p2align	1
+_init:
+
+	.section	".fini"
+	.global	_fini
+	.type	_fini,@function
+	.p2align	1
+_fini:
diff --git a/libgcc/config/lobster128/crtn.S b/libgcc/config/lobster128/crtn.S
new file mode 100644
index 00000000000..65858d947e3
--- /dev/null
+++ b/libgcc/config/lobster128/crtn.S
@@ -0,0 +1,34 @@
+# crtn.S for lobster128
+# 
+#   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+# 
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the
+# Free Software Foundation; either version 3, or (at your option) any
+# later version.
+# 
+# This file is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+# 
+# Under Section 7 of GPL version 3, you are granted additional
+# permissions described in the GCC Runtime Library Exception, version
+# 3.1, as published by the Free Software Foundation.
+#
+# You should have received a copy of the GNU General Public License and
+# a copy of the GCC Runtime Library Exception along with this program;
+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+# <http://www.gnu.org/licenses/>.
+
+# This file just makes sure that the .fini and .init sections do in
+# fact return.  Users may put any desired instructions in those sections.
+# This file is the last thing linked into any executable.
+
+	.file		"crtn.S"
+
+	.section	".init"
+	z.ret.owo
+	
+	.section	".fini"
+	z.ret.owo
diff --git a/libgcc/config/lobster128/sfp-machine.h b/libgcc/config/lobster128/sfp-machine.h
new file mode 100644
index 00000000000..7874081fdab
--- /dev/null
+++ b/libgcc/config/lobster128/sfp-machine.h
@@ -0,0 +1,51 @@
+/* Use 32-bit types here to prevent longlong.h trying to use TImode.
+   Once TImode works we might be better to use 64-bit here.  */
+
+#define _FP_W_TYPE_SIZE		32
+#define _FP_W_TYPE		unsigned int
+#define _FP_WS_TYPE		signed int
+#define _FP_I_TYPE		int
+
+#define _FP_MUL_MEAT_S(R,X,Y)				\
+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_D(R,X,Y)				\
+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_loop(S,R,X,Y)
+#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_2_udiv(D,R,X,Y)
+
+#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
+#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+
+#define _FP_KEEPNANFRACP 1
+#define _FP_QNANNEGATEDP 0
+
+/* Someone please check this.  */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)			\
+  do {								\
+    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)		\
+	&& !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))	\
+      {								\
+	R##_s = Y##_s;						\
+	_FP_FRAC_COPY_##wc(R,Y);				\
+      }								\
+    else							\
+      {								\
+	R##_s = X##_s;						\
+	_FP_FRAC_COPY_##wc(R,X);				\
+      }								\
+    R##_c = FP_CLS_NAN;						\
+  } while (0)
+
+#define _FP_TININESS_AFTER_ROUNDING 0
+
+#define __LITTLE_ENDIAN 1234
+#define	__BIG_ENDIAN	4321
+#define __BYTE_ORDER __LITTLE_ENDIAN
+
+/* Define ALIASNAME as a strong alias for NAME.  */
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+# define _strong_alias(name, aliasname) \
+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index 9e2ee865481..c9e04770a6f 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -29241,7 +29241,7 @@ else
     case "${target}" in
       *-rtems*)
         case "${target}" in
-          bfin* | lm32* | mips* | moxie* | or1k* | v850*)
+          bfin* | lm32* | lobster128* | mips* | moxie* | or1k* | v850*)
             ;;
           *)
             $as_echo "#define HAVE_TLS 1" >>confdefs.h
diff --git a/libstdc++-v3/configure.ac b/libstdc++-v3/configure.ac
index b351622bf46..8caca87552b 100644
--- a/libstdc++-v3/configure.ac
+++ b/libstdc++-v3/configure.ac
@@ -357,7 +357,7 @@ else
     case "${target}" in
       *-rtems*)
         case "${target}" in
-          bfin* | lm32* | mips* | moxie* | or1k* | v850*)
+          bfin* | lm32* | lobster128* | mips* | moxie* | or1k* | v850*)
             ;;
           *)
             AC_DEFINE(HAVE_TLS)
