diff --git a/bfd/Makefile.am b/bfd/Makefile.am
index 2fa8df45135..f294e2650d2 100644
--- a/bfd/Makefile.am
+++ b/bfd/Makefile.am
@@ -121,6 +121,7 @@ ALL_MACHINES = \
 	cpu-ia64.lo \
 	cpu-ip2k.lo \
 	cpu-iq2000.lo \
+	cpu-lobster128.lo \
 	cpu-lm32.lo \
 	cpu-loongarch.lo \
 	cpu-m10200.lo \
@@ -205,6 +206,7 @@ ALL_MACHINES_CFILES = \
 	cpu-ip2k.c \
 	cpu-iq2000.c \
 	cpu-lm32.c \
+	cpu-lobster128.c \
 	cpu-loongarch.c \
 	cpu-m10200.c \
 	cpu-m10300.c \
@@ -550,6 +552,7 @@ BFD64_BACKENDS = \
 	elf64-ia64.lo \
 	elf64-ia64-vms.lo \
 	elfxx-ia64.lo \
+	elf64-lobster128.lo \
 	elf32-loongarch.lo \
 	elf64-loongarch.lo \
 	elfxx-loongarch.lo \
@@ -611,6 +614,7 @@ BFD64_BACKENDS_CFILES = \
 	elfn32-mips.c \
 	elfxx-aarch64.c \
 	elfxx-ia64.c \
+	elf64-lobster128.c \
 	elfxx-loongarch.c \
 	elfxx-mips.c \
 	elfxx-riscv.c \
diff --git a/bfd/archures.c b/bfd/archures.c
index c67bacddfdc..87dc5728bc5 100644
--- a/bfd/archures.c
+++ b/bfd/archures.c
@@ -562,6 +562,8 @@ DESCRIPTION
 .#define bfd_mach_amdgcn_gfx1030 0x036
 .#define bfd_mach_amdgcn_gfx1031 0x037
 .#define bfd_mach_amdgcn_gfx1032 0x038
+.  bfd_arch_lobster128,      {* Lobster128 *}
+#define bfd_mach_lobster128 1
 .  bfd_arch_last
 .  };
 */
@@ -641,6 +643,7 @@ extern const bfd_arch_info_type bfd_ia64_arch;
 extern const bfd_arch_info_type bfd_ip2k_arch;
 extern const bfd_arch_info_type bfd_iq2000_arch;
 extern const bfd_arch_info_type bfd_lm32_arch;
+extern const bfd_arch_info_type bfd_lobster128_arch;
 extern const bfd_arch_info_type bfd_loongarch_arch;
 extern const bfd_arch_info_type bfd_m32c_arch;
 extern const bfd_arch_info_type bfd_m32r_arch;
@@ -729,6 +732,7 @@ static const bfd_arch_info_type * const bfd_archures_list[] =
     &bfd_ip2k_arch,
     &bfd_iq2000_arch,
     &bfd_lm32_arch,
+    &bfd_lobster128_arch,
     &bfd_loongarch_arch,
     &bfd_m32c_arch,
     &bfd_m32r_arch,
diff --git a/bfd/bfd-in2.h b/bfd/bfd-in2.h
index 79fcc4eb912..0fb969ddf30 100644
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -1880,6 +1880,8 @@ enum bfd_architecture
 #define bfd_mach_amdgcn_gfx1030 0x036
 #define bfd_mach_amdgcn_gfx1031 0x037
 #define bfd_mach_amdgcn_gfx1032 0x038
+  bfd_arch_lobster128,      /* Lobster128 */
+#define bfd_mach_lobster128   1
   bfd_arch_last
   };
 
@@ -6292,6 +6294,10 @@ assembler and not (currently) written to any object files.  */
   BFD_RELOC_LARCH_TLS_GD_HI20,
   BFD_RELOC_LARCH_32_PCREL,
   BFD_RELOC_LARCH_RELAX,
+
+  BFD_RELOC_LOBSTER128_13,
+  BFD_RELOC_LOBSTER128_13_PCREL,
+  
   BFD_RELOC_UNUSED };
 
 typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
diff --git a/bfd/config.bfd b/bfd/config.bfd
index a79a0e2bf5b..bd78b815719 100644
--- a/bfd/config.bfd
+++ b/bfd/config.bfd
@@ -797,6 +797,10 @@ case "${targ}" in
     targ_selvecs=lm32_elf32_vec
     ;;
 
+  lobster128-*-elf)
+    targ_defvec=lobster128_elf64_vec
+    ;;
+
   m32c-*-elf)
     targ_defvec=m32c_elf32_vec
     targ_underscore=yes
diff --git a/bfd/configure b/bfd/configure
index b5e44e6af79..925bbff4d78 100755
--- a/bfd/configure
+++ b/bfd/configure
@@ -13413,6 +13413,7 @@ do
     iq2000_elf32_vec)		 tb="$tb elf32-iq2000.lo elf32.lo $elf" ;;
     lm32_elf32_vec)		 tb="$tb elf32-lm32.lo elf32.lo $elf" ;;
     lm32_elf32_fdpic_vec)	 tb="$tb elf32-lm32.lo elf32.lo $elf" ;;
+    lobster128_elf64_vec)	 tb="$tb elf64-lobster128.lo elf64.lo $elf"; target_size=64 ;;
     loongarch_elf32_vec)	 tb="$tb elf32-loongarch.lo elfxx-loongarch.lo elf32.lo elf-ifunc.lo $elf" ;;
     loongarch_elf64_vec)	 tb="$tb elf64-loongarch.lo elf64.lo elfxx-loongarch.lo elf32.lo elf-ifunc.lo $elf"; target_size=64 ;;
     loongarch64_pei_vec)	 tb="$tb pei-loongarch64.lo pe-loongarch64igen.lo $coff"; target_size=64 ;;
diff --git a/bfd/configure.ac b/bfd/configure.ac
index fb8795bdffc..ec4723bd526 100644
--- a/bfd/configure.ac
+++ b/bfd/configure.ac
@@ -492,6 +492,7 @@ do
     iq2000_elf32_vec)		 tb="$tb elf32-iq2000.lo elf32.lo $elf" ;;
     lm32_elf32_vec)		 tb="$tb elf32-lm32.lo elf32.lo $elf" ;;
     lm32_elf32_fdpic_vec)	 tb="$tb elf32-lm32.lo elf32.lo $elf" ;;
+    lobster128_elf64_vec)	 tb="$tb elf64- lobster128.lo elf64.lo elf32.lo elf-ifunc.lo $elf"; target_size=64 ;;
     loongarch_elf32_vec)	 tb="$tb elf32-loongarch.lo elfxx-loongarch.lo elf32.lo elf-ifunc.lo $elf" ;;
     loongarch_elf64_vec)	 tb="$tb elf64-loongarch.lo elf64.lo elfxx-loongarch.lo elf32.lo elf-ifunc.lo $elf"; target_size=64 ;;
     loongarch64_pei_vec)	 tb="$tb pei-loongarch64.lo pe-loongarch64igen.lo $coff"; target_size=64 ;;
diff --git a/bfd/cpu-lobster128.c b/bfd/cpu-lobster128.c
new file mode 100644
index 00000000000..b19c97ea28b
--- /dev/null
+++ b/bfd/cpu-lobster128.c
@@ -0,0 +1,41 @@
+/* BFD support for LoongArch.
+   Copyright (C) 2021-2022 Free Software Foundation, Inc.
+   Contributed by Loongson Ltd.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING3.  If not,
+   see <http://www.gnu.org/licenses/>.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+
+const bfd_arch_info_type bfd_lobster128_arch =
+{
+  128,			/* Bits in a word.  */
+  64,				/* Bits in an address.  */
+  8,				/* Bits in a byte.  */
+  bfd_arch_lobster128,		/* Architecture.  */
+  bfd_mach_lobster128, 	/* Machine number - 0 for now.  */
+  "lobster128",		/* Architecture name.  */
+  "Lobster128",		/* Printable name.  */
+  6,				/* Section align power.  */
+  true,			/* This is the default architecture.  */
+  bfd_default_compatible,	/* Architecture comparison function.  */
+  bfd_default_scan,		/* String to architecture conversion.  */
+  bfd_arch_default_fill,	/* Default fill.  */
+  NULL, 			/* Next in list.  */
+  0,          /* Maximum offset of a reloc from the start of an insn.  */
+};
diff --git a/bfd/elf64-lobster128.c b/bfd/elf64-lobster128.c
new file mode 100644
index 00000000000..1d8bef6ff61
--- /dev/null
+++ b/bfd/elf64-lobster128.c
@@ -0,0 +1,343 @@
+/* lobster128-specific support for 32-bit ELF.
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   Copied from elf32-fr30.c which is..
+   Copyright (C) 1998-2022 Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "elf/lobster128.h"
+
+/* Forward declarations.  */
+
+static reloc_howto_type lobster128_elf_howto_table[] =
+{
+  /* This reloc does nothing.  */
+  HOWTO(R_LOBSTER128_NONE,      /* type */
+        0,                      /* rightshift */
+        0,                      /* size */
+        0,                      /* bitsize */
+        false,                  /* pc_relative */
+        0,                      /* bitpos */
+        complain_overflow_dont, /* complain_on_overflow */
+        bfd_elf_generic_reloc,  /* special_function */
+        "R_LOBSTER128_NONE",    /* name */
+        false,                  /* partial_inplace */
+        0,                      /* src_mask */
+        0,                      /* dst_mask */
+        false),                 /* pcrel_offset */
+  HOWTO(R_LOBSTER128_13,        /* type */
+        0,                      /* rightshift */
+        2,                      /* size */
+        13,                     /* bitsize */
+        false,                  /* pc_relative */
+        0,                      /* bitpos */
+        complain_overflow_dont, /* complain_on_overflow */
+        bfd_elf_generic_reloc,  /* special_function */
+        "R_LOBSTER128_13",      /* name */
+        false,                  /* partial_inplace */
+        0,                      /* src_mask */
+        0x1fff,                 /* dst_mask */
+        false),                 /* pcrel_offset */
+  HOWTO(R_LOBSTER128_13_PCREL,  /* type */
+        0,                      /* rightshift */
+        2,                      /* size */
+        13,                     /* bitsize */
+        true,                   /* pc_relative */
+        0,                      /* bitpos */
+        complain_overflow_dont, /* complain_on_overflow */
+        bfd_elf_generic_reloc,  /* special_function */
+        "R_LOBSTER128_13_PCREL",/* name */
+        false,                  /* partial_inplace */
+        0,                      /* src_mask */
+        0x1fff,                 /* dst_mask */
+        true),                  /* pcrel_offset */
+};
+
+/* Map BFD reloc types to LOBSTER128 ELF reloc types.  */
+
+struct lobster128_reloc_map
+{
+  bfd_reloc_code_real_type bfd_reloc_val;
+  unsigned int lobster128_reloc_val;
+};
+
+static const struct lobster128_reloc_map lobster128_reloc_map[] = {
+  {BFD_RELOC_NONE, R_LOBSTER128_NONE},
+};
+
+static reloc_howto_type *
+lobster128_reloc_type_lookup(bfd *abfd ATTRIBUTE_UNUSED,
+                             bfd_reloc_code_real_type code)
+{
+  unsigned int i;
+  for (i = sizeof(lobster128_reloc_map) / sizeof(lobster128_reloc_map[0]); i--; )
+    if (lobster128_reloc_map[i].bfd_reloc_val == code)
+      return &lobster128_elf_howto_table[lobster128_reloc_map[i].lobster128_reloc_val];
+  return NULL;
+}
+
+static reloc_howto_type *
+lobster128_reloc_name_lookup(bfd *abfd ATTRIBUTE_UNUSED, const char *r_name)
+{
+  unsigned int i;
+  for (i = 0; i < sizeof(lobster128_elf_howto_table) / sizeof(lobster128_elf_howto_table[0]); i++)
+    if (lobster128_elf_howto_table[i].name != NULL && strcasecmp(lobster128_elf_howto_table[i].name, r_name) == 0)
+      return &lobster128_elf_howto_table[i];
+  return NULL;
+}
+
+/* Set the howto pointer for an LOBSTER128 ELF reloc.  */
+
+static bool
+lobster128_info_to_howto_rela(bfd *abfd,
+                              arelent *cache_ptr,
+                              Elf_Internal_Rela *dst)
+{
+  unsigned int r_type = ELF32_R_TYPE(dst->r_info);
+  if (r_type >= (unsigned int)R_LOBSTER128_max)
+  {
+    /* xgettext:c-format */
+    _bfd_error_handler(_("%pB: unsupported relocation type %#x"),
+                       abfd, r_type);
+    bfd_set_error(bfd_error_bad_value);
+    return false;
+  }
+  cache_ptr->howto = &lobster128_elf_howto_table[r_type];
+  return true;
+}
+
+/* Perform a single relocation.  By default we use the standard BFD
+   routines, but a few relocs, we have to do them ourselves.  */
+
+static bfd_reloc_status_type
+lobster128_final_link_relocate(reloc_howto_type *howto,
+                               bfd *input_bfd,
+                               asection *input_section,
+                               bfd_byte *contents,
+                               Elf_Internal_Rela *rel,
+                               bfd_vma relocation)
+{
+  bfd_reloc_status_type r = bfd_reloc_ok;
+  switch (howto->type)
+  {
+  default:
+    r = _bfd_final_link_relocate(howto, input_bfd, input_section,
+                                 contents, rel->r_offset,
+                                 relocation, rel->r_addend);
+  }
+  return r;
+}
+
+/* Relocate an LOBSTER128 ELF section.
+
+   The RELOCATE_SECTION function is called by the new ELF backend linker
+   to handle the relocations for a section.
+
+   The relocs are always passed as Rela structures; if the section
+   actually uses Rel structures, the r_addend field will always be
+   zero.
+
+   This function is responsible for adjusting the section contents as
+   necessary, and (if using Rela relocs and generating a relocatable
+   output file) adjusting the reloc addend as necessary.
+
+   This function does not have to worry about setting the reloc
+   address or the reloc symbol index.
+
+   LOCAL_SYMS is a pointer to the swapped in local symbols.
+
+   LOCAL_SECTIONS is an array giving the section in the input file
+   corresponding to the st_shndx field of each local symbol.
+
+   The global hash table entry for the global symbols can be found
+   via elf_sym_hashes (input_bfd).
+
+   When generating relocatable output, this function must handle
+   STB_LOCAL/STT_SECTION symbols specially.  The output symbol is
+   going to be the section symbol corresponding to the output
+   section, which means that the addend must be adjusted
+   accordingly.  */
+
+static int
+lobster128_elf_relocate_section(bfd *output_bfd,
+                                struct bfd_link_info *info,
+                                bfd *input_bfd,
+                                asection *input_section,
+                                bfd_byte *contents,
+                                Elf_Internal_Rela *relocs,
+                                Elf_Internal_Sym *local_syms,
+                                asection **local_sections)
+{
+  struct elf_link_hash_entry **sym_hashes;
+  Elf_Internal_Shdr *symtab_hdr = &elf_tdata(input_bfd)->symtab_hdr;
+  Elf_Internal_Rela *relend = relocs + input_section->reloc_count;
+  Elf_Internal_Rela *rel;
+
+  sym_hashes = elf_sym_hashes(input_bfd);
+
+  for (rel = relocs; rel < relend; rel++)
+  {
+    int r_type = ELF32_R_TYPE(rel->r_info);
+    unsigned long r_symndx = ELF32_R_SYM(rel->r_info);
+    reloc_howto_type *howto = lobster128_elf_howto_table + r_type;
+    struct elf_link_hash_entry *h = NULL;
+    Elf_Internal_Sym *sym = NULL;
+    asection *sec = NULL;
+    bfd_vma relocation;
+    bfd_reloc_status_type r;
+    const char *name;
+
+    if (r_symndx < symtab_hdr->sh_info)
+    {
+      sym = local_syms + r_symndx;
+      sec = local_sections[r_symndx];
+      relocation = _bfd_elf_rela_local_sym(output_bfd, sym, &sec, rel);
+
+      name = bfd_elf_string_from_elf_section(input_bfd, symtab_hdr->sh_link, sym->st_name);
+      name = name == NULL ? bfd_section_name(sec) : name;
+    }
+    else
+    {
+      bool unresolved_reloc, warned, ignored;
+
+      RELOC_FOR_GLOBAL_SYMBOL(info, input_bfd, input_section, rel,
+                              r_symndx, symtab_hdr, sym_hashes,
+                              h, sec, relocation,
+                              unresolved_reloc, warned, ignored);
+
+      name = h->root.root.string;
+    }
+
+    if (sec != NULL && discarded_section(sec))
+      RELOC_AGAINST_DISCARDED_SECTION(info, input_bfd, input_section,
+                                      rel, 1, relend, howto, 0, contents);
+
+    if (bfd_link_relocatable(info))
+      continue;
+
+    r = lobster128_final_link_relocate(howto, input_bfd, input_section,
+                                       contents, rel, relocation);
+    if (r != bfd_reloc_ok)
+    {
+      const char *msg = NULL;
+      switch (r)
+      {
+      case bfd_reloc_overflow:
+        (*info->callbacks->reloc_overflow)(info, (h ? &h->root : NULL), name, howto->name,
+                                           (bfd_vma)0, input_bfd, input_section, rel->r_offset);
+        break;
+      case bfd_reloc_undefined:
+        (*info->callbacks->undefined_symbol)(info, name, input_bfd, input_section, rel->r_offset, true);
+        break;
+      case bfd_reloc_outofrange:
+        msg = _("internal error: out of range error");
+        break;
+      case bfd_reloc_notsupported:
+        msg = _("internal error: unsupported relocation error");
+        break;
+      case bfd_reloc_dangerous:
+        msg = _("internal error: dangerous relocation");
+        break;
+      default:
+        msg = _("internal error: unknown error");
+        break;
+      }
+
+      if (msg)
+        (*info->callbacks->warning)(info, msg, name, input_bfd,
+                                    input_section, rel->r_offset);
+    }
+  }
+  return true;
+}
+
+/* Return the section that should be marked against GC for a given
+   relocation.  */
+
+static asection *
+lobster128_elf_gc_mark_hook(asection *sec,
+                            struct bfd_link_info *info,
+                            Elf_Internal_Rela *rel,
+                            struct elf_link_hash_entry *h,
+                            Elf_Internal_Sym *sym)
+{
+  return _bfd_elf_gc_mark_hook(sec, info, rel, h, sym);
+}
+
+/* Look through the relocs for a section during the first phase.
+   Since we don't do .gots or .plts, we just need to consider the
+   virtual table relocs for gc.  */
+
+static bool
+lobster128_elf_check_relocs(bfd *abfd,
+                            struct bfd_link_info *info,
+                            asection *sec,
+                            const Elf_Internal_Rela *relocs)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  const Elf_Internal_Rela *rel;
+  const Elf_Internal_Rela *rel_end;
+
+  if (bfd_link_relocatable(info))
+    return true;
+
+  symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes(abfd);
+
+  rel_end = relocs + sec->reloc_count;
+  for (rel = relocs; rel < rel_end; rel++)
+  {
+    struct elf_link_hash_entry *h;
+    unsigned long r_symndx = ELF32_R_SYM(rel->r_info);
+    if (r_symndx < symtab_hdr->sh_info)
+      h = NULL;
+    else
+    {
+      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+      while (h->root.type == bfd_link_hash_indirect || h->root.type == bfd_link_hash_warning)
+        h = (struct elf_link_hash_entry *)h->root.u.i.link;
+    }
+  }
+  return true;
+}
+
+#define TARGET_LITTLE_SYM lobster128_elf64_vec
+#define TARGET_LITTLE_NAME "elf64-lobster128"
+#define ELF_ARCH bfd_arch_lobster128
+#define ELF_MACHINE_CODE EM_LOBSTER128
+#define ELF_MAXPAGESIZE 1
+
+#define elf_info_to_howto_rel NULL
+#define elf_info_to_howto lobster128_info_to_howto_rela
+#define elf_backend_relocate_section lobster128_elf_relocate_section
+#define elf_backend_gc_mark_hook lobster128_elf_gc_mark_hook
+#define elf_backend_check_relocs lobster128_elf_check_relocs
+
+#define elf_backend_can_gc_sections 1
+#define elf_backend_rela_normal 1
+
+#define bfd_elf64_bfd_reloc_type_lookup lobster128_reloc_type_lookup
+#define bfd_elf64_bfd_reloc_name_lookup lobster128_reloc_name_lookup
+
+#include "elf64-target.h"
diff --git a/bfd/libbfd.h b/bfd/libbfd.h
index 68d0c4278b3..2ea4a9c79a4 100644
--- a/bfd/libbfd.h
+++ b/bfd/libbfd.h
@@ -3505,6 +3505,9 @@ static const char *const bfd_reloc_code_real_names[] = { "@@uninitialized@@",
   "BFD_RELOC_LARCH_TLS_GD_HI20",
   "BFD_RELOC_LARCH_32_PCREL",
   "BFD_RELOC_LARCH_RELAX",
+
+  "BFD_RELOC_LOBSTER128_13",
+  "BFD_RELOC_LOBSTER128_13_PCREL",
  "@@overflow: BFD_RELOC_UNUSED@@",
 };
 #endif
diff --git a/bfd/reloc.c b/bfd/reloc.c
index 89b6f7fd352..f93433636d1 100644
--- a/bfd/reloc.c
+++ b/bfd/reloc.c
@@ -8313,6 +8313,14 @@ ENUMX
 ENUMDOC
   LARCH relocations.
 
+ENUM
+  BFD_RELOC_LOBSTER128_13
+ENUMX
+  BFD_RELOC_LOBSTER128_13_PCREL
+ENUMDOC
+  Moxie ELF relocations.
+COMMENT
+
 ENDSENUM
   BFD_RELOC_UNUSED
 CODE_FRAGMENT
diff --git a/bfd/targets.c b/bfd/targets.c
index 1ec8acdb03f..598f55bbb1e 100644
--- a/bfd/targets.c
+++ b/bfd/targets.c
@@ -772,6 +772,7 @@ extern const bfd_target ip2k_elf32_vec;
 extern const bfd_target iq2000_elf32_vec;
 extern const bfd_target lm32_elf32_vec;
 extern const bfd_target lm32_elf32_fdpic_vec;
+extern const bfd_target lobster128_elf64_vec;
 extern const bfd_target loongarch_elf64_vec;
 extern const bfd_target loongarch_elf32_vec;
 extern const bfd_target loongarch64_pei_vec;
@@ -1363,6 +1364,7 @@ static const bfd_target * const _bfd_target_vector[] =
 	&z8k_coff_vec,
 
 #ifdef BFD64
+	&lobster128_elf64_vec,
 	&loongarch_elf32_vec,
 	&loongarch_elf64_vec,
 	&loongarch64_pei_vec,
diff --git a/binutils/readelf.c b/binutils/readelf.c
index cafba9a4f56..21f5a9502f0 100644
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -1046,6 +1046,7 @@ guess_is_rela (unsigned int e_machine)
     case EM_IP2K_OLD:
     case EM_IQ2000:
     case EM_LATTICEMICO32:
+	case EM_LOBSTER128:
     case EM_M32C_OLD:
     case EM_M32C:
     case EM_M32R:
@@ -2940,6 +2941,7 @@ get_machine_name (unsigned e_machine)
     case EM_KF32:		return "ChipON KungFu32";
 
       /* Large numbers...  */
+	case EM_LOBSTER128:	return "Lobster128";
     case EM_MT:                 return "Morpho Techologies MT processor";
     case EM_ALPHA:		return "Alpha";
     case EM_WEBASSEMBLY:	return "Web Assembly";
diff --git a/config.sub b/config.sub
index dba16e84c77..859f91fb75e 100755
--- a/config.sub
+++ b/config.sub
@@ -1207,6 +1207,7 @@ case $cpu-$vendor in
 			| k1om \
 			| le32 | le64 \
 			| lm32 \
+			| lobster128 \
 			| loongarch32 | loongarch64 | loongarchx32 \
 			| m32c | m32r | m32rle \
 			| m5200 | m68000 | m680[012346]0 | m68360 | m683?2 | m68k \
diff --git a/configure b/configure
index 16139e3bfa3..e6a5b430413 100755
--- a/configure
+++ b/configure
@@ -3856,6 +3856,9 @@ case "${target}" in
   i[3456789]86-*-rdos*)
     noconfigdirs="$noconfigdirs gdb"
     ;;
+  lobster128-*-*)
+    noconfigdirs="$noconfigdirs"
+    ;;
   mmix-*-*)
     noconfigdirs="$noconfigdirs gdb"
     ;;
diff --git a/elfcpp/elfcpp.h b/elfcpp/elfcpp.h
index 3ca2d614947..e852fd36f20 100644
--- a/elfcpp/elfcpp.h
+++ b/elfcpp/elfcpp.h
@@ -271,6 +271,7 @@ enum EM
   EM_TI_PRU = 144,
   EM_AARCH64 = 183,
   EM_TILEGX = 191,
+  EM_LOBSTER128 = 290,
   // The Morph MT.
   EM_MT = 0x2530,
   // DLX.
diff --git a/gas/Makefile.am b/gas/Makefile.am
index bd597398671..3756714703a 100644
--- a/gas/Makefile.am
+++ b/gas/Makefile.am
@@ -156,6 +156,7 @@ TARGET_CPU_CFILES = \
 	config/tc-ip2k.c \
 	config/tc-iq2000.c \
 	config/tc-lm32.c \
+	config/tc-lobster128.c \
 	config/tc-loongarch.c \
 	config/tc-m32c.c \
 	config/tc-m32r.c \
diff --git a/gas/Makefile.in b/gas/Makefile.in
index c57d78f82c4..f5c07c6c463 100644
--- a/gas/Makefile.in
+++ b/gas/Makefile.in
@@ -634,6 +634,7 @@ TARGET_CPU_CFILES = \
 	config/tc-ip2k.c \
 	config/tc-iq2000.c \
 	config/tc-lm32.c \
+	config/tc-lobster128.c \
 	config/tc-loongarch.c \
 	config/tc-m32c.c \
 	config/tc-m32r.c \
@@ -1113,6 +1114,8 @@ config/tc-iq2000.$(OBJEXT): config/$(am__dirstamp) \
 	config/$(DEPDIR)/$(am__dirstamp)
 config/tc-lm32.$(OBJEXT): config/$(am__dirstamp) \
 	config/$(DEPDIR)/$(am__dirstamp)
+config/tc-lobster128.$(OBJEXT): config/$(am__dirstamp) \
+	config/$(DEPDIR)/$(am__dirstamp)
 config/tc-loongarch.$(OBJEXT): config/$(am__dirstamp) \
 	config/$(DEPDIR)/$(am__dirstamp)
 config/tc-m32c.$(OBJEXT): config/$(am__dirstamp) \
@@ -1363,6 +1366,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-ip2k.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-iq2000.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-lm32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-lobster128.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-loongarch.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-m32c.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-m32r.Po@am__quote@
diff --git a/gas/config/tc-lobster128.c b/gas/config/tc-lobster128.c
new file mode 100644
index 00000000000..997923a6efe
--- /dev/null
+++ b/gas/config/tc-lobster128.c
@@ -0,0 +1,500 @@
+/* tc-lobster128.c -- Assemble code for lobster128
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to
+   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+#include "as.h"
+#include "safe-ctype.h"
+#include "opcode/lobster128.h"
+#include "elf/lobster128.h"
+
+extern const lobster128_opc_info_t lobster128_opc_info[LOBSTER128_NUM_OPCODES];
+
+const char comment_chars[] = "#";
+const char line_separator_chars[] = ";";
+const char line_comment_chars[] = "#";
+
+static int pending_reloc;
+static htab_t opcode_hash_control;
+
+const pseudo_typeS md_pseudo_table[] = {
+  {0, 0, 0}
+};
+
+const char FLT_CHARS[] = "rRsSfFdDxXpP";
+const char EXP_CHARS[] = "eE";
+
+extern int target_big_endian;
+
+struct option md_longopts[] =
+{
+  { NULL,          no_argument, NULL, 0}
+};
+
+size_t md_longopts_size = sizeof (md_longopts);
+const char *md_shortopts = "";
+
+static valueT md_chars_to_number(char *buf, int n);
+
+void md_operand(expressionS *op ATTRIBUTE_UNUSED)
+{
+  /* Empty for now. */
+}
+
+/* This function is called once, at assembler startup time.  It sets
+   up the hash table with all the opcodes in it, and also initializes
+   some aliases for compatibility with other assemblers.  */
+
+void md_begin(void)
+{
+  int count;
+  const lobster128_opc_info_t *opcode;
+  opcode_hash_control = str_htab_create();
+
+  /* Insert names into hash table.  */
+  for (count = 0, opcode = lobster128_opc_info; count++ < LOBSTER128_NUM_OPCODES; opcode++)
+    str_hash_insert(opcode_hash_control, opcode->name, opcode, 0);
+  
+  target_big_endian = 0;
+  bfd_set_arch_mach(stdoutput, TARGET_ARCH, 0);
+}
+
+/* Parse an expression and then restore the input line pointer.  */
+
+static char *
+parse_exp_save_ilp(char *s, expressionS *op)
+{
+  char *save = input_line_pointer;
+
+  input_line_pointer = s;
+  expression(op);
+  s = input_line_pointer;
+  input_line_pointer = save;
+  return s;
+}
+
+static bool
+parse_is_register_operand(char *s)
+{
+  if (s[0] == 'z' && s[1] == 'e' && s[2] == 'r' && s[3] == 'o')
+  {
+    return true;
+  }
+  else if (s[0] == 'p' && s[1] == 'c')
+  {
+    return true;
+  }
+  else if (s[0] == 'r')
+  {
+    int reg = atoi(&s[1]);
+    if ((reg < 0) || (reg > 128))
+    {
+      return false;
+    }
+    return true;
+  }
+  return false;
+}
+
+static int
+parse_register_operand(char **ptr)
+{
+  int reg;
+  char *s = *ptr;
+  if (s[0] == 'z' && s[1] == 'e' && s[2] == 'r' && s[3] == 'o')
+  {
+    *ptr += 4;
+    reg = 0;
+  }
+  else if (s[0] == 'p' && s[1] == 'c')
+  {
+    *ptr += 2;
+    reg = 1;
+  }
+  else if (s[0] == 'r')
+  {
+    *ptr += 1;
+    reg = atoi(*ptr);
+    if ((reg < 0) || (reg > 128))
+    {
+      as_bad(_("Illegal register number %d"), reg);
+      ignore_rest_of_line();
+      return -1;
+    }
+
+    /* Skip digit from the register */
+    while(ISDIGIT(**ptr))
+      *ptr += 1;
+  }
+  else
+  {
+    as_bad(_("Illegal register %s"), s);
+    ignore_rest_of_line();
+    return -1;
+  }
+  return reg;
+}
+
+/* This is the guts of the machine-dependent assembler.  STR points to
+   a machine dependent instruction.  This function is supposed to emit
+   the frags/bytes it assembles to.  */
+
+void md_assemble(char *str)
+{
+  expressionS arg;
+
+  /* Drop leading whitespace.  */
+  while (*str == ' ')
+    str++;
+
+  /* Find the op code end.  */
+  char *op_start = str;
+  int nlen = 0;
+  char *op_end;
+  for (op_end = str; *op_end && !is_end_of_line[*op_end & 0xff] && *op_end != ' '; op_end++)
+    nlen++;
+
+  char pend = *op_end;
+  *op_end = 0;
+
+  if (nlen == 0)
+    as_bad(_("Can't find opcode "));
+  lobster128_opc_info_t *opcode = (lobster128_opc_info_t *)str_hash_find(opcode_hash_control, op_start);
+  if (opcode == NULL)
+  {
+    as_bad(_("Unknown opcode \"%s\""), op_start);
+    return;
+  }
+  *op_end = pend;
+
+  /* Instructions for the lobtser128 architecture can vary from 16-bits,
+     or 32-bits and can extend up until 128-bit instruction colossus */
+  if (opcode->type == MICRO_OP) {
+    /* Micro ops have 16-bits each and can only operate on registers
+       r0 to r63, for both destination and source, they also have to be
+       aligned */
+    /* TODO: Enforce alignment requirements/emit a warn about said alignment */
+    char *p = frag_more(2);
+    while (ISSPACE(*op_end))
+      op_end++;
+
+    /* Obtain registers */
+    int rd = parse_register_operand(&op_end);
+    if (*op_end != ',')
+      as_warn(_("Expecting comma delimited register operands"));
+    op_end++;
+    int rs = parse_register_operand(&op_end);
+    if(rd >= 0x20 || rs >= 0x20)
+      as_bad(_("Register is out of scope for micro-instruction"));
+    if (*op_end != 0)
+      as_warn(_("Extra stuff on line ignored"));
+    
+    unsigned short iword = opcode->opcode[0] & 0x3f;
+    iword |= ((rs << 5) + rd) << 6; /* 4bits op, 2bit prefix */
+    md_number_to_chars(p, iword, 2);
+    dwarf2_emit_insn(2);
+  } else if ((opcode->type & MINI_OP) != 0) {
+    char *p = frag_more(4);
+    while (ISSPACE(*op_end))
+      op_end++;
+
+    /* Obtain registers */
+    int rd = parse_register_operand(&op_end);
+    if (*op_end != ',')
+      as_warn(_("Expecting comma delimited register operands"));
+    op_end++;
+
+    unsigned long lword = opcode->opcode[0];
+    if(opcode->type == MINI_IMM_OP)
+      goto mini_imm;
+    else if(opcode->type == MINI_REG_OP)
+      goto mini_reg;
+
+    /* Auto deduction */
+    if (parse_is_register_operand(op_end)) { /* Register */
+      as_warn(_("Use \"%sr\" instead of \"%s\" for safety"), opcode->name, opcode->name);
+      lword |= SINST_MEMOP(MEM_MOVE);
+mini_reg:
+      int ra = parse_register_operand(&op_end);
+      if (*op_end != ',')
+        as_warn(_("Expecting comma delimited register operands"));
+      op_end++;
+      int rb = parse_register_operand(&op_end);
+      if(rd >= 0x40 || ra >= 0x40 || rb >= 0x40)
+        as_bad(_("Register is out of scope for mini-instruction"));
+      lword |= ((ra << 12) | (rb << 6) | rd) << 14;
+    } else { /* 13-bit immediate */
+      as_warn(_("Use \"%si\" instead of \"%s\" for safety"), opcode->name, opcode->name);
+      lword |= SINST_MEMOP(MEM_IMM);
+mini_imm:
+      if(rd >= 0x20)
+        as_bad(_("Register is out of scope for mini-instruction"));
+      op_end = parse_exp_save_ilp(op_end, &arg);
+      fix_new_exp(frag_now,
+                  (p - frag_now->fr_literal),
+                  2,
+                  &arg,
+                  0,
+                  BFD_RELOC_LOBSTER128_13);
+      lword |= (rd) << 14;
+    }
+    md_number_to_chars(p, lword, 4);
+    dwarf2_emit_insn(4);
+  } else {
+    abort();
+  }
+
+  while (ISSPACE(*op_end))
+    op_end++;
+  if (*op_end != 0)
+    as_warn(_("Extra stuff on line ignored"));
+
+  if (pending_reloc)
+    as_bad(_("Something forgot to clean up\n"));
+}
+
+/* Turn a string in input_line_pointer into a floating point constant
+   of type type, and store the appropriate bytes in *LITP.  The number
+   of LITTLENUMS emitted is stored in *SIZEP .  An error message is
+   returned, or NULL on OK.  */
+const char *
+md_atof(int type, char *litP, int *sizeP)
+{
+  int prec;
+  LITTLENUM_TYPE words[4];
+  char *t;
+  int i;
+
+  switch (type)
+  {
+  case 'f':
+    prec = 2;
+    break;
+
+  case 'd':
+    prec = 4;
+    break;
+
+  default:
+    *sizeP = 0;
+    return _("bad call to md_atof");
+  }
+
+  t = atof_ieee(input_line_pointer, type, words);
+  if (t)
+    input_line_pointer = t;
+
+  *sizeP = prec * 2;
+  for (i = prec - 1; i >= 0; i--)
+  {
+    md_number_to_chars(litP, (valueT)words[i], 2);
+    litP += 2;
+  }
+  return NULL;
+}
+
+
+/* Apply a fixup to the object file.  */
+void md_apply_fix(fixS *fixP, valueT *valP, segT seg)
+{
+  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
+  long val = *valP, newval;
+  long min = 0, max = 0;
+  switch (fixP->fx_r_type)
+  {
+  case BFD_RELOC_32:
+    if (target_big_endian)
+    {
+      buf[0] = val >> 24;
+      buf[1] = val >> 16;
+      buf[2] = val >> 8;
+      buf[3] = val >> 0;
+    }
+    else
+    {
+      buf[3] = val >> 24;
+      buf[2] = val >> 16;
+      buf[1] = val >> 8;
+      buf[0] = val >> 0;
+    }
+    buf += 4;
+    break;
+  case BFD_RELOC_16:
+    if (target_big_endian)
+    {
+      buf[0] = val >> 8;
+      buf[1] = val >> 0;
+    }
+    else
+    {
+      buf[1] = val >> 8;
+      buf[0] = val >> 0;
+    }
+    buf += 2;
+    break;
+  case BFD_RELOC_8:
+    *buf++ = val;
+    break;
+  /* 13-bit relocation, first byte is taken entirely by neval however the
+   * second one has to be bitwise ORed while keeping the remaining 3 bits */
+  case BFD_RELOC_LOBSTER128_13:
+    newval = md_chars_to_number(buf, 4);
+    newval |= ((val & 0x1fff) << 3) << 16;
+    md_number_to_chars(buf, newval, 4);
+    break;
+  default:
+    abort();
+  }
+
+  if (max != 0 && (val < min || val > max))
+    as_bad_where(fixP->fx_file, fixP->fx_line, _("offset out of range"));
+
+  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
+    fixP->fx_done = 1;
+}
+
+/* Convert from target byte order to host byte order.  */
+static valueT
+md_chars_to_number(char *buf, int n)
+{
+  valueT result = 0;
+  unsigned char *where = (unsigned char *)buf;
+
+  if (target_big_endian)
+  {
+    while (n--)
+    {
+      result <<= 8;
+      result |= (*where++ & 255);
+    }
+  }
+  else
+  {
+    while (n--)
+    {
+      result <<= 8;
+      result |= (where[n] & 255);
+    }
+  }
+
+  return result;
+}
+
+/* Put number into target byte order.  */
+void md_number_to_chars(char *ptr, valueT use, int nbytes)
+{
+  if (target_big_endian)
+    number_to_chars_bigendian (ptr, use, nbytes);
+  else
+    number_to_chars_littleendian (ptr, use, nbytes);
+}
+
+/* Generate a machine-dependent relocation.  */
+arelent *
+tc_gen_reloc(asection *section ATTRIBUTE_UNUSED, fixS *fixP)
+{
+  bfd_reloc_code_real_type code;
+  switch (fixP->fx_r_type)
+  {
+  case BFD_RELOC_32:
+    code = fixP->fx_r_type;
+    break;
+  case BFD_RELOC_LOBSTER128_13_PCREL:
+    code = fixP->fx_r_type;
+    break;
+  default:
+    as_bad_where(fixP->fx_file, fixP->fx_line,
+                 _("Semantics error.  This type of operand can not be relocated, it must be an assembly-time constant"));
+    return 0;
+  }
+
+  arelent *relP = XNEW(arelent);
+  relP->sym_ptr_ptr = XNEW(asymbol *);
+  *relP->sym_ptr_ptr = symbol_get_bfdsym(fixP->fx_addsy);
+  relP->address = fixP->fx_frag->fr_address + fixP->fx_where;
+
+  relP->addend = fixP->fx_offset;
+
+  /* This is the standard place for KLUDGEs to work around bugs in
+     bfd_install_relocation (first such note in the documentation
+     appears with binutils-2.8).
+
+     That function bfd_install_relocation does the wrong thing with
+     putting stuff into the addend of a reloc (it should stay out) for a
+     weak symbol.  The really bad thing is that it adds the
+     "segment-relative offset" of the symbol into the reloc.  In this
+     case, the reloc should instead be relative to the symbol with no
+     other offset than the assembly code shows; and since the symbol is
+     weak, any local definition should be ignored until link time (or
+     thereafter).
+     To wit:  weaksym+42  should be weaksym+42 in the reloc,
+     not weaksym+(offset_from_segment_of_local_weaksym_definition)
+
+     To "work around" this, we subtract the segment-relative offset of
+     "known" weak symbols.  This evens out the extra offset.
+
+     That happens for a.out but not for ELF, since for ELF,
+     bfd_install_relocation uses the "special function" field of the
+     howto, and does not execute the code that needs to be undone.  */
+  if (OUTPUT_FLAVOR == bfd_target_aout_flavour && fixP->fx_addsy && S_IS_WEAK(fixP->fx_addsy) && !bfd_is_und_section(S_GET_SEGMENT(fixP->fx_addsy)))
+  {
+    relP->addend -= S_GET_VALUE(fixP->fx_addsy);
+  }
+
+  relP->howto = bfd_reloc_type_lookup(stdoutput, code);
+  if (!relP->howto)
+  {
+    const char *name;
+    if ((name = S_GET_NAME(fixP->fx_addsy)) == NULL)
+      name = _("<unknown>");
+    as_fatal(_("Cannot generate relocation type for symbol %s, code %s"),
+             name, bfd_get_reloc_code_name(code));
+  }
+
+  return relP;
+}
+
+/* Decide from what point a pc-relative relocation is relative to,
+   relative to the pc-relative fixup.  Er, relatively speaking.  */
+long md_pcrel_from(fixS *fixP)
+{
+  valueT addr = fixP->fx_where + fixP->fx_frag->fr_address;
+
+  switch (fixP->fx_r_type)
+  {
+  case BFD_RELOC_32:
+    return addr + 4;
+  case BFD_RELOC_LOBSTER128_13_PCREL:
+    return addr + 4;
+  default:
+    abort();
+    return addr;
+  }
+}
+
+void
+md_show_usage (FILE *stream ATTRIBUTE_UNUSED)
+{
+
+}
+
+int
+md_parse_option (int c ATTRIBUTE_UNUSED, const char *arg ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
diff --git a/gas/config/tc-lobster128.h b/gas/config/tc-lobster128.h
new file mode 100644
index 00000000000..df8cdd1c57b
--- /dev/null
+++ b/gas/config/tc-lobster128.h
@@ -0,0 +1,41 @@
+/* tc-lobster128.h -- Header file for tc-lobster128.c.
+
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with GAS; see the file COPYING.  If not, write to the Free Software
+   Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#define TC_LOBSTER128
+
+#define TARGET_BYTES_LITTLE_ENDIAN 1
+#define WORKING_DOT_WORD
+
+/* Permit temporary numeric labels.  */
+#define LOCAL_LABELS_FB 1
+
+/* This macro is the BFD architecture to pass to `bfd_set_arch_mach'.  */
+#define TARGET_FORMAT "elf64-lobster128"
+#define TARGET_ARCH bfd_arch_lobster128
+#define TARGET_MACH bfd_mach_lobster128
+
+#define md_undefined_symbol(NAME)           0
+
+/* These macros must be defined, but is will be a fatal assembler
+   error if we ever hit them.  */
+#define md_estimate_size_before_relax(A, B) (as_fatal (_("estimate size\n")), 0)
+#define md_convert_frag(B, S, F)            as_fatal (_("convert_frag\n"))
+
+#define md_section_align(SEGMENT, SIZE)     (SIZE)
diff --git a/gas/configure.tgt b/gas/configure.tgt
index 9f2b6720bd7..0caca2f0671 100644
--- a/gas/configure.tgt
+++ b/gas/configure.tgt
@@ -279,6 +279,8 @@ case ${generic_target} in
   iq2000-*-elf)				fmt=elf ;;
 
   lm32-*-*)				fmt=elf ;;
+  
+  lobster128-*-*)				fmt=elf endian=little ;;
 
   loongarch*)				fmt=elf ;;
 
diff --git a/include/elf/common.h b/include/elf/common.h
index ebcd8f9e82c..853494c8fbc 100644
--- a/include/elf/common.h
+++ b/include/elf/common.h
@@ -360,6 +360,7 @@
 #define EM_U16_U8CORE	260	/* LAPIS nX-U16/U8 */
 #define EM_TACHYUM	261	/* Tachyum */
 #define EM_56800EF	262	/* NXP 56800EF Digital Signal Controller (DSC) */
+#define EM_LOBSTER128 290  /* Lobster128 */
 
 /* If it is necessary to assign new unofficial EM_* values, please pick large
    random numbers (0x8523, 0xa7f2, etc.) to minimize the chances of collision
diff --git a/include/elf/lobster128.h b/include/elf/lobster128.h
new file mode 100644
index 00000000000..e1e8e95fdbb
--- /dev/null
+++ b/include/elf/lobster128.h
@@ -0,0 +1,32 @@
+/* lobster128 ELF support for BFD.
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _ELF_LOBSTER128_H
+#define _ELF_LOBSTER128_H
+
+#include "elf/reloc-macros.h"
+
+/* Relocation types.  */
+START_RELOC_NUMBERS (elf_lobster128_reloc_type)
+  RELOC_NUMBER (R_LOBSTER128_NONE, 0)
+  RELOC_NUMBER (R_LOBSTER128_13, 1)
+  RELOC_NUMBER (R_LOBSTER128_13_PCREL, 2)
+END_RELOC_NUMBERS (R_LOBSTER128_max)
+
+#endif /* _ELF_LOBSTER128_H */
diff --git a/include/opcode/lobster128.h b/include/opcode/lobster128.h
new file mode 100644
index 00000000000..8c382bc72b0
--- /dev/null
+++ b/include/opcode/lobster128.h
@@ -0,0 +1,89 @@
+/* Definitions for decoding the lobster128 opcode table.
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#define PREFIX_MICROINST  0b00
+#define PREFIX_LONGINST   0b01
+#define PREFIX_MINIINST   0b10
+#define PREFIX_REP        0b11
+
+#define XLU_ADD   0b0000
+#define XLU_SUB   0b0001
+#define XLU_AND   0b0010
+#define XLU_NOT   0b0011
+#define XLU_LSH   0b0100
+#define XLU_RSH   0b0101
+#define XLU_OR    0b0110
+#define XLU_XOR   0b0111
+#define XLU_MUL   0b1000
+#define XLU_DIV   0b1001
+#define XLU_SET   0b1010 /* Oops! */
+#define XLU_REM   0b1011
+#define XLU_SEX   0b1100
+#define XLU_PUSH  0b1101
+#define XLU_POP   0b1110
+#define XLU_EXT   0b1111
+
+#define DELEG_ALU 0b0000
+#define DELEG_FPU 0b0001
+#define DELEG_VPU 0b0010
+#define DELEG_VFPU 0b0011
+#define DELEG_CTRL 0b1011
+#define DELEG_MEM 0b1100
+#define DELEG_LOCK 0b1000 /* Bitmask */
+
+#define MEM_8 0b0000
+#define MEM_16 0b0100
+#define MEM_32 0b1000
+#define MEM_64 0b1100
+#define MEM_NOOP 0b0000
+#define MEM_IMM MEM_NOOP
+#define MEM_LOAD 0b0001
+#define MEM_LOAD8 0b0001
+#define MEM_LOAD16 0b0101
+#define MEM_LOAD32 0b1001
+#define MEM_LOAD64 0b1101
+#define MEM_STORE 0b0010
+#define MEM_STORE8 0b0010
+#define MEM_STORE16 0b0110
+#define MEM_STORE32 0b1010
+#define MEM_STORE64 0b1110
+#define MEM_MOVE 0b0011
+
+#define UINST(op) { ((op) << 2) | PREFIX_MICROINST, 0, 0, 0 }
+#define SINST_MEMOP(memop) ((memop) << 6)
+#define SINST(op, deleg, memop) { ((op) << 10) | SINST_MEMOP(memop) | ((deleg) << 2) | PREFIX_MINIINST, 0, 0, 0 }
+
+typedef enum lobster128_opc_type_t
+{
+  MICRO_OP = 0, /* 16-bits */
+  MINI_OP = 1, /* 32-bits */
+  MACRO_OP = 2, /* 64-bits */
+
+  MINI_IMM_OP = MINI_OP | 0x40, /* 32-bits, immediate */
+  MINI_REG_OP = MINI_OP | 0x80, /* 32-bits, reg-to-reg */
+} lobster128_opc_type_t;
+
+typedef struct lobster128_opc_info_t
+{
+  unsigned long         opcode[4];
+  lobster128_opc_type_t type;
+  const char *          name;
+} lobster128_opc_info_t;
+
+#define LOBSTER128_NUM_OPCODES 160
+extern const lobster128_opc_info_t lobster128_opc_info[LOBSTER128_NUM_OPCODES];
diff --git a/ld/Makefile.am b/ld/Makefile.am
index d31021c13e2..b0b290c3c3e 100644
--- a/ld/Makefile.am
+++ b/ld/Makefile.am
@@ -440,6 +440,7 @@ ALL_64_EMULATION_SOURCES = \
 	eelf64loongarch.c \
 	eelf64lppc.c \
 	eelf64lppc_fbsd.c \
+	eelf64lobster128.c \
 	eelf64lriscv.c \
 	eelf64lriscv_lp64.c \
 	eelf64lriscv_lp64f.c \
@@ -933,6 +934,7 @@ $(ALL_EMULATION_SOURCES) $(ALL_64_EMULATION_SOURCES): $(GEN_DEPENDS)
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lriscv_lp64f.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64ltsmip.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64ltsmip_fbsd.Pc@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lobster128.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64mmix.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64ppc.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64ppc_fbsd.Pc@am__quote@
diff --git a/ld/Makefile.in b/ld/Makefile.in
index ee0c98f65b0..74f0f72bf51 100644
--- a/ld/Makefile.in
+++ b/ld/Makefile.in
@@ -941,6 +941,7 @@ ALL_64_EMULATION_SOURCES = \
 	eelf64lriscv_lp64f.c \
 	eelf64ltsmip.c \
 	eelf64ltsmip_fbsd.c \
+	eelf64lobster128.c \
 	eelf64mmix.c \
 	eelf64ppc.c \
 	eelf64ppc_fbsd.c \
@@ -1434,6 +1435,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lriscv_lp64f.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64ltsmip.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64ltsmip_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lobster128.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64mmix.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64ppc.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64ppc_fbsd.Po@am__quote@
diff --git a/ld/configure.tgt b/ld/configure.tgt
index 2bae9099b6a..6f848af0935 100644
--- a/ld/configure.tgt
+++ b/ld/configure.tgt
@@ -473,6 +473,8 @@ lm32-*-*linux*)		targ_emul=elf32lm32fd
 lm32-*-*)		targ_emul=elf32lm32
 			targ_extra_emuls="elf32lm32fd"
 			;;
+lobster128-*-*)		targ_emul=elf64lobster128
+			;;
 m32c-*-elf)
 			targ_emul=elf32m32c
 			;;
diff --git a/ld/emulparams/elf64lobster128.sh b/ld/emulparams/elf64lobster128.sh
new file mode 100644
index 00000000000..cc08734809d
--- /dev/null
+++ b/ld/emulparams/elf64lobster128.sh
@@ -0,0 +1,6 @@
+SCRIPT_NAME=elf
+TEMPLATE_NAME=elf
+OUTPUT_FORMAT="elf64-lobster128"
+MAXPAGESIZE="CONSTANT (MAXPAGESIZE)"
+ARCH=lobster128
+EMBEDDED=yes
diff --git a/opcodes/Makefile.am b/opcodes/Makefile.am
index 87be5e7edb2..bb3426444f6 100644
--- a/opcodes/Makefile.am
+++ b/opcodes/Makefile.am
@@ -173,6 +173,8 @@ TARGET32_LIBOPCODES_CFILES = \
 	iq2000-dis.c \
 	iq2000-ibld.c \
 	iq2000-opc.c \
+	lobster128-dis.c \
+	lobster128-opc.c \
 	lm32-asm.c \
 	lm32-desc.c \
 	lm32-dis.c \
diff --git a/opcodes/Makefile.in b/opcodes/Makefile.in
index 581747edb7b..e6b7fbba4b1 100644
--- a/opcodes/Makefile.in
+++ b/opcodes/Makefile.in
@@ -565,6 +565,8 @@ TARGET32_LIBOPCODES_CFILES = \
 	iq2000-dis.c \
 	iq2000-ibld.c \
 	iq2000-opc.c \
+	lobster128-dis.c \
+	lobster128-opc.c \
 	lm32-asm.c \
 	lm32-desc.c \
 	lm32-dis.c \
diff --git a/opcodes/configure b/opcodes/configure
index a5951b9b362..4f17dc055bd 100755
--- a/opcodes/configure
+++ b/opcodes/configure
@@ -12521,6 +12521,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_ip2k_arch)		ta="$ta ip2k-asm.lo ip2k-desc.lo ip2k-dis.lo ip2k-ibld.lo ip2k-opc.lo" using_cgen=yes ;;
 	bfd_epiphany_arch)	ta="$ta epiphany-asm.lo epiphany-desc.lo epiphany-dis.lo epiphany-ibld.lo epiphany-opc.lo" using_cgen=yes ;;
 	bfd_iq2000_arch)	ta="$ta iq2000-asm.lo iq2000-desc.lo iq2000-dis.lo iq2000-ibld.lo iq2000-opc.lo" using_cgen=yes ;;
+  bfd_lobster128_arch) ta="$ta lobster128-dis.lo lobster128-opc.lo" ;;
 	bfd_lm32_arch)		ta="$ta lm32-asm.lo lm32-desc.lo lm32-dis.lo lm32-ibld.lo lm32-opc.lo lm32-opinst.lo" using_cgen=yes ;;
 	bfd_m32c_arch)		ta="$ta m32c-asm.lo m32c-desc.lo m32c-dis.lo m32c-ibld.lo m32c-opc.lo" using_cgen=yes ;;
 	bfd_m32r_arch)		ta="$ta m32r-asm.lo m32r-desc.lo m32r-dis.lo m32r-ibld.lo m32r-opc.lo m32r-opinst.lo" using_cgen=yes ;;
diff --git a/opcodes/configure.ac b/opcodes/configure.ac
index e998d613436..653f4318f27 100644
--- a/opcodes/configure.ac
+++ b/opcodes/configure.ac
@@ -287,6 +287,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_ip2k_arch)		ta="$ta ip2k-asm.lo ip2k-desc.lo ip2k-dis.lo ip2k-ibld.lo ip2k-opc.lo" using_cgen=yes ;;
 	bfd_epiphany_arch)	ta="$ta epiphany-asm.lo epiphany-desc.lo epiphany-dis.lo epiphany-ibld.lo epiphany-opc.lo" using_cgen=yes ;;
 	bfd_iq2000_arch)	ta="$ta iq2000-asm.lo iq2000-desc.lo iq2000-dis.lo iq2000-ibld.lo iq2000-opc.lo" using_cgen=yes ;;
+	bfd_lobster128_arch) ta="$ta lobster128-dis.lo lobster128-opc.lo" ;;
 	bfd_lm32_arch)		ta="$ta lm32-asm.lo lm32-desc.lo lm32-dis.lo lm32-ibld.lo lm32-opc.lo lm32-opinst.lo" using_cgen=yes ;;
 	bfd_m32c_arch)		ta="$ta m32c-asm.lo m32c-desc.lo m32c-dis.lo m32c-ibld.lo m32c-opc.lo" using_cgen=yes ;;
 	bfd_m32r_arch)		ta="$ta m32r-asm.lo m32r-desc.lo m32r-dis.lo m32r-ibld.lo m32r-opc.lo m32r-opinst.lo" using_cgen=yes ;;
diff --git a/opcodes/disassemble.c b/opcodes/disassemble.c
index 79a2f3dabe5..936faeb3930 100644
--- a/opcodes/disassemble.c
+++ b/opcodes/disassemble.c
@@ -58,6 +58,7 @@
 #define ARCH_ip2k
 #define ARCH_iq2000
 #define ARCH_lm32
+#define ARCH_lobster128
 #define ARCH_m32c
 #define ARCH_m32r
 #define ARCH_m68hc11
@@ -261,6 +262,11 @@ disassembler (enum bfd_architecture a,
       disassemble = print_insn_lm32;
       break;
 #endif
+#ifdef ARCH_lobster128
+    case bfd_arch_lobster128:
+      disassemble = print_insn_lobster128;
+      break;
+#endif
 #ifdef ARCH_m32r
     case bfd_arch_m32r:
       disassemble = print_insn_m32r;
diff --git a/opcodes/disassemble.h b/opcodes/disassemble.h
index 2c4c1348099..efc7d84b392 100644
--- a/opcodes/disassemble.h
+++ b/opcodes/disassemble.h
@@ -58,6 +58,7 @@ extern int print_insn_little_mips	(bfd_vma, disassemble_info *);
 extern int print_insn_little_powerpc	(bfd_vma, disassemble_info *);
 extern int print_insn_little_score      (bfd_vma, disassemble_info *);
 extern int print_insn_lm32		(bfd_vma, disassemble_info *);
+extern int print_insn_lobster128	(bfd_vma, disassemble_info *);
 extern int print_insn_m32r		(bfd_vma, disassemble_info *);
 extern int print_insn_m68hc11		(bfd_vma, disassemble_info *);
 extern int print_insn_m68hc12		(bfd_vma, disassemble_info *);
diff --git a/opcodes/lobster128-dis.c b/opcodes/lobster128-dis.c
new file mode 100644
index 00000000000..6dc4402100d
--- /dev/null
+++ b/opcodes/lobster128-dis.c
@@ -0,0 +1,127 @@
+/* Disassemble lobster128 instructions.
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This file is part of the GNU opcodes library.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include <stdio.h>
+
+#define STATIC_TABLE
+#define DEFINE_TABLE
+
+#include "opcode/lobster128.h"
+#include "disassemble.h"
+
+static fprintf_ftype fpr;
+static void *stream;
+
+static const char * reg_names[128] = {
+  "zero", "pc",   "sp",   "fp",   "r4",   "r5",   "r6",   "r7",
+  "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
+  "r16",  "r17",  "r18",  "r19",  "r20",  "r21",  "r22",  "r23",
+  "r24",  "r25",  "r26",  "r27",  "r28",  "r29",  "r30",  "r31",
+  "r32",  "r34",  "r35",  "r36",  "r37",  "r38",  "r39",  "r40",
+  "r41",  "r42",  "r43",  "r44",  "r45",  "r46",  "r47",  "r48",
+  "r49",  "r50",  "r51",  "r52",  "r53",  "r54",  "r55",  "r56",
+  "r57",  "r58",  "r59",  "r60",  "r61",  "r62",  "r63",  "r64",
+  "r65",  "r66",  "r67",  "r68",  "r69",  "r70",  "r71",  "r72",
+  "r73",  "r74",  "r75",  "r76",  "r77",  "r78",  "r79",  "r80",
+  "r81",  "r82",  "r83",  "r84",  "r85",  "r86",  "r87",  "r88",  
+  "r89",  "r90",  "r91",  "r92",  "r93",  "r94",  "r95",  "r96", 
+  "r97",  "r98",  "r99",  "r100", "r101", "r102", "r103", "r104", 
+  "r105", "r106", "r107", "r108", "r109", "r110", "r111", "r112", 
+  "r113", "r114", "r115", "r116", "r117", "r118", "r119", "r120", 
+  "r121", "r122", "r123", "r124", "r125", "r126", "r127", "r128"
+};
+
+static const char *op_names[16] = {
+  "add", "sub", "and", "not", "lsh", "rsh", "or", "xor", "mul", "div",
+  "set", "rem", "sex", "push", "pop", "ext"
+};
+
+static const char *deleg_prefixes[16] = {
+  "", /* ALU */
+  "f", /* FPU */
+  "v", /* VPU */
+  "vf", /* VFPU */
+  "u0",
+  "u1",
+  "u2",
+  "u3",
+  "u4",
+  "u5",
+  "u6",
+  "u7",
+  "u8",
+  /* TODO: Use correct values for this */
+  "c", /* Control */
+  "u9", /* Move/memory */
+  "l", /* Atomic locked operation */
+};
+
+int
+print_insn_lobster128 (bfd_vma addr, struct disassemble_info * info)
+{
+  int status;
+  bfd_byte buffer[4];
+  stream = info->stream;
+  fpr = info->fprintf_func;
+  if ((status = info->read_memory_func (addr, buffer, 2, info)))
+    goto fail;
+  
+  bfd_vma iword = info->endian == BFD_ENDIAN_BIG ? bfd_getb16 (buffer) : bfd_getl16 (buffer);
+  /* We will start from the bottom down, micro insntruction first */
+  if((iword & 0x03) == PREFIX_MICROINST) {
+    int op = (iword >> 2) & 0x0f; /* Extract nibble 4-bits for opcode */
+    int rd = (iword >> 6) & 0x1f;
+    int rs = (iword >> 11) & 0x1f;
+    fpr(stream, "u.%sr\t%s, %s", op_names[op], reg_names[rd], reg_names[rs]);
+    return 2;
+  } else if((iword & 0x03) == PREFIX_MINIINST) {
+    /* Lengthy 32-bits word */
+    if ((status = info->read_memory_func (addr, buffer, 4, info)))
+      goto fail;
+    bfd_vma lword = info->endian == BFD_ENDIAN_BIG ? bfd_getb32 (buffer) : bfd_getl32 (buffer);
+    int del = (lword >> 2) & 0x0f; /* Delegator */
+    const char *delprefix = deleg_prefixes[del];
+    delprefix = delprefix ? delprefix : "\0";
+    int memop = (lword >> 6) & 0x0f; /* Memory operation */
+    int op = (lword >> 10) & 0x0f; /* Extract nibble 4-bits for opcode */
+    if((memop & 0x3) == MEM_IMM) {
+      unsigned short imm13 = (lword >> 19) & 0x1fff;
+      int rd = (lword >> 14) & 0x1f;
+      fpr(stream, "m.%s%si\t%s, %i", delprefix, op_names[op], reg_names[rd], imm13);
+    } else {
+      int rd = (lword >> 14) & 0x3f;
+      int ra = ((lword >> 12) >> 14) & 0x3f;
+      int rb = ((lword >> 6) >> 14) & 0x3f;
+      if((memop & 0x3) == MEM_MOVE) {
+        fpr(stream, "m.%s%sr\t%s,%s,%s", delprefix, op_names[op], reg_names[rd], reg_names[ra], reg_names[rb]);
+      } else {
+        fpr(stream, "m.%s%sm\t%s,%s,%s", delprefix, op_names[op], reg_names[rd], reg_names[ra], reg_names[rb]);
+      }
+    }
+    return 4;
+  } else {
+    fpr(stream, "z.nop\t%lx", iword);
+    return 2;
+  }
+fail:
+  info->memory_error_func (status, addr, info);
+  return -1;
+}
diff --git a/opcodes/lobster128-opc.c b/opcodes/lobster128-opc.c
new file mode 100644
index 00000000000..3395b6dd864
--- /dev/null
+++ b/opcodes/lobster128-opc.c
@@ -0,0 +1,189 @@
+/* lobster128-opc.c -- Definitions for lobster128 opcodes.
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This file is part of the GNU opcodes library.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING.  If not, write to the
+   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "opcode/lobster128.h"
+
+const lobster128_opc_info_t lobster128_opc_info[LOBSTER128_NUM_OPCODES] = {
+  /* Micro instructions */
+  { UINST(XLU_ADD), MICRO_OP, "u.addr" },
+  { UINST(XLU_SUB), MICRO_OP, "u.subr" },
+  { UINST(XLU_AND), MICRO_OP, "u.andr" },
+  { UINST(XLU_NOT), MICRO_OP, "u.notr" },
+  { UINST(XLU_LSH), MICRO_OP, "u.lshr" },
+  { UINST(XLU_RSH), MICRO_OP, "u.rshr" },
+  { UINST(XLU_OR), MICRO_OP, "u.orr" },
+  { UINST(XLU_XOR), MICRO_OP, "u.xorr" },
+  { UINST(XLU_MUL), MICRO_OP, "u.mulr" },
+  { UINST(XLU_DIV), MICRO_OP, "u.divr" },
+  { UINST(XLU_SET), MICRO_OP, "u.set" },
+  { UINST(XLU_REM), MICRO_OP, "u.remr" },
+  { UINST(XLU_SEX), MICRO_OP, "u.sexr" },
+  { UINST(XLU_PUSH), MICRO_OP, "u.pushr" },
+  { UINST(XLU_POP), MICRO_OP, "u.popr" },
+  { UINST(XLU_EXT), MICRO_OP, "u.extr" },
+  /* Immediate mini instructions */
+  { SINST(XLU_ADD, DELEG_ALU, MEM_IMM), MINI_IMM_OP, "m.addi" },
+  { SINST(XLU_SUB, DELEG_ALU, MEM_IMM), MINI_IMM_OP, "m.subi" },
+  { SINST(XLU_AND, DELEG_ALU, MEM_IMM), MINI_IMM_OP, "m.andi" },
+  { SINST(XLU_NOT, DELEG_ALU, MEM_IMM), MINI_IMM_OP, "m.noti" },
+  { SINST(XLU_LSH, DELEG_ALU, MEM_IMM), MINI_IMM_OP, "m.lshi" },
+  { SINST(XLU_RSH, DELEG_ALU, MEM_IMM), MINI_IMM_OP, "m.rshi" },
+  { SINST(XLU_OR, DELEG_ALU, MEM_IMM), MINI_IMM_OP, "m.ori" },
+  { SINST(XLU_XOR, DELEG_ALU, MEM_IMM), MINI_IMM_OP, "m.xori" },
+  { SINST(XLU_MUL, DELEG_ALU, MEM_IMM), MINI_IMM_OP, "m.muli" },
+  { SINST(XLU_DIV, DELEG_ALU, MEM_IMM), MINI_IMM_OP, "m.divi" },
+  { SINST(XLU_SET, DELEG_ALU, MEM_IMM), MINI_IMM_OP, "m.seti" },
+  { SINST(XLU_REM, DELEG_ALU, MEM_IMM), MINI_IMM_OP, "m.remi" },
+  { SINST(XLU_SEX, DELEG_ALU, MEM_IMM), MINI_IMM_OP, "m.sexi" },
+  { SINST(XLU_PUSH, DELEG_ALU, MEM_IMM), MINI_IMM_OP, "m.pushi" },
+  { SINST(XLU_POP, DELEG_ALU, MEM_IMM), MINI_IMM_OP, "m.popi" },
+  { SINST(XLU_EXT, DELEG_ALU, MEM_IMM), MINI_IMM_OP, "m.exti" },
+  { SINST(XLU_ADD, DELEG_FPU, MEM_IMM), MINI_IMM_OP, "m.faddi" },
+  { SINST(XLU_SUB, DELEG_FPU, MEM_IMM), MINI_IMM_OP, "m.fsubi" },
+  { SINST(XLU_AND, DELEG_FPU, MEM_IMM), MINI_IMM_OP, "m.fandi" },
+  { SINST(XLU_NOT, DELEG_FPU, MEM_IMM), MINI_IMM_OP, "m.fnoti" },
+  { SINST(XLU_LSH, DELEG_FPU, MEM_IMM), MINI_IMM_OP, "m.flshi" },
+  { SINST(XLU_RSH, DELEG_FPU, MEM_IMM), MINI_IMM_OP, "m.frshi" },
+  { SINST(XLU_OR, DELEG_FPU, MEM_IMM), MINI_IMM_OP, "m.fori" },
+  { SINST(XLU_XOR, DELEG_FPU, MEM_IMM), MINI_IMM_OP, "m.fxori" },
+  { SINST(XLU_MUL, DELEG_FPU, MEM_IMM), MINI_IMM_OP, "m.fmuli" },
+  { SINST(XLU_DIV, DELEG_FPU, MEM_IMM), MINI_IMM_OP, "m.fdivi" },
+  { SINST(XLU_SET, DELEG_FPU, MEM_IMM), MINI_IMM_OP, "m.fseti" },
+  { SINST(XLU_REM, DELEG_FPU, MEM_IMM), MINI_IMM_OP, "m.fremi" },
+  { SINST(XLU_SEX, DELEG_FPU, MEM_IMM), MINI_IMM_OP, "m.fsexi" },
+  { SINST(XLU_PUSH, DELEG_FPU, MEM_IMM), MINI_IMM_OP, "m.fpushi" },
+  { SINST(XLU_POP, DELEG_FPU, MEM_IMM), MINI_IMM_OP, "m.fpopi" },
+  { SINST(XLU_EXT, DELEG_FPU, MEM_IMM), MINI_IMM_OP, "m.fexti" },
+  { SINST(XLU_ADD, DELEG_VPU, MEM_IMM), MINI_IMM_OP, "m.vaddi" },
+  { SINST(XLU_SUB, DELEG_VPU, MEM_IMM), MINI_IMM_OP, "m.vsubi" },
+  { SINST(XLU_AND, DELEG_VPU, MEM_IMM), MINI_IMM_OP, "m.vandi" },
+  { SINST(XLU_NOT, DELEG_VPU, MEM_IMM), MINI_IMM_OP, "m.vnoti" },
+  { SINST(XLU_LSH, DELEG_VPU, MEM_IMM), MINI_IMM_OP, "m.vlshi" },
+  { SINST(XLU_RSH, DELEG_VPU, MEM_IMM), MINI_IMM_OP, "m.vrshi" },
+  { SINST(XLU_OR, DELEG_VPU, MEM_IMM), MINI_IMM_OP, "m.vori" },
+  { SINST(XLU_XOR, DELEG_VPU, MEM_IMM), MINI_IMM_OP, "m.vxori" },
+  { SINST(XLU_MUL, DELEG_VPU, MEM_IMM), MINI_IMM_OP, "m.vmuli" },
+  { SINST(XLU_DIV, DELEG_VPU, MEM_IMM), MINI_IMM_OP, "m.vdivi" },
+  { SINST(XLU_SET, DELEG_VPU, MEM_IMM), MINI_IMM_OP, "m.vseti" },
+  { SINST(XLU_REM, DELEG_VPU, MEM_IMM), MINI_IMM_OP, "m.vremi" },
+  { SINST(XLU_SEX, DELEG_VPU, MEM_IMM), MINI_IMM_OP, "m.vsexi" },
+  { SINST(XLU_PUSH, DELEG_VPU, MEM_IMM), MINI_IMM_OP, "m.vpushi" },
+  { SINST(XLU_POP, DELEG_VPU, MEM_IMM), MINI_IMM_OP, "m.vpopi" },
+  { SINST(XLU_EXT, DELEG_VPU, MEM_IMM), MINI_IMM_OP, "m.vexti" },
+  /* Register mini instructions */
+  { SINST(XLU_ADD, DELEG_ALU, MEM_MOVE), MINI_REG_OP, "m.addr" },
+  { SINST(XLU_SUB, DELEG_ALU, MEM_MOVE), MINI_REG_OP, "m.subr" },
+  { SINST(XLU_AND, DELEG_ALU, MEM_MOVE), MINI_REG_OP, "m.andr" },
+  { SINST(XLU_NOT, DELEG_ALU, MEM_MOVE), MINI_REG_OP, "m.notr" },
+  { SINST(XLU_LSH, DELEG_ALU, MEM_MOVE), MINI_REG_OP, "m.lshr" },
+  { SINST(XLU_RSH, DELEG_ALU, MEM_MOVE), MINI_REG_OP, "m.rshr" },
+  { SINST(XLU_OR, DELEG_ALU, MEM_MOVE), MINI_REG_OP, "m.orr" },
+  { SINST(XLU_XOR, DELEG_ALU, MEM_MOVE), MINI_REG_OP, "m.xorr" },
+  { SINST(XLU_MUL, DELEG_ALU, MEM_MOVE), MINI_REG_OP, "m.mulr" },
+  { SINST(XLU_DIV, DELEG_ALU, MEM_MOVE), MINI_REG_OP, "m.divr" },
+  { SINST(XLU_SET, DELEG_ALU, MEM_MOVE), MINI_REG_OP, "m.setr" },
+  { SINST(XLU_REM, DELEG_ALU, MEM_MOVE), MINI_REG_OP, "m.remr" },
+  { SINST(XLU_SEX, DELEG_ALU, MEM_MOVE), MINI_REG_OP, "m.sexr" },
+  { SINST(XLU_PUSH, DELEG_ALU, MEM_MOVE), MINI_REG_OP, "m.pushr" },
+  { SINST(XLU_POP, DELEG_ALU, MEM_MOVE), MINI_REG_OP, "m.popr" },
+  { SINST(XLU_EXT, DELEG_ALU, MEM_MOVE), MINI_REG_OP, "m.extr" },
+  { SINST(XLU_ADD, DELEG_FPU, MEM_MOVE), MINI_REG_OP, "m.faddr" },
+  { SINST(XLU_SUB, DELEG_FPU, MEM_MOVE), MINI_REG_OP, "m.fsubr" },
+  { SINST(XLU_AND, DELEG_FPU, MEM_MOVE), MINI_REG_OP, "m.fandr" },
+  { SINST(XLU_NOT, DELEG_FPU, MEM_MOVE), MINI_REG_OP, "m.fnotr" },
+  { SINST(XLU_LSH, DELEG_FPU, MEM_MOVE), MINI_REG_OP, "m.flshr" },
+  { SINST(XLU_RSH, DELEG_FPU, MEM_MOVE), MINI_REG_OP, "m.frshr" },
+  { SINST(XLU_OR, DELEG_FPU, MEM_MOVE), MINI_REG_OP, "m.forr" },
+  { SINST(XLU_XOR, DELEG_FPU, MEM_MOVE), MINI_REG_OP, "m.fxorr" },
+  { SINST(XLU_MUL, DELEG_FPU, MEM_MOVE), MINI_REG_OP, "m.fmulr" },
+  { SINST(XLU_DIV, DELEG_FPU, MEM_MOVE), MINI_REG_OP, "m.fdivr" },
+  { SINST(XLU_SET, DELEG_FPU, MEM_MOVE), MINI_REG_OP, "m.fsetr" },
+  { SINST(XLU_REM, DELEG_FPU, MEM_MOVE), MINI_REG_OP, "m.fremr" },
+  { SINST(XLU_SEX, DELEG_FPU, MEM_MOVE), MINI_REG_OP, "m.fsexr" },
+  { SINST(XLU_PUSH, DELEG_FPU, MEM_MOVE), MINI_REG_OP, "m.fpushr" },
+  { SINST(XLU_POP, DELEG_FPU, MEM_MOVE), MINI_REG_OP, "m.fpopr" },
+  { SINST(XLU_EXT, DELEG_FPU, MEM_MOVE), MINI_REG_OP, "m.fextr" },
+  { SINST(XLU_ADD, DELEG_VPU, MEM_MOVE), MINI_REG_OP, "m.vaddr" },
+  { SINST(XLU_SUB, DELEG_VPU, MEM_MOVE), MINI_REG_OP, "m.vsubr" },
+  { SINST(XLU_AND, DELEG_VPU, MEM_MOVE), MINI_REG_OP, "m.vandr" },
+  { SINST(XLU_NOT, DELEG_VPU, MEM_MOVE), MINI_REG_OP, "m.vnotr" },
+  { SINST(XLU_LSH, DELEG_VPU, MEM_MOVE), MINI_REG_OP, "m.vlshr" },
+  { SINST(XLU_RSH, DELEG_VPU, MEM_MOVE), MINI_REG_OP, "m.vrshr" },
+  { SINST(XLU_OR, DELEG_VPU, MEM_MOVE), MINI_REG_OP, "m.vorr" },
+  { SINST(XLU_XOR, DELEG_VPU, MEM_MOVE), MINI_REG_OP, "m.vxorr" },
+  { SINST(XLU_MUL, DELEG_VPU, MEM_MOVE), MINI_REG_OP, "m.vmulr" },
+  { SINST(XLU_DIV, DELEG_VPU, MEM_MOVE), MINI_REG_OP, "m.vdivr" },
+  { SINST(XLU_SET, DELEG_VPU, MEM_MOVE), MINI_REG_OP, "m.vsetr" },
+  { SINST(XLU_REM, DELEG_VPU, MEM_MOVE), MINI_REG_OP, "m.vremr" },
+  { SINST(XLU_SEX, DELEG_VPU, MEM_MOVE), MINI_REG_OP, "m.vsexr" },
+  { SINST(XLU_PUSH, DELEG_VPU, MEM_MOVE), MINI_REG_OP, "m.vpushr" },
+  { SINST(XLU_POP, DELEG_VPU, MEM_MOVE), MINI_REG_OP, "m.vpopr" },
+  { SINST(XLU_EXT, DELEG_VPU, MEM_MOVE), MINI_REG_OP, "m.vextr" },
+  /* Mini instructions */
+  { SINST(XLU_ADD, DELEG_ALU, 0), MINI_OP, "m.add" },
+  { SINST(XLU_SUB, DELEG_ALU, 0), MINI_OP, "m.sub" },
+  { SINST(XLU_AND, DELEG_ALU, 0), MINI_OP, "m.and" },
+  { SINST(XLU_NOT, DELEG_ALU, 0), MINI_OP, "m.not" },
+  { SINST(XLU_LSH, DELEG_ALU, 0), MINI_OP, "m.lsh" },
+  { SINST(XLU_RSH, DELEG_ALU, 0), MINI_OP, "m.rsh" },
+  { SINST(XLU_OR, DELEG_ALU, 0), MINI_OP, "m.or" },
+  { SINST(XLU_XOR, DELEG_ALU, 0), MINI_OP, "m.xor" },
+  { SINST(XLU_MUL, DELEG_ALU, 0), MINI_OP, "m.mul" },
+  { SINST(XLU_DIV, DELEG_ALU, 0), MINI_OP, "m.div" },
+  { SINST(XLU_SET, DELEG_ALU, 0), MINI_OP, "m.set" },
+  { SINST(XLU_REM, DELEG_ALU, 0), MINI_OP, "m.rem" },
+  { SINST(XLU_SEX, DELEG_ALU, 0), MINI_OP, "m.sex" },
+  { SINST(XLU_PUSH, DELEG_ALU, 0), MINI_OP, "m.push" },
+  { SINST(XLU_POP, DELEG_ALU, 0), MINI_OP, "m.pop" },
+  { SINST(XLU_EXT, DELEG_ALU, 0), MINI_OP, "m.ext" },
+  { SINST(XLU_ADD, DELEG_FPU, 0), MINI_OP, "m.fadd" },
+  { SINST(XLU_SUB, DELEG_FPU, 0), MINI_OP, "m.fsub" },
+  { SINST(XLU_AND, DELEG_FPU, 0), MINI_OP, "m.fand" },
+  { SINST(XLU_NOT, DELEG_FPU, 0), MINI_OP, "m.fnot" },
+  { SINST(XLU_LSH, DELEG_FPU, 0), MINI_OP, "m.flsh" },
+  { SINST(XLU_RSH, DELEG_FPU, 0), MINI_OP, "m.frsh" },
+  { SINST(XLU_OR, DELEG_FPU, 0), MINI_OP, "m.for" },
+  { SINST(XLU_XOR, DELEG_FPU, 0), MINI_OP, "m.fxor" },
+  { SINST(XLU_MUL, DELEG_FPU, 0), MINI_OP, "m.fmul" },
+  { SINST(XLU_DIV, DELEG_FPU, 0), MINI_OP, "m.fdiv" },
+  { SINST(XLU_SET, DELEG_FPU, 0), MINI_OP, "m.fset" },
+  { SINST(XLU_REM, DELEG_FPU, 0), MINI_OP, "m.frem" },
+  { SINST(XLU_SEX, DELEG_FPU, 0), MINI_OP, "m.fsex" },
+  { SINST(XLU_PUSH, DELEG_FPU, 0), MINI_OP, "m.fpush" },
+  { SINST(XLU_POP, DELEG_FPU, 0), MINI_OP, "m.fpop" },
+  { SINST(XLU_EXT, DELEG_FPU, 0), MINI_OP, "m.fext" },
+  { SINST(XLU_ADD, DELEG_VPU, 0), MINI_OP, "m.vadd" },
+  { SINST(XLU_SUB, DELEG_VPU, 0), MINI_OP, "m.vsub" },
+  { SINST(XLU_AND, DELEG_VPU, 0), MINI_OP, "m.vand" },
+  { SINST(XLU_NOT, DELEG_VPU, 0), MINI_OP, "m.vnot" },
+  { SINST(XLU_LSH, DELEG_VPU, 0), MINI_OP, "m.vlsh" },
+  { SINST(XLU_RSH, DELEG_VPU, 0), MINI_OP, "m.vrsh" },
+  { SINST(XLU_OR, DELEG_VPU, 0), MINI_OP, "m.vor" },
+  { SINST(XLU_XOR, DELEG_VPU, 0), MINI_OP, "m.vxor" },
+  { SINST(XLU_MUL, DELEG_VPU, 0), MINI_OP, "m.vmul" },
+  { SINST(XLU_DIV, DELEG_VPU, 0), MINI_OP, "m.vdiv" },
+  { SINST(XLU_SET, DELEG_VPU, 0), MINI_OP, "m.vset" },
+  { SINST(XLU_REM, DELEG_VPU, 0), MINI_OP, "m.vrem" },
+  { SINST(XLU_SEX, DELEG_VPU, 0), MINI_OP, "m.vsex" },
+  { SINST(XLU_PUSH, DELEG_VPU, 0), MINI_OP, "m.vpush" },
+  { SINST(XLU_POP, DELEG_VPU, 0), MINI_OP, "m.vpop" },
+  { SINST(XLU_EXT, DELEG_VPU, 0), MINI_OP, "m.vext" },
+};
