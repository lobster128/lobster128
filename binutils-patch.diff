diff --git a/bfd/Makefile.am b/bfd/Makefile.am
index 2fa8df45135..f294e2650d2 100644
--- a/bfd/Makefile.am
+++ b/bfd/Makefile.am
@@ -121,6 +121,7 @@ ALL_MACHINES = \
 	cpu-ia64.lo \
 	cpu-ip2k.lo \
 	cpu-iq2000.lo \
+	cpu-lobster128.lo \
 	cpu-lm32.lo \
 	cpu-loongarch.lo \
 	cpu-m10200.lo \
@@ -205,6 +206,7 @@ ALL_MACHINES_CFILES = \
 	cpu-ip2k.c \
 	cpu-iq2000.c \
 	cpu-lm32.c \
+	cpu-lobster128.c \
 	cpu-loongarch.c \
 	cpu-m10200.c \
 	cpu-m10300.c \
@@ -550,6 +552,7 @@ BFD64_BACKENDS = \
 	elf64-ia64.lo \
 	elf64-ia64-vms.lo \
 	elfxx-ia64.lo \
+	elf64-lobster128.lo \
 	elf32-loongarch.lo \
 	elf64-loongarch.lo \
 	elfxx-loongarch.lo \
@@ -611,6 +614,7 @@ BFD64_BACKENDS_CFILES = \
 	elfn32-mips.c \
 	elfxx-aarch64.c \
 	elfxx-ia64.c \
+	elf64-lobster128.c \
 	elfxx-loongarch.c \
 	elfxx-mips.c \
 	elfxx-riscv.c \
diff --git a/bfd/archures.c b/bfd/archures.c
index c67bacddfdc..87dc5728bc5 100644
--- a/bfd/archures.c
+++ b/bfd/archures.c
@@ -562,6 +562,8 @@ DESCRIPTION
 .#define bfd_mach_amdgcn_gfx1030 0x036
 .#define bfd_mach_amdgcn_gfx1031 0x037
 .#define bfd_mach_amdgcn_gfx1032 0x038
+.  bfd_arch_lobster128,      {* Lobster128 *}
+#define bfd_mach_lobster128 1
 .  bfd_arch_last
 .  };
 */
@@ -641,6 +643,7 @@ extern const bfd_arch_info_type bfd_ia64_arch;
 extern const bfd_arch_info_type bfd_ip2k_arch;
 extern const bfd_arch_info_type bfd_iq2000_arch;
 extern const bfd_arch_info_type bfd_lm32_arch;
+extern const bfd_arch_info_type bfd_lobster128_arch;
 extern const bfd_arch_info_type bfd_loongarch_arch;
 extern const bfd_arch_info_type bfd_m32c_arch;
 extern const bfd_arch_info_type bfd_m32r_arch;
@@ -729,6 +732,7 @@ static const bfd_arch_info_type * const bfd_archures_list[] =
     &bfd_ip2k_arch,
     &bfd_iq2000_arch,
     &bfd_lm32_arch,
+    &bfd_lobster128_arch,
     &bfd_loongarch_arch,
     &bfd_m32c_arch,
     &bfd_m32r_arch,
diff --git a/bfd/bfd-in2.h b/bfd/bfd-in2.h
index 6aefdd7cdb2..19d49ee01cc 100644
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -1880,6 +1880,8 @@ enum bfd_architecture
 #define bfd_mach_amdgcn_gfx1030 0x036
 #define bfd_mach_amdgcn_gfx1031 0x037
 #define bfd_mach_amdgcn_gfx1032 0x038
+  bfd_arch_lobster128,      /* Lobster128 */
+#define bfd_mach_lobster128   1
   bfd_arch_last
   };
 
diff --git a/bfd/config.bfd b/bfd/config.bfd
index 8c7be5da38a..b158d8110d7 100644
--- a/bfd/config.bfd
+++ b/bfd/config.bfd
@@ -798,6 +798,10 @@ case "${targ}" in
     targ_selvecs=lm32_elf32_vec
     ;;
 
+  lobster128-*-elf)
+    targ_defvec=lobster128_elf64_vec
+    ;;
+
   m32c-*-elf)
     targ_defvec=m32c_elf32_vec
     targ_underscore=yes
diff --git a/bfd/configure b/bfd/configure
index b5e44e6af79..925bbff4d78 100755
--- a/bfd/configure
+++ b/bfd/configure
@@ -13413,6 +13413,7 @@ do
     iq2000_elf32_vec)		 tb="$tb elf32-iq2000.lo elf32.lo $elf" ;;
     lm32_elf32_vec)		 tb="$tb elf32-lm32.lo elf32.lo $elf" ;;
     lm32_elf32_fdpic_vec)	 tb="$tb elf32-lm32.lo elf32.lo $elf" ;;
+    lobster128_elf64_vec)	 tb="$tb elf64-lobster128.lo elf64.lo $elf"; target_size=64 ;;
     loongarch_elf32_vec)	 tb="$tb elf32-loongarch.lo elfxx-loongarch.lo elf32.lo elf-ifunc.lo $elf" ;;
     loongarch_elf64_vec)	 tb="$tb elf64-loongarch.lo elf64.lo elfxx-loongarch.lo elf32.lo elf-ifunc.lo $elf"; target_size=64 ;;
     loongarch64_pei_vec)	 tb="$tb pei-loongarch64.lo pe-loongarch64igen.lo $coff"; target_size=64 ;;
diff --git a/bfd/configure.ac b/bfd/configure.ac
index fb8795bdffc..ec4723bd526 100644
--- a/bfd/configure.ac
+++ b/bfd/configure.ac
@@ -492,6 +492,7 @@ do
     iq2000_elf32_vec)		 tb="$tb elf32-iq2000.lo elf32.lo $elf" ;;
     lm32_elf32_vec)		 tb="$tb elf32-lm32.lo elf32.lo $elf" ;;
     lm32_elf32_fdpic_vec)	 tb="$tb elf32-lm32.lo elf32.lo $elf" ;;
+    lobster128_elf64_vec)	 tb="$tb elf64- lobster128.lo elf64.lo elf32.lo elf-ifunc.lo $elf"; target_size=64 ;;
     loongarch_elf32_vec)	 tb="$tb elf32-loongarch.lo elfxx-loongarch.lo elf32.lo elf-ifunc.lo $elf" ;;
     loongarch_elf64_vec)	 tb="$tb elf64-loongarch.lo elf64.lo elfxx-loongarch.lo elf32.lo elf-ifunc.lo $elf"; target_size=64 ;;
     loongarch64_pei_vec)	 tb="$tb pei-loongarch64.lo pe-loongarch64igen.lo $coff"; target_size=64 ;;
diff --git a/bfd/cpu-lobster128.c b/bfd/cpu-lobster128.c
new file mode 100644
index 00000000000..b19c97ea28b
--- /dev/null
+++ b/bfd/cpu-lobster128.c
@@ -0,0 +1,41 @@
+/* BFD support for LoongArch.
+   Copyright (C) 2021-2022 Free Software Foundation, Inc.
+   Contributed by Loongson Ltd.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING3.  If not,
+   see <http://www.gnu.org/licenses/>.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+
+const bfd_arch_info_type bfd_lobster128_arch =
+{
+  128,			/* Bits in a word.  */
+  64,				/* Bits in an address.  */
+  8,				/* Bits in a byte.  */
+  bfd_arch_lobster128,		/* Architecture.  */
+  bfd_mach_lobster128, 	/* Machine number - 0 for now.  */
+  "lobster128",		/* Architecture name.  */
+  "Lobster128",		/* Printable name.  */
+  6,				/* Section align power.  */
+  true,			/* This is the default architecture.  */
+  bfd_default_compatible,	/* Architecture comparison function.  */
+  bfd_default_scan,		/* String to architecture conversion.  */
+  bfd_arch_default_fill,	/* Default fill.  */
+  NULL, 			/* Next in list.  */
+  0,          /* Maximum offset of a reloc from the start of an insn.  */
+};
diff --git a/bfd/elf64-lobster128.c b/bfd/elf64-lobster128.c
new file mode 100644
index 00000000000..1174deac998
--- /dev/null
+++ b/bfd/elf64-lobster128.c
@@ -0,0 +1,318 @@
+/* lobster128-specific support for 32-bit ELF.
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   Copied from elf32-fr30.c which is..
+   Copyright (C) 1998-2022 Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "elf/lobster128.h"
+
+/* Forward declarations.  */
+
+static reloc_howto_type lobster128_elf_howto_table[] =
+{
+  /* This reloc does nothing.  */
+  HOWTO(R_LOBSTER128_NONE,      /* type */
+        0,                      /* rightshift */
+        0,                      /* size */
+        0,                      /* bitsize */
+        false,                  /* pc_relative */
+        0,                      /* bitpos */
+        complain_overflow_dont, /* complain_on_overflow */
+        bfd_elf_generic_reloc,  /* special_function */
+        "R_LOBSTER128_NONE",    /* name */
+        false,                  /* partial_inplace */
+        0,                      /* src_mask */
+        0,                      /* dst_mask */
+        false),                 /* pcrel_offset */
+};
+
+/* Map BFD reloc types to LOBSTER128 ELF reloc types.  */
+
+struct lobster128_reloc_map
+{
+  bfd_reloc_code_real_type bfd_reloc_val;
+  unsigned int lobster128_reloc_val;
+};
+
+static const struct lobster128_reloc_map lobster128_reloc_map[] = {
+  {BFD_RELOC_NONE, R_LOBSTER128_NONE},
+};
+
+static reloc_howto_type *
+lobster128_reloc_type_lookup(bfd *abfd ATTRIBUTE_UNUSED,
+                             bfd_reloc_code_real_type code)
+{
+  unsigned int i;
+  for (i = sizeof(lobster128_reloc_map) / sizeof(lobster128_reloc_map[0]); i--; )
+    if (lobster128_reloc_map[i].bfd_reloc_val == code)
+      return &lobster128_elf_howto_table[lobster128_reloc_map[i].lobster128_reloc_val];
+  return NULL;
+}
+
+static reloc_howto_type *
+lobster128_reloc_name_lookup(bfd *abfd ATTRIBUTE_UNUSED, const char *r_name)
+{
+  unsigned int i;
+  for (i = 0; i < sizeof(lobster128_elf_howto_table) / sizeof(lobster128_elf_howto_table[0]); i++)
+    if (lobster128_elf_howto_table[i].name != NULL && strcasecmp(lobster128_elf_howto_table[i].name, r_name) == 0)
+      return &lobster128_elf_howto_table[i];
+  return NULL;
+}
+
+/* Set the howto pointer for an LOBSTER128 ELF reloc.  */
+
+static bool
+lobster128_info_to_howto_rela(bfd *abfd,
+                              arelent *cache_ptr,
+                              Elf_Internal_Rela *dst)
+{
+  unsigned int r_type = ELF32_R_TYPE(dst->r_info);
+  if (r_type >= (unsigned int)R_LOBSTER128_max)
+  {
+    /* xgettext:c-format */
+    _bfd_error_handler(_("%pB: unsupported relocation type %#x"),
+                       abfd, r_type);
+    bfd_set_error(bfd_error_bad_value);
+    return false;
+  }
+  cache_ptr->howto = &lobster128_elf_howto_table[r_type];
+  return true;
+}
+
+/* Perform a single relocation.  By default we use the standard BFD
+   routines, but a few relocs, we have to do them ourselves.  */
+
+static bfd_reloc_status_type
+lobster128_final_link_relocate(reloc_howto_type *howto,
+                               bfd *input_bfd,
+                               asection *input_section,
+                               bfd_byte *contents,
+                               Elf_Internal_Rela *rel,
+                               bfd_vma relocation)
+{
+  bfd_reloc_status_type r = bfd_reloc_ok;
+  switch (howto->type)
+  {
+  default:
+    r = _bfd_final_link_relocate(howto, input_bfd, input_section,
+                                 contents, rel->r_offset,
+                                 relocation, rel->r_addend);
+  }
+  return r;
+}
+
+/* Relocate an LOBSTER128 ELF section.
+
+   The RELOCATE_SECTION function is called by the new ELF backend linker
+   to handle the relocations for a section.
+
+   The relocs are always passed as Rela structures; if the section
+   actually uses Rel structures, the r_addend field will always be
+   zero.
+
+   This function is responsible for adjusting the section contents as
+   necessary, and (if using Rela relocs and generating a relocatable
+   output file) adjusting the reloc addend as necessary.
+
+   This function does not have to worry about setting the reloc
+   address or the reloc symbol index.
+
+   LOCAL_SYMS is a pointer to the swapped in local symbols.
+
+   LOCAL_SECTIONS is an array giving the section in the input file
+   corresponding to the st_shndx field of each local symbol.
+
+   The global hash table entry for the global symbols can be found
+   via elf_sym_hashes (input_bfd).
+
+   When generating relocatable output, this function must handle
+   STB_LOCAL/STT_SECTION symbols specially.  The output symbol is
+   going to be the section symbol corresponding to the output
+   section, which means that the addend must be adjusted
+   accordingly.  */
+
+static int
+lobster128_elf_relocate_section(bfd *output_bfd,
+                                struct bfd_link_info *info,
+                                bfd *input_bfd,
+                                asection *input_section,
+                                bfd_byte *contents,
+                                Elf_Internal_Rela *relocs,
+                                Elf_Internal_Sym *local_syms,
+                                asection **local_sections)
+{
+  struct elf_link_hash_entry **sym_hashes;
+  Elf_Internal_Shdr *symtab_hdr = &elf_tdata(input_bfd)->symtab_hdr;
+  Elf_Internal_Rela *relend = relocs + input_section->reloc_count;
+  Elf_Internal_Rela *rel;
+
+  sym_hashes = elf_sym_hashes(input_bfd);
+
+  for (rel = relocs; rel < relend; rel++)
+  {
+    int r_type = ELF32_R_TYPE(rel->r_info);
+    unsigned long r_symndx = ELF32_R_SYM(rel->r_info);
+    reloc_howto_type *howto = lobster128_elf_howto_table + r_type;
+    struct elf_link_hash_entry *h = NULL;
+    Elf_Internal_Sym *sym = NULL;
+    asection *sec = NULL;
+    bfd_vma relocation;
+    bfd_reloc_status_type r;
+    const char *name;
+
+    if (r_symndx < symtab_hdr->sh_info)
+    {
+      sym = local_syms + r_symndx;
+      sec = local_sections[r_symndx];
+      relocation = _bfd_elf_rela_local_sym(output_bfd, sym, &sec, rel);
+
+      name = bfd_elf_string_from_elf_section(input_bfd, symtab_hdr->sh_link, sym->st_name);
+      name = name == NULL ? bfd_section_name(sec) : name;
+    }
+    else
+    {
+      bool unresolved_reloc, warned, ignored;
+
+      RELOC_FOR_GLOBAL_SYMBOL(info, input_bfd, input_section, rel,
+                              r_symndx, symtab_hdr, sym_hashes,
+                              h, sec, relocation,
+                              unresolved_reloc, warned, ignored);
+
+      name = h->root.root.string;
+    }
+
+    if (sec != NULL && discarded_section(sec))
+      RELOC_AGAINST_DISCARDED_SECTION(info, input_bfd, input_section,
+                                      rel, 1, relend, howto, 0, contents);
+
+    if (bfd_link_relocatable(info))
+      continue;
+
+    r = lobster128_final_link_relocate(howto, input_bfd, input_section,
+                                       contents, rel, relocation);
+    if (r != bfd_reloc_ok)
+    {
+      const char *msg = NULL;
+      switch (r)
+      {
+      case bfd_reloc_overflow:
+        (*info->callbacks->reloc_overflow)(info, (h ? &h->root : NULL), name, howto->name,
+                                           (bfd_vma)0, input_bfd, input_section, rel->r_offset);
+        break;
+      case bfd_reloc_undefined:
+        (*info->callbacks->undefined_symbol)(info, name, input_bfd, input_section, rel->r_offset, true);
+        break;
+      case bfd_reloc_outofrange:
+        msg = _("internal error: out of range error");
+        break;
+      case bfd_reloc_notsupported:
+        msg = _("internal error: unsupported relocation error");
+        break;
+      case bfd_reloc_dangerous:
+        msg = _("internal error: dangerous relocation");
+        break;
+      default:
+        msg = _("internal error: unknown error");
+        break;
+      }
+
+      if (msg)
+        (*info->callbacks->warning)(info, msg, name, input_bfd,
+                                    input_section, rel->r_offset);
+    }
+  }
+  return true;
+}
+
+/* Return the section that should be marked against GC for a given
+   relocation.  */
+
+static asection *
+lobster128_elf_gc_mark_hook(asection *sec,
+                            struct bfd_link_info *info,
+                            Elf_Internal_Rela *rel,
+                            struct elf_link_hash_entry *h,
+                            Elf_Internal_Sym *sym)
+{
+  return _bfd_elf_gc_mark_hook(sec, info, rel, h, sym);
+}
+
+/* Look through the relocs for a section during the first phase.
+   Since we don't do .gots or .plts, we just need to consider the
+   virtual table relocs for gc.  */
+
+static bool
+lobster128_elf_check_relocs(bfd *abfd,
+                            struct bfd_link_info *info,
+                            asection *sec,
+                            const Elf_Internal_Rela *relocs)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  const Elf_Internal_Rela *rel;
+  const Elf_Internal_Rela *rel_end;
+
+  if (bfd_link_relocatable(info))
+    return true;
+
+  symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes(abfd);
+
+  rel_end = relocs + sec->reloc_count;
+  for (rel = relocs; rel < rel_end; rel++)
+  {
+    struct elf_link_hash_entry *h;
+    unsigned long r_symndx = ELF32_R_SYM(rel->r_info);
+    if (r_symndx < symtab_hdr->sh_info)
+      h = NULL;
+    else
+    {
+      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+      while (h->root.type == bfd_link_hash_indirect || h->root.type == bfd_link_hash_warning)
+        h = (struct elf_link_hash_entry *)h->root.u.i.link;
+    }
+  }
+  return true;
+}
+
+#define ELF_ARCH bfd_arch_lobster128
+#define ELF_MACHINE_CODE EM_LOBSTER128
+#define ELF_MAXPAGESIZE 1
+
+#define TARGET_LITTLE_SYM lobster128_elf64_vec
+#define TARGET_LITTLE_NAME "elf64-lobster128"
+
+#define elf_info_to_howto_rel NULL
+#define elf_info_to_howto lobster128_info_to_howto_rela
+#define elf_backend_relocate_section lobster128_elf_relocate_section
+#define elf_backend_gc_mark_hook lobster128_elf_gc_mark_hook
+#define elf_backend_check_relocs lobster128_elf_check_relocs
+
+#define elf_backend_can_gc_sections 1
+#define elf_backend_rela_normal 1
+
+#define bfd_elf64_bfd_reloc_type_lookup lobster128_reloc_type_lookup
+#define bfd_elf64_bfd_reloc_name_lookup lobster128_reloc_name_lookup
+
+#include "elf64-target.h"
diff --git a/bfd/targets.c b/bfd/targets.c
index 8ad3ef366ce..77ed21b4373 100644
--- a/bfd/targets.c
+++ b/bfd/targets.c
@@ -766,6 +766,7 @@ extern const bfd_target ip2k_elf32_vec;
 extern const bfd_target iq2000_elf32_vec;
 extern const bfd_target lm32_elf32_vec;
 extern const bfd_target lm32_elf32_fdpic_vec;
+extern const bfd_target lobster128_elf64_vec;
 extern const bfd_target loongarch_elf64_vec;
 extern const bfd_target loongarch_elf32_vec;
 extern const bfd_target loongarch64_pei_vec;
@@ -1357,6 +1358,7 @@ static const bfd_target * const _bfd_target_vector[] =
 	&z8k_coff_vec,
 
 #ifdef BFD64
+	&lobster128_elf64_vec,
 	&loongarch_elf32_vec,
 	&loongarch_elf64_vec,
 	&loongarch64_pei_vec,
diff --git a/config.sub b/config.sub
index dba16e84c77..859f91fb75e 100755
--- a/config.sub
+++ b/config.sub
@@ -1207,6 +1207,7 @@ case $cpu-$vendor in
 			| k1om \
 			| le32 | le64 \
 			| lm32 \
+			| lobster128 \
 			| loongarch32 | loongarch64 | loongarchx32 \
 			| m32c | m32r | m32rle \
 			| m5200 | m68000 | m680[012346]0 | m68360 | m683?2 | m68k \
diff --git a/configure b/configure
index 16139e3bfa3..e6a5b430413 100755
--- a/configure
+++ b/configure
@@ -3856,6 +3856,9 @@ case "${target}" in
   i[3456789]86-*-rdos*)
     noconfigdirs="$noconfigdirs gdb"
     ;;
+  lobster128-*-*)
+    noconfigdirs="$noconfigdirs"
+    ;;
   mmix-*-*)
     noconfigdirs="$noconfigdirs gdb"
     ;;
diff --git a/gas/Makefile.am b/gas/Makefile.am
index bd597398671..3756714703a 100644
--- a/gas/Makefile.am
+++ b/gas/Makefile.am
@@ -156,6 +156,7 @@ TARGET_CPU_CFILES = \
 	config/tc-ip2k.c \
 	config/tc-iq2000.c \
 	config/tc-lm32.c \
+	config/tc-lobster128.c \
 	config/tc-loongarch.c \
 	config/tc-m32c.c \
 	config/tc-m32r.c \
diff --git a/gas/Makefile.in b/gas/Makefile.in
index c57d78f82c4..f5c07c6c463 100644
--- a/gas/Makefile.in
+++ b/gas/Makefile.in
@@ -634,6 +634,7 @@ TARGET_CPU_CFILES = \
 	config/tc-ip2k.c \
 	config/tc-iq2000.c \
 	config/tc-lm32.c \
+	config/tc-lobster128.c \
 	config/tc-loongarch.c \
 	config/tc-m32c.c \
 	config/tc-m32r.c \
@@ -1113,6 +1114,8 @@ config/tc-iq2000.$(OBJEXT): config/$(am__dirstamp) \
 	config/$(DEPDIR)/$(am__dirstamp)
 config/tc-lm32.$(OBJEXT): config/$(am__dirstamp) \
 	config/$(DEPDIR)/$(am__dirstamp)
+config/tc-lobster128.$(OBJEXT): config/$(am__dirstamp) \
+	config/$(DEPDIR)/$(am__dirstamp)
 config/tc-loongarch.$(OBJEXT): config/$(am__dirstamp) \
 	config/$(DEPDIR)/$(am__dirstamp)
 config/tc-m32c.$(OBJEXT): config/$(am__dirstamp) \
@@ -1363,6 +1366,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-ip2k.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-iq2000.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-lm32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-lobster128.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-loongarch.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-m32c.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-m32r.Po@am__quote@
diff --git a/gas/config/tc-lobster128.c b/gas/config/tc-lobster128.c
new file mode 100644
index 00000000000..cb671956705
--- /dev/null
+++ b/gas/config/tc-lobster128.c
@@ -0,0 +1,377 @@
+/* tc-lobster128.c -- Assemble code for lobster128
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to
+   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+#include "as.h"
+#include "safe-ctype.h"
+#include "opcode/lobster128.h"
+#include "elf/lobster128.h"
+
+extern const lobster128_opc_info_t lobster128_opc_info[LOBSTER128_NUM_OPCODES];
+
+const char comment_chars[] = "#";
+const char line_separator_chars[] = ";";
+const char line_comment_chars[] = "#";
+
+static int pending_reloc;
+static htab_t opcode_hash_control;
+
+const pseudo_typeS md_pseudo_table[] =
+    {
+        {0, 0, 0}};
+
+const char FLT_CHARS[] = "rRsSfFdDxXpP";
+const char EXP_CHARS[] = "eE";
+
+static valueT md_chars_to_number(char *buf, int n);
+
+void md_operand(expressionS *op __attribute__((unused)))
+{
+  /* Empty for now. */
+}
+
+/* This function is called once, at assembler startup time.  It sets
+   up the hash table with all the opcodes in it, and also initializes
+   some aliases for compatibility with other assemblers.  */
+
+void md_begin(void)
+{
+  int count;
+  const lobster128_opc_info_t *opcode;
+  opcode_hash_control = str_htab_create();
+
+  /* Insert names into hash table.  */
+  for (count = 0, opcode = lobster128_opc_info; count++ < LOBSTER128_NUM_OPCODES; opcode++)
+    str_hash_insert(opcode_hash_control, opcode->name, opcode, 0);
+
+  bfd_set_arch_mach(stdoutput, TARGET_ARCH, 0);
+}
+
+/* Parse an expression and then restore the input line pointer.  */
+
+static char *
+parse_exp_save_ilp(char *s, expressionS *op)
+{
+  char *save = input_line_pointer;
+
+  input_line_pointer = s;
+  expression(op);
+  s = input_line_pointer;
+  input_line_pointer = save;
+  return s;
+}
+
+static int
+parse_register_operand(char **ptr)
+{
+  int reg;
+  char *s = *ptr;
+  
+  if (s[0] == 'z' && s[1] == 'e' && s[2] == 'r' && s[3] == 'o')
+  {
+    *ptr += 4;
+    return 0;
+  }
+  if (s[0] == 'p' && s[1] == 'c')
+  {
+    *ptr += 2;
+    return 1;
+  }
+  if (s[0] == 'r' || s[0] == 'R')
+  {
+    *ptr += 1;
+    reg = atoi(&s[1]);
+    if ((reg < 0) || (reg > 128))
+    {
+      as_bad(_("illegal register number"));
+      ignore_rest_of_line();
+      return -1;
+    }
+
+    /* Skip digit from the register */
+    while(ISDIGIT(**ptr))
+      *ptr += 1;
+  }
+  else
+  {
+    as_bad(_("illegal register number"));
+    ignore_rest_of_line();
+    return -1;
+  }
+  return reg;
+}
+
+/* This is the guts of the machine-dependent assembler.  STR points to
+   a machine dependent instruction.  This function is supposed to emit
+   the frags/bytes it assembles to.  */
+
+void md_assemble(char *str)
+{
+  char *op_end;
+
+  /* Drop leading whitespace.  */
+  while (*str == ' ')
+    str++;
+
+  /* Find the op code end.  */
+  char *op_start = str;
+  int nlen = 0;
+  for (op_end = str; *op_end && !is_end_of_line[*op_end & 0xff] && *op_end != ' '; op_end++)
+    nlen++;
+
+  char pend = *op_end;
+  *op_end = 0;
+
+  if (nlen == 0)
+    as_bad(_("can't find opcode "));
+  lobster128_opc_info_t *opcode = (lobster128_opc_info_t *)str_hash_find(opcode_hash_control, op_start);
+  *op_end = pend;
+
+  if (opcode == NULL)
+  {
+    as_bad(_("unknown opcode %s"), op_start);
+    return;
+  }
+
+  /* Instructions for the lobtser128 architecture can vary from 16-bits,
+     or 32-bits and can extend up until 128-bit instruction colossus */
+  if (opcode->type == LOBSTER128_MICRO_OP) {
+    /* Micro ops have 16-bits each and can only operate on registers
+       r0 to r63, for both destination and source, they also have to be
+       aligned */
+    /* TODO: Enforce alignment requirements/emit a warn about said alignment */
+    char *p = frag_more(2);
+    unsigned short iword = opcode->opcode;
+    while (ISSPACE(*op_end))
+      op_end++;
+
+    /* Obtain registers */
+    int rd = parse_register_operand(&op_end);
+    if (*op_end != ',')
+      as_warn(_("expecting comma delimited register operands"));
+    op_end++;
+    int rs = parse_register_operand(&op_end);
+
+    if(rd >= 0x20 || rs >= 0x20)
+      as_bad(_("register is out of scope for micro-instruction"));
+
+    iword |= ((rs << 5) | rd) << 6; /* 4bits op, 2bit prefix */
+    while (ISSPACE(*op_end))
+      op_end++;
+    if (*op_end != 0)
+      as_warn(_("extra stuff on line ignored"));
+    
+    md_number_to_chars(p, iword, 2);
+    dwarf2_emit_insn(2);
+  } else {
+    abort();
+  }
+
+  while (ISSPACE(*op_end))
+    op_end++;
+
+  if (*op_end != 0)
+    as_warn(_("extra stuff on line ignored"));
+
+  if (pending_reloc)
+    as_bad(_("Something forgot to clean up\n"));
+}
+
+/* Turn a string in input_line_pointer into a floating point constant
+   of type type, and store the appropriate bytes in *LITP.  The number
+   of LITTLENUMS emitted is stored in *SIZEP .  An error message is
+   returned, or NULL on OK.  */
+const char *
+md_atof(int type, char *litP, int *sizeP)
+{
+  int prec;
+  LITTLENUM_TYPE words[4];
+  char *t;
+  int i;
+
+  switch (type)
+  {
+  case 'f':
+    prec = 2;
+    break;
+
+  case 'd':
+    prec = 4;
+    break;
+
+  default:
+    *sizeP = 0;
+    return _("bad call to md_atof");
+  }
+
+  t = atof_ieee(input_line_pointer, type, words);
+  if (t)
+    input_line_pointer = t;
+
+  *sizeP = prec * 2;
+  for (i = prec - 1; i >= 0; i--)
+  {
+    md_number_to_chars(litP, (valueT)words[i], 2);
+    litP += 2;
+  }
+  return NULL;
+}
+
+
+/* Apply a fixup to the object file.  */
+void md_apply_fix(fixS *fixP ATTRIBUTE_UNUSED,
+                  valueT *valP ATTRIBUTE_UNUSED, segT seg ATTRIBUTE_UNUSED)
+{
+  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
+  long val = *valP;
+  long min = 0, max = 0;
+  switch (fixP->fx_r_type)
+  {
+  case BFD_RELOC_32:
+    buf[3] = val >> 24;
+    buf[2] = val >> 16;
+    buf[1] = val >> 8;
+    buf[0] = val >> 0;
+    buf += 4;
+    break;
+  case BFD_RELOC_16:
+    buf[1] = val >> 8;
+    buf[0] = val >> 0;
+    buf += 2;
+    break;
+  case BFD_RELOC_8:
+    *buf++ = val;
+    break;
+  default:
+    abort();
+  }
+
+  if (max != 0 && (val < min || val > max))
+    as_bad_where(fixP->fx_file, fixP->fx_line, _("offset out of range"));
+
+  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
+    fixP->fx_done = 1;
+}
+
+/* Put number into target byte order.  */
+
+void md_number_to_chars(char *ptr, valueT use, int nbytes)
+{
+  number_to_chars_littleendian(ptr, use, nbytes);
+}
+
+/* Generate a machine-dependent relocation.  */
+arelent *
+tc_gen_reloc(asection *section ATTRIBUTE_UNUSED, fixS *fixP)
+{
+  bfd_reloc_code_real_type code;
+  switch (fixP->fx_r_type)
+  {
+  case BFD_RELOC_32:
+    code = fixP->fx_r_type;
+    break;
+  default:
+    as_bad_where(fixP->fx_file, fixP->fx_line,
+                 _("Semantics error.  This type of operand can not be relocated, it must be an assembly-time constant"));
+    return 0;
+  }
+
+  arelent *relP = XNEW(arelent);
+  relP->sym_ptr_ptr = XNEW(asymbol *);
+  *relP->sym_ptr_ptr = symbol_get_bfdsym(fixP->fx_addsy);
+  relP->address = fixP->fx_frag->fr_address + fixP->fx_where;
+
+  relP->addend = fixP->fx_offset;
+
+  /* This is the standard place for KLUDGEs to work around bugs in
+     bfd_install_relocation (first such note in the documentation
+     appears with binutils-2.8).
+
+     That function bfd_install_relocation does the wrong thing with
+     putting stuff into the addend of a reloc (it should stay out) for a
+     weak symbol.  The really bad thing is that it adds the
+     "segment-relative offset" of the symbol into the reloc.  In this
+     case, the reloc should instead be relative to the symbol with no
+     other offset than the assembly code shows; and since the symbol is
+     weak, any local definition should be ignored until link time (or
+     thereafter).
+     To wit:  weaksym+42  should be weaksym+42 in the reloc,
+     not weaksym+(offset_from_segment_of_local_weaksym_definition)
+
+     To "work around" this, we subtract the segment-relative offset of
+     "known" weak symbols.  This evens out the extra offset.
+
+     That happens for a.out but not for ELF, since for ELF,
+     bfd_install_relocation uses the "special function" field of the
+     howto, and does not execute the code that needs to be undone.  */
+  if (OUTPUT_FLAVOR == bfd_target_aout_flavour && fixP->fx_addsy && S_IS_WEAK(fixP->fx_addsy) && !bfd_is_und_section(S_GET_SEGMENT(fixP->fx_addsy)))
+  {
+    relP->addend -= S_GET_VALUE(fixP->fx_addsy);
+  }
+
+  relP->howto = bfd_reloc_type_lookup(stdoutput, code);
+  if (!relP->howto)
+  {
+    const char *name;
+
+    name = S_GET_NAME(fixP->fx_addsy);
+    if (name == NULL)
+      name = _("<unknown>");
+    as_fatal(_("Cannot generate relocation type for symbol %s, code %s"),
+             name, bfd_get_reloc_code_name(code));
+  }
+
+  return relP;
+}
+
+/* Decide from what point a pc-relative relocation is relative to,
+   relative to the pc-relative fixup.  Er, relatively speaking.  */
+long md_pcrel_from(fixS *fixP)
+{
+  valueT addr = fixP->fx_where + fixP->fx_frag->fr_address;
+
+  switch (fixP->fx_r_type)
+  {
+  case BFD_RELOC_32:
+    return addr + 4;
+  default:
+    abort();
+    return addr;
+  }
+}
+
+struct option md_longopts[] =
+{
+  { NULL,          no_argument, NULL, 0}
+};
+
+size_t md_longopts_size = sizeof (md_longopts);
+const char *md_shortopts = "";
+
+void
+md_show_usage (FILE *stream ATTRIBUTE_UNUSED)
+{
+
+}
+
+int
+md_parse_option (int c ATTRIBUTE_UNUSED, const char *arg ATTRIBUTE_UNUSED)
+{
+
+}
diff --git a/gas/config/tc-lobster128.h b/gas/config/tc-lobster128.h
new file mode 100644
index 00000000000..661a4bbc31c
--- /dev/null
+++ b/gas/config/tc-lobster128.h
@@ -0,0 +1,38 @@
+/* tc-lobster128.h -- Header file for tc-lobster128.c.
+
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with GAS; see the file COPYING.  If not, write to the Free Software
+   Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#define TC_LOBSTER128 1
+#ifndef TARGET_BYTES_LITTLE_ENDIAN
+#define TARGET_BYTES_LITTLE_ENDIAN 1
+#endif
+#define WORKING_DOT_WORD
+
+/* This macro is the BFD architecture to pass to `bfd_set_arch_mach'.  */
+#define TARGET_FORMAT "elf64-lobster128"
+#define TARGET_ARCH bfd_arch_lobster128
+
+#define md_undefined_symbol(NAME)           0
+
+/* These macros must be defined, but is will be a fatal assembler
+   error if we ever hit them.  */
+#define md_estimate_size_before_relax(A, B) (as_fatal (_("estimate size\n")), 0)
+#define md_convert_frag(B, S, F)            as_fatal (_("convert_frag\n"))
+
+#define md_section_align(SEGMENT, SIZE)     (SIZE)
diff --git a/gas/configure.tgt b/gas/configure.tgt
index 62f806bdfe8..aa505962788 100644
--- a/gas/configure.tgt
+++ b/gas/configure.tgt
@@ -278,6 +278,8 @@ case ${generic_target} in
   iq2000-*-elf)				fmt=elf ;;
 
   lm32-*-*)				fmt=elf ;;
+  
+  lobster128-*-*)				fmt=elf endian=little ;;
 
   loongarch*)				fmt=elf ;;
 
diff --git a/include/elf/common.h b/include/elf/common.h
index ebcd8f9e82c..ff8ccbc930f 100644
--- a/include/elf/common.h
+++ b/include/elf/common.h
@@ -360,6 +360,7 @@
 #define EM_U16_U8CORE	260	/* LAPIS nX-U16/U8 */
 #define EM_TACHYUM	261	/* Tachyum */
 #define EM_56800EF	262	/* NXP 56800EF Digital Signal Controller (DSC) */
+#define EM_LOBSTER128 263  /* Lobster128 */
 
 /* If it is necessary to assign new unofficial EM_* values, please pick large
    random numbers (0x8523, 0xa7f2, etc.) to minimize the chances of collision
diff --git a/include/elf/lobster128.h b/include/elf/lobster128.h
new file mode 100644
index 00000000000..2c000132937
--- /dev/null
+++ b/include/elf/lobster128.h
@@ -0,0 +1,30 @@
+/* lobster128 ELF support for BFD.
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _ELF_LOBSTER128_H
+#define _ELF_LOBSTER128_H
+
+#include "elf/reloc-macros.h"
+
+/* Relocation types.  */
+START_RELOC_NUMBERS (elf_lobster128_reloc_type)
+  RELOC_NUMBER (R_LOBSTER128_NONE, 0)
+END_RELOC_NUMBERS (R_LOBSTER128_max)
+
+#endif /* _ELF_LOBSTER128_H */
diff --git a/include/opcode/lobster128.h b/include/opcode/lobster128.h
new file mode 100644
index 00000000000..cfb096a22ef
--- /dev/null
+++ b/include/opcode/lobster128.h
@@ -0,0 +1,55 @@
+/* Definitions for decoding the lobster128 opcode table.
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#define PREFIX_MICROINST  0b00
+#define PREFIX_LONGINST   0b01
+#define PREFIX_REP        0b11
+
+#define XLU_ADD   0b0000
+#define XLU_SUB   0b0001
+#define XLU_AND   0b0010
+#define XLU_NOT   0b0011
+#define XLU_LSH   0b0100
+#define XLU_RSH   0b0101
+#define XLU_OR    0b0110
+#define XLU_XOR   0b0111
+#define XLU_MUL   0b1000
+#define XLU_DIV   0b1001
+#define XLU_REM   0b1011
+#define XLU_SEX   0b1100
+#define XLU_PUSH  0b1101
+#define XLU_POP   0b1110
+#define XLU_EXT   0b1111
+
+typedef enum lobster128_opc_type_t
+{
+  LOBSTER128_MICRO_OP, /* 16-bits */
+  LOBSTER128_MINI_OP, /* 32-bits */
+  LOBSTER128_MACRO_OP, /* 64-bits */
+} lobster128_opc_type_t;
+
+typedef struct lobster128_opc_info_t
+{
+  long long             opcode;
+  long long             opcode2; /* For lengthy VLIW opcodes */
+  lobster128_opc_type_t type;
+  const char *          name;
+} lobster128_opc_info_t;
+
+#define LOBSTER128_NUM_OPCODES 15
+extern const lobster128_opc_info_t lobster128_opc_info[LOBSTER128_NUM_OPCODES];
diff --git a/ld/Makefile.am b/ld/Makefile.am
index d31021c13e2..b0b290c3c3e 100644
--- a/ld/Makefile.am
+++ b/ld/Makefile.am
@@ -440,6 +440,7 @@ ALL_64_EMULATION_SOURCES = \
 	eelf64loongarch.c \
 	eelf64lppc.c \
 	eelf64lppc_fbsd.c \
+	eelf64lobster128.c \
 	eelf64lriscv.c \
 	eelf64lriscv_lp64.c \
 	eelf64lriscv_lp64f.c \
@@ -933,6 +934,7 @@ $(ALL_EMULATION_SOURCES) $(ALL_64_EMULATION_SOURCES): $(GEN_DEPENDS)
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lriscv_lp64f.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64ltsmip.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64ltsmip_fbsd.Pc@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lobster128.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64mmix.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64ppc.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64ppc_fbsd.Pc@am__quote@
diff --git a/ld/Makefile.in b/ld/Makefile.in
index ee0c98f65b0..74f0f72bf51 100644
--- a/ld/Makefile.in
+++ b/ld/Makefile.in
@@ -941,6 +941,7 @@ ALL_64_EMULATION_SOURCES = \
 	eelf64lriscv_lp64f.c \
 	eelf64ltsmip.c \
 	eelf64ltsmip_fbsd.c \
+	eelf64lobster128.c \
 	eelf64mmix.c \
 	eelf64ppc.c \
 	eelf64ppc_fbsd.c \
@@ -1434,6 +1435,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lriscv_lp64f.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64ltsmip.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64ltsmip_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lobster128.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64mmix.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64ppc.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64ppc_fbsd.Po@am__quote@
diff --git a/ld/configure.tgt b/ld/configure.tgt
index 2bae9099b6a..6f848af0935 100644
--- a/ld/configure.tgt
+++ b/ld/configure.tgt
@@ -473,6 +473,8 @@ lm32-*-*linux*)		targ_emul=elf32lm32fd
 lm32-*-*)		targ_emul=elf32lm32
 			targ_extra_emuls="elf32lm32fd"
 			;;
+lobster128-*-*)		targ_emul=elf64lobster128
+			;;
 m32c-*-elf)
 			targ_emul=elf32m32c
 			;;
diff --git a/ld/emulparams/elf64lobster128.sh b/ld/emulparams/elf64lobster128.sh
new file mode 100644
index 00000000000..cc08734809d
--- /dev/null
+++ b/ld/emulparams/elf64lobster128.sh
@@ -0,0 +1,6 @@
+SCRIPT_NAME=elf
+TEMPLATE_NAME=elf
+OUTPUT_FORMAT="elf64-lobster128"
+MAXPAGESIZE="CONSTANT (MAXPAGESIZE)"
+ARCH=lobster128
+EMBEDDED=yes
diff --git a/opcodes/Makefile.am b/opcodes/Makefile.am
index 87be5e7edb2..d733ddbe46c 100644
--- a/opcodes/Makefile.am
+++ b/opcodes/Makefile.am
@@ -173,6 +173,9 @@ TARGET32_LIBOPCODES_CFILES = \
 	iq2000-dis.c \
 	iq2000-ibld.c \
 	iq2000-opc.c \
+	lobster128-asm.c \
+	lobster128-dis.c \
+	lobster128-opc.c \
 	lm32-asm.c \
 	lm32-desc.c \
 	lm32-dis.c \
diff --git a/opcodes/Makefile.in b/opcodes/Makefile.in
index 581747edb7b..925594af22e 100644
--- a/opcodes/Makefile.in
+++ b/opcodes/Makefile.in
@@ -565,6 +565,9 @@ TARGET32_LIBOPCODES_CFILES = \
 	iq2000-dis.c \
 	iq2000-ibld.c \
 	iq2000-opc.c \
+	lobster128-asm.c \
+	lobster128-dis.c \
+	lobster128-opc.c \
 	lm32-asm.c \
 	lm32-desc.c \
 	lm32-dis.c \
diff --git a/opcodes/configure b/opcodes/configure
index a5951b9b362..4f17dc055bd 100755
--- a/opcodes/configure
+++ b/opcodes/configure
@@ -12521,6 +12521,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_ip2k_arch)		ta="$ta ip2k-asm.lo ip2k-desc.lo ip2k-dis.lo ip2k-ibld.lo ip2k-opc.lo" using_cgen=yes ;;
 	bfd_epiphany_arch)	ta="$ta epiphany-asm.lo epiphany-desc.lo epiphany-dis.lo epiphany-ibld.lo epiphany-opc.lo" using_cgen=yes ;;
 	bfd_iq2000_arch)	ta="$ta iq2000-asm.lo iq2000-desc.lo iq2000-dis.lo iq2000-ibld.lo iq2000-opc.lo" using_cgen=yes ;;
+  bfd_lobster128_arch) ta="$ta lobster128-dis.lo lobster128-opc.lo" ;;
 	bfd_lm32_arch)		ta="$ta lm32-asm.lo lm32-desc.lo lm32-dis.lo lm32-ibld.lo lm32-opc.lo lm32-opinst.lo" using_cgen=yes ;;
 	bfd_m32c_arch)		ta="$ta m32c-asm.lo m32c-desc.lo m32c-dis.lo m32c-ibld.lo m32c-opc.lo" using_cgen=yes ;;
 	bfd_m32r_arch)		ta="$ta m32r-asm.lo m32r-desc.lo m32r-dis.lo m32r-ibld.lo m32r-opc.lo m32r-opinst.lo" using_cgen=yes ;;
diff --git a/opcodes/configure.ac b/opcodes/configure.ac
index e998d613436..653f4318f27 100644
--- a/opcodes/configure.ac
+++ b/opcodes/configure.ac
@@ -287,6 +287,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_ip2k_arch)		ta="$ta ip2k-asm.lo ip2k-desc.lo ip2k-dis.lo ip2k-ibld.lo ip2k-opc.lo" using_cgen=yes ;;
 	bfd_epiphany_arch)	ta="$ta epiphany-asm.lo epiphany-desc.lo epiphany-dis.lo epiphany-ibld.lo epiphany-opc.lo" using_cgen=yes ;;
 	bfd_iq2000_arch)	ta="$ta iq2000-asm.lo iq2000-desc.lo iq2000-dis.lo iq2000-ibld.lo iq2000-opc.lo" using_cgen=yes ;;
+	bfd_lobster128_arch) ta="$ta lobster128-dis.lo lobster128-opc.lo" ;;
 	bfd_lm32_arch)		ta="$ta lm32-asm.lo lm32-desc.lo lm32-dis.lo lm32-ibld.lo lm32-opc.lo lm32-opinst.lo" using_cgen=yes ;;
 	bfd_m32c_arch)		ta="$ta m32c-asm.lo m32c-desc.lo m32c-dis.lo m32c-ibld.lo m32c-opc.lo" using_cgen=yes ;;
 	bfd_m32r_arch)		ta="$ta m32r-asm.lo m32r-desc.lo m32r-dis.lo m32r-ibld.lo m32r-opc.lo m32r-opinst.lo" using_cgen=yes ;;
diff --git a/opcodes/lobster128-dis.c b/opcodes/lobster128-dis.c
new file mode 100644
index 00000000000..85cea475979
--- /dev/null
+++ b/opcodes/lobster128-dis.c
@@ -0,0 +1,80 @@
+/* Disassemble lobster128 instructions.
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This file is part of the GNU opcodes library.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include <stdio.h>
+
+#define STATIC_TABLE
+#define DEFINE_TABLE
+
+#include "opcode/lobster128.h"
+#include "disassemble.h"
+
+static fprintf_ftype fpr;
+static void *stream;
+
+static const char * reg_names[128] =
+    { "zero", "pc",   "sp",   "fp",   "r4",   "r5",   "r6",   "r7",
+      "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
+      "r16",  "r17",  "r18",  "r19",  "r20",  "r21",  "r22",  "r23",
+      "r24",  "r25",  "r26",  "r27",  "r28",  "r29",  "r30",  "r31",
+      "r32",  "r34",  "r35",  "r36",  "r37",  "r38",  "r39",  "r40",
+      "r41",  "r42",  "r43",  "r44",  "r45",  "r46",  "r47",  "r48",
+      "r49",  "r50",  "r51",  "r52",  "r53",  "r54",  "r55",  "r56",
+      "r57",  "r58",  "r59",  "r60",  "r61",  "r62",  "r63",  "r64",
+      "r65",  "r66",  "r67",  "r68",  "r69",  "r70",  "r71",  "r72",
+      "r73",  "r74",  "r75",  "r76",  "r77",  "r78",  "r79",  "r80",
+      "r81",  "r82",  "r83",  "r84",  "r85",  "r86",  "r87",  "r88",  
+      "r89",  "r90",  "r91",  "r92",  "r93",  "r94",  "r95",  "r96", 
+      "r97",  "r98",  "r99",  "r100", "r101", "r102", "r103", "r104", 
+      "r105", "r106", "r107", "r108", "r109", "r110", "r111", "r112", 
+      "r113", "r114", "r115", "r116", "r117", "r118", "r119", "r120", 
+      "r121", "r122", "r123", "r124", "r125", "r126", "r127", "r128" };
+
+static const char *op_names[16] = {
+  "add", "sub", "and", "not", "lsh", "rsh", "or", "xor", "mul", "div",
+  "bad", "rem", "sex", "push", "pop", "ext"
+};
+
+int
+print_insn_lobster128 (bfd_vma addr, struct disassemble_info * info)
+{
+  int status;
+  unsigned long iword;
+  bfd_byte buffer[4];
+  fpr = info->fprintf_func;
+  if ((status = info->read_memory_func (addr, buffer, 2, info)))
+    goto fail;
+  
+  /* We will start from the bottom down, micro insntruction first */
+  iword = bfd_getl16(buffer);
+  if(iword & 0x03 == PREFIX_MICROINST) {
+    char opcode = (iword >> 2) & 0x0f; /* Extract nibble 4-bits for opcode */
+    char rd = (iword >> 6) & 0x1f;
+    char rs = (iword >> 11) & 0x1f;
+    fpr(stream, "z.%s.r %s, %s\n", op_names[opcode & 0x0f], reg_names[rd], reg_names[rs]);
+  } else {
+    fpr(stream, "todo: non-micro insn\n");
+  }
+
+ fail:
+  info->memory_error_func (status, addr, info);
+  return -1;
+}
diff --git a/opcodes/lobster128-opc.c b/opcodes/lobster128-opc.c
new file mode 100644
index 00000000000..e53b159a035
--- /dev/null
+++ b/opcodes/lobster128-opc.c
@@ -0,0 +1,60 @@
+/* lobster128-opc.c -- Definitions for lobster128 opcodes.
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This file is part of the GNU opcodes library.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING.  If not, write to the
+   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "opcode/lobster128.h"
+
+#define PREFIX_MICROINST  0b00
+#define PREFIX_LONGINST   0b01
+#define PREFIX_REP        0b11
+
+#define XLU_ADD   0b0000
+#define XLU_SUB   0b0001
+#define XLU_AND   0b0010
+#define XLU_NOT   0b0011
+#define XLU_LSH   0b0100
+#define XLU_RSH   0b0101
+#define XLU_OR    0b0110
+#define XLU_XOR   0b0111
+#define XLU_MUL   0b1000
+#define XLU_DIV   0b1001
+#define XLU_REM   0b1011
+#define XLU_SEX   0b1100
+#define XLU_PUSH  0b1101
+#define XLU_POP   0b1110
+#define XLU_EXT   0b1111
+
+const lobster128_opc_info_t lobster128_opc_info[LOBSTER128_NUM_OPCODES] = {
+  { XLU_ADD | PREFIX_MICROINST, 0, LOBSTER128_MICRO_OP, "z.add.r" },
+  { XLU_SUB | PREFIX_MICROINST, 0, LOBSTER128_MICRO_OP, "z.sub.r" },
+  { XLU_AND | PREFIX_MICROINST, 0, LOBSTER128_MICRO_OP, "z.and.r" },
+  { XLU_NOT | PREFIX_MICROINST, 0, LOBSTER128_MICRO_OP, "z.not.r" },
+  { XLU_LSH | PREFIX_MICROINST, 0, LOBSTER128_MICRO_OP, "z.lsh.r" },
+  { XLU_RSH | PREFIX_MICROINST, 0, LOBSTER128_MICRO_OP, "z.rsh.r" },
+  { XLU_OR | PREFIX_MICROINST, 0, LOBSTER128_MICRO_OP, "z.or.r" },
+  { XLU_XOR | PREFIX_MICROINST, 0, LOBSTER128_MICRO_OP, "z.xor.r" },
+  { XLU_MUL | PREFIX_MICROINST, 0, LOBSTER128_MICRO_OP, "z.mul.r" },
+  { XLU_DIV | PREFIX_MICROINST, 0, LOBSTER128_MICRO_OP, "z.div.r" },
+  { XLU_REM | PREFIX_MICROINST, 0, LOBSTER128_MICRO_OP, "z.rem.r" },
+  { XLU_SEX | PREFIX_MICROINST, 0, LOBSTER128_MICRO_OP, "z.sex.r" },
+  { XLU_PUSH | PREFIX_MICROINST, 0, LOBSTER128_MICRO_OP, "z.push.r" },
+  { XLU_POP | PREFIX_MICROINST, 0, LOBSTER128_MICRO_OP, "z.pop.r" },
+  { XLU_EXT | PREFIX_MICROINST, 0, LOBSTER128_MICRO_OP, "z.ext.r" },
+};
